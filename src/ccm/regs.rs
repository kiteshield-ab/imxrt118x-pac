#[doc = "Clock root access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ClockRootAuthen(pub u32);
impl ClockRootAuthen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::ClockRootAuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::ClockRootAuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::ClockRootAuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::ClockRootAuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::ClockRootAuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::ClockRootAuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for ClockRootAuthen {
    #[inline(always)]
    fn default() -> ClockRootAuthen {
        ClockRootAuthen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for ClockRootAuthen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockRootAuthen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ClockRootAuthen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ClockRootAuthen {
            tz_user: super::vals::ClockRootAuthenTzUser,
            tz_ns: super::vals::ClockRootAuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = ClockRootAuthen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock Root Control Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ClockRootControl(pub u32);
impl ClockRootControl {
    #[doc = "Clock division fraction."]
    #[must_use]
    #[inline(always)]
    pub const fn div(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Clock division fraction."]
    #[inline(always)]
    pub const fn set_div(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Clock multiplexer."]
    #[must_use]
    #[inline(always)]
    pub const fn mux(&self) -> super::vals::Mux {
        let val = (self.0 >> 8usize) & 0x03;
        super::vals::Mux::from_bits(val as u8)
    }
    #[doc = "Clock multiplexer."]
    #[inline(always)]
    pub const fn set_mux(&mut self, val: super::vals::Mux) {
        self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
    }
    #[doc = "Shutdown clock root."]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> super::vals::ClockRootControlOff {
        let val = (self.0 >> 24usize) & 0x01;
        super::vals::ClockRootControlOff::from_bits(val as u8)
    }
    #[doc = "Shutdown clock root."]
    #[inline(always)]
    pub const fn set_off(&mut self, val: super::vals::ClockRootControlOff) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
    }
}
impl Default for ClockRootControl {
    #[inline(always)]
    fn default() -> ClockRootControl {
        ClockRootControl(0u64 as u32)
    }
}
impl core::fmt::Debug for ClockRootControl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockRootControl")
            .field("div", &self.div())
            .field("mux", &self.mux())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ClockRootControl {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ClockRootControl {
            div: u8,
            mux: super::vals::Mux,
            off: super::vals::ClockRootControlOff,
        }
        let proxy = ClockRootControl {
            div: self.div(),
            mux: self.mux(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock Root Control Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ClockRootControlClr(pub u32);
impl ClockRootControlClr {
    #[doc = "Clock division fraction."]
    #[must_use]
    #[inline(always)]
    pub const fn div(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Clock division fraction."]
    #[inline(always)]
    pub const fn set_div(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Clock multiplexer."]
    #[must_use]
    #[inline(always)]
    pub const fn mux(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0x03;
        val as u8
    }
    #[doc = "Clock multiplexer."]
    #[inline(always)]
    pub const fn set_mux(&mut self, val: u8) {
        self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
    }
    #[doc = "Shutdown clock root."]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "Shutdown clock root."]
    #[inline(always)]
    pub const fn set_off(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
}
impl Default for ClockRootControlClr {
    #[inline(always)]
    fn default() -> ClockRootControlClr {
        ClockRootControlClr(0u64 as u32)
    }
}
impl core::fmt::Debug for ClockRootControlClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockRootControlClr")
            .field("div", &self.div())
            .field("mux", &self.mux())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ClockRootControlClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ClockRootControlClr {
            div: u8,
            mux: u8,
            off: bool,
        }
        let proxy = ClockRootControlClr {
            div: self.div(),
            mux: self.mux(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock Root Control Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ClockRootControlSet(pub u32);
impl ClockRootControlSet {
    #[doc = "Clock division fraction."]
    #[must_use]
    #[inline(always)]
    pub const fn div(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Clock division fraction."]
    #[inline(always)]
    pub const fn set_div(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Clock multiplexer."]
    #[must_use]
    #[inline(always)]
    pub const fn mux(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0x03;
        val as u8
    }
    #[doc = "Clock multiplexer."]
    #[inline(always)]
    pub const fn set_mux(&mut self, val: u8) {
        self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
    }
    #[doc = "Shutdown clock root."]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "Shutdown clock root."]
    #[inline(always)]
    pub const fn set_off(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
}
impl Default for ClockRootControlSet {
    #[inline(always)]
    fn default() -> ClockRootControlSet {
        ClockRootControlSet(0u64 as u32)
    }
}
impl core::fmt::Debug for ClockRootControlSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockRootControlSet")
            .field("div", &self.div())
            .field("mux", &self.mux())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ClockRootControlSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ClockRootControlSet {
            div: u8,
            mux: u8,
            off: bool,
        }
        let proxy = ClockRootControlSet {
            div: self.div(),
            mux: self.mux(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock Root Control Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ClockRootControlTog(pub u32);
impl ClockRootControlTog {
    #[doc = "Clock division fraction."]
    #[must_use]
    #[inline(always)]
    pub const fn div(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Clock division fraction."]
    #[inline(always)]
    pub const fn set_div(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Clock multiplexer."]
    #[must_use]
    #[inline(always)]
    pub const fn mux(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0x03;
        val as u8
    }
    #[doc = "Clock multiplexer."]
    #[inline(always)]
    pub const fn set_mux(&mut self, val: u8) {
        self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
    }
    #[doc = "Shutdown clock root."]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "Shutdown clock root."]
    #[inline(always)]
    pub const fn set_off(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
}
impl Default for ClockRootControlTog {
    #[inline(always)]
    fn default() -> ClockRootControlTog {
        ClockRootControlTog(0u64 as u32)
    }
}
impl core::fmt::Debug for ClockRootControlTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockRootControlTog")
            .field("div", &self.div())
            .field("mux", &self.mux())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ClockRootControlTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ClockRootControlTog {
            div: u8,
            mux: u8,
            off: bool,
        }
        let proxy = ClockRootControlTog {
            div: self.div(),
            mux: self.mux(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock root working status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ClockRootStatus0(pub u32);
impl ClockRootStatus0 {
    #[doc = "Current clock root DIV setting"]
    #[must_use]
    #[inline(always)]
    pub const fn div(&self) -> u8 {
        let val = (self.0 >> 0usize) & 0xff;
        val as u8
    }
    #[doc = "Current clock root DIV setting"]
    #[inline(always)]
    pub const fn set_div(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
    }
    #[doc = "Current clock root MUX setting"]
    #[must_use]
    #[inline(always)]
    pub const fn mux(&self) -> u8 {
        let val = (self.0 >> 8usize) & 0x03;
        val as u8
    }
    #[doc = "Current clock root MUX setting"]
    #[inline(always)]
    pub const fn set_mux(&mut self, val: u8) {
        self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
    }
    #[doc = "Current clock root OFF setting"]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> super::vals::ClockRootStatus0Off {
        let val = (self.0 >> 24usize) & 0x01;
        super::vals::ClockRootStatus0Off::from_bits(val as u8)
    }
    #[doc = "Current clock root OFF setting"]
    #[inline(always)]
    pub const fn set_off(&mut self, val: super::vals::ClockRootStatus0Off) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
    }
    #[doc = "Internal updating in generation logic Indication for clock generation logic is applying new setting."]
    #[must_use]
    #[inline(always)]
    pub const fn slice_busy(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "Internal updating in generation logic Indication for clock generation logic is applying new setting."]
    #[inline(always)]
    pub const fn set_slice_busy(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "Indication for clock root internal logic is updating. This status is a combination of UPDATE_FORWARD and SLICE_BUSY."]
    #[must_use]
    #[inline(always)]
    pub const fn changing(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Indication for clock root internal logic is updating. This status is a combination of UPDATE_FORWARD and SLICE_BUSY."]
    #[inline(always)]
    pub const fn set_changing(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for ClockRootStatus0 {
    #[inline(always)]
    fn default() -> ClockRootStatus0 {
        ClockRootStatus0(0u64 as u32)
    }
}
impl core::fmt::Debug for ClockRootStatus0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockRootStatus0")
            .field("div", &self.div())
            .field("mux", &self.mux())
            .field("off", &self.off())
            .field("slice_busy", &self.slice_busy())
            .field("changing", &self.changing())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ClockRootStatus0 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ClockRootStatus0 {
            div: u8,
            mux: u8,
            off: super::vals::ClockRootStatus0Off,
            slice_busy: bool,
            changing: bool,
        }
        let proxy = ClockRootStatus0 {
            div: self.div(),
            mux: self.mux(),
            off: self.off(),
            slice_busy: self.slice_busy(),
            changing: self.changing(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprPrivateAuthen(pub u32);
impl GprPrivateAuthen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprPrivateAuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprPrivateAuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprPrivateAuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprPrivateAuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprPrivateAuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprPrivateAuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprPrivateAuthen {
    #[inline(always)]
    fn default() -> GprPrivateAuthen {
        GprPrivateAuthen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprPrivateAuthen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprPrivateAuthen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprPrivateAuthen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprPrivateAuthen {
            tz_user: super::vals::GprPrivateAuthenTzUser,
            tz_ns: super::vals::GprPrivateAuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprPrivateAuthen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprPrivateAuthenClr(pub u32);
impl GprPrivateAuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprPrivateAuthenClr {
    #[inline(always)]
    fn default() -> GprPrivateAuthenClr {
        GprPrivateAuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprPrivateAuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprPrivateAuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprPrivateAuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprPrivateAuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprPrivateAuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprPrivateAuthenSet(pub u32);
impl GprPrivateAuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprPrivateAuthenSet {
    #[inline(always)]
    fn default() -> GprPrivateAuthenSet {
        GprPrivateAuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprPrivateAuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprPrivateAuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprPrivateAuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprPrivateAuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprPrivateAuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprPrivateAuthenTog(pub u32);
impl GprPrivateAuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprPrivateAuthenTog {
    #[inline(always)]
    fn default() -> GprPrivateAuthenTog {
        GprPrivateAuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprPrivateAuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprPrivateAuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprPrivateAuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprPrivateAuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprPrivateAuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared0Authen(pub u32);
impl GprShared0Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared0AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared0AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared0AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared0AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared0AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared0AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared0Authen {
    #[inline(always)]
    fn default() -> GprShared0Authen {
        GprShared0Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared0Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared0Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared0Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared0Authen {
            tz_user: super::vals::GprShared0AuthenTzUser,
            tz_ns: super::vals::GprShared0AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared0Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared0AuthenClr(pub u32);
impl GprShared0AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared0AuthenClr {
    #[inline(always)]
    fn default() -> GprShared0AuthenClr {
        GprShared0AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared0AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared0AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared0AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared0AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared0AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared0AuthenSet(pub u32);
impl GprShared0AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared0AuthenSet {
    #[inline(always)]
    fn default() -> GprShared0AuthenSet {
        GprShared0AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared0AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared0AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared0AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared0AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared0AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared0AuthenTog(pub u32);
impl GprShared0AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared0AuthenTog {
    #[inline(always)]
    fn default() -> GprShared0AuthenTog {
        GprShared0AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared0AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared0AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared0AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared0AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared0AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10(pub u32);
impl GprShared10 {
    #[doc = "m33_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared10 {
    #[inline(always)]
    fn default() -> GprShared10 {
        GprShared10(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10")
            .field("m33_adc1_ipg_doze", &self.m33_adc1_ipg_doze())
            .field("m33_adc2_ipg_doze", &self.m33_adc2_ipg_doze())
            .field("m33_flexspi1_ipg_doze", &self.m33_flexspi1_ipg_doze())
            .field("m33_flexspi2_ipg_doze", &self.m33_flexspi2_ipg_doze())
            .field("m33_flexio1_ipg_doze", &self.m33_flexio1_ipg_doze())
            .field("m33_flexio2_ipg_doze", &self.m33_flexio2_ipg_doze())
            .field("m33_lpit1_ipg_doze", &self.m33_lpit1_ipg_doze())
            .field("m33_lpit2_ipg_doze", &self.m33_lpit2_ipg_doze())
            .field("m33_lpit3_ipg_doze", &self.m33_lpit3_ipg_doze())
            .field("m33_tpm1_ipg_doze", &self.m33_tpm1_ipg_doze())
            .field("m33_tpm2_ipg_doze", &self.m33_tpm2_ipg_doze())
            .field("m33_tpm3_ipg_doze", &self.m33_tpm3_ipg_doze())
            .field("m33_tpm4_ipg_doze", &self.m33_tpm4_ipg_doze())
            .field("m33_tpm5_ipg_doze", &self.m33_tpm5_ipg_doze())
            .field("m33_tpm6_ipg_doze", &self.m33_tpm6_ipg_doze())
            .field("m33_gpt1_ipg_doze", &self.m33_gpt1_ipg_doze())
            .field("m33_gpt2_ipg_doze", &self.m33_gpt2_ipg_doze())
            .field("m33_can1_ipg_doze", &self.m33_can1_ipg_doze())
            .field("m33_can2_ipg_doze", &self.m33_can2_ipg_doze())
            .field("m33_can3_ipg_doze", &self.m33_can3_ipg_doze())
            .field("m33_lpuart1_ipg_doze", &self.m33_lpuart1_ipg_doze())
            .field("m33_lpuart2_ipg_doze", &self.m33_lpuart2_ipg_doze())
            .field("m33_lpuart3_ipg_doze", &self.m33_lpuart3_ipg_doze())
            .field("m33_lpuart4_ipg_doze", &self.m33_lpuart4_ipg_doze())
            .field("m33_lpuart5_ipg_doze", &self.m33_lpuart5_ipg_doze())
            .field("m33_lpuart6_ipg_doze", &self.m33_lpuart6_ipg_doze())
            .field("m33_lpuart7_ipg_doze", &self.m33_lpuart7_ipg_doze())
            .field("m33_lpuart8_ipg_doze", &self.m33_lpuart8_ipg_doze())
            .field("m33_lpuart9_ipg_doze", &self.m33_lpuart9_ipg_doze())
            .field("m33_lpuart10_ipg_doze", &self.m33_lpuart10_ipg_doze())
            .field("m33_lpuart11_ipg_doze", &self.m33_lpuart11_ipg_doze())
            .field("m33_lpuart12_ipg_doze", &self.m33_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10 {
            m33_adc1_ipg_doze: bool,
            m33_adc2_ipg_doze: bool,
            m33_flexspi1_ipg_doze: bool,
            m33_flexspi2_ipg_doze: bool,
            m33_flexio1_ipg_doze: bool,
            m33_flexio2_ipg_doze: bool,
            m33_lpit1_ipg_doze: bool,
            m33_lpit2_ipg_doze: bool,
            m33_lpit3_ipg_doze: bool,
            m33_tpm1_ipg_doze: bool,
            m33_tpm2_ipg_doze: bool,
            m33_tpm3_ipg_doze: bool,
            m33_tpm4_ipg_doze: bool,
            m33_tpm5_ipg_doze: bool,
            m33_tpm6_ipg_doze: bool,
            m33_gpt1_ipg_doze: bool,
            m33_gpt2_ipg_doze: bool,
            m33_can1_ipg_doze: bool,
            m33_can2_ipg_doze: bool,
            m33_can3_ipg_doze: bool,
            m33_lpuart1_ipg_doze: bool,
            m33_lpuart2_ipg_doze: bool,
            m33_lpuart3_ipg_doze: bool,
            m33_lpuart4_ipg_doze: bool,
            m33_lpuart5_ipg_doze: bool,
            m33_lpuart6_ipg_doze: bool,
            m33_lpuart7_ipg_doze: bool,
            m33_lpuart8_ipg_doze: bool,
            m33_lpuart9_ipg_doze: bool,
            m33_lpuart10_ipg_doze: bool,
            m33_lpuart11_ipg_doze: bool,
            m33_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared10 {
            m33_adc1_ipg_doze: self.m33_adc1_ipg_doze(),
            m33_adc2_ipg_doze: self.m33_adc2_ipg_doze(),
            m33_flexspi1_ipg_doze: self.m33_flexspi1_ipg_doze(),
            m33_flexspi2_ipg_doze: self.m33_flexspi2_ipg_doze(),
            m33_flexio1_ipg_doze: self.m33_flexio1_ipg_doze(),
            m33_flexio2_ipg_doze: self.m33_flexio2_ipg_doze(),
            m33_lpit1_ipg_doze: self.m33_lpit1_ipg_doze(),
            m33_lpit2_ipg_doze: self.m33_lpit2_ipg_doze(),
            m33_lpit3_ipg_doze: self.m33_lpit3_ipg_doze(),
            m33_tpm1_ipg_doze: self.m33_tpm1_ipg_doze(),
            m33_tpm2_ipg_doze: self.m33_tpm2_ipg_doze(),
            m33_tpm3_ipg_doze: self.m33_tpm3_ipg_doze(),
            m33_tpm4_ipg_doze: self.m33_tpm4_ipg_doze(),
            m33_tpm5_ipg_doze: self.m33_tpm5_ipg_doze(),
            m33_tpm6_ipg_doze: self.m33_tpm6_ipg_doze(),
            m33_gpt1_ipg_doze: self.m33_gpt1_ipg_doze(),
            m33_gpt2_ipg_doze: self.m33_gpt2_ipg_doze(),
            m33_can1_ipg_doze: self.m33_can1_ipg_doze(),
            m33_can2_ipg_doze: self.m33_can2_ipg_doze(),
            m33_can3_ipg_doze: self.m33_can3_ipg_doze(),
            m33_lpuart1_ipg_doze: self.m33_lpuart1_ipg_doze(),
            m33_lpuart2_ipg_doze: self.m33_lpuart2_ipg_doze(),
            m33_lpuart3_ipg_doze: self.m33_lpuart3_ipg_doze(),
            m33_lpuart4_ipg_doze: self.m33_lpuart4_ipg_doze(),
            m33_lpuart5_ipg_doze: self.m33_lpuart5_ipg_doze(),
            m33_lpuart6_ipg_doze: self.m33_lpuart6_ipg_doze(),
            m33_lpuart7_ipg_doze: self.m33_lpuart7_ipg_doze(),
            m33_lpuart8_ipg_doze: self.m33_lpuart8_ipg_doze(),
            m33_lpuart9_ipg_doze: self.m33_lpuart9_ipg_doze(),
            m33_lpuart10_ipg_doze: self.m33_lpuart10_ipg_doze(),
            m33_lpuart11_ipg_doze: self.m33_lpuart11_ipg_doze(),
            m33_lpuart12_ipg_doze: self.m33_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10Authen(pub u32);
impl GprShared10Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared10AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared10AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared10AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared10AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared10AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared10AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared10Authen {
    #[inline(always)]
    fn default() -> GprShared10Authen {
        GprShared10Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10Authen {
            tz_user: super::vals::GprShared10AuthenTzUser,
            tz_ns: super::vals::GprShared10AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared10Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10AuthenClr(pub u32);
impl GprShared10AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared10AuthenClr {
    #[inline(always)]
    fn default() -> GprShared10AuthenClr {
        GprShared10AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared10AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10AuthenSet(pub u32);
impl GprShared10AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared10AuthenSet {
    #[inline(always)]
    fn default() -> GprShared10AuthenSet {
        GprShared10AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared10AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10AuthenTog(pub u32);
impl GprShared10AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared10AuthenTog {
    #[inline(always)]
    fn default() -> GprShared10AuthenTog {
        GprShared10AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared10AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10Clr(pub u32);
impl GprShared10Clr {
    #[doc = "m33_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared10Clr {
    #[inline(always)]
    fn default() -> GprShared10Clr {
        GprShared10Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10Clr")
            .field("m33_adc1_ipg_doze", &self.m33_adc1_ipg_doze())
            .field("m33_adc2_ipg_doze", &self.m33_adc2_ipg_doze())
            .field("m33_flexspi1_ipg_doze", &self.m33_flexspi1_ipg_doze())
            .field("m33_flexspi2_ipg_doze", &self.m33_flexspi2_ipg_doze())
            .field("m33_flexio1_ipg_doze", &self.m33_flexio1_ipg_doze())
            .field("m33_flexio2_ipg_doze", &self.m33_flexio2_ipg_doze())
            .field("m33_lpit1_ipg_doze", &self.m33_lpit1_ipg_doze())
            .field("m33_lpit2_ipg_doze", &self.m33_lpit2_ipg_doze())
            .field("m33_lpit3_ipg_doze", &self.m33_lpit3_ipg_doze())
            .field("m33_tpm1_ipg_doze", &self.m33_tpm1_ipg_doze())
            .field("m33_tpm2_ipg_doze", &self.m33_tpm2_ipg_doze())
            .field("m33_tpm3_ipg_doze", &self.m33_tpm3_ipg_doze())
            .field("m33_tpm4_ipg_doze", &self.m33_tpm4_ipg_doze())
            .field("m33_tpm5_ipg_doze", &self.m33_tpm5_ipg_doze())
            .field("m33_tpm6_ipg_doze", &self.m33_tpm6_ipg_doze())
            .field("m33_gpt1_ipg_doze", &self.m33_gpt1_ipg_doze())
            .field("m33_gpt2_ipg_doze", &self.m33_gpt2_ipg_doze())
            .field("m33_can1_ipg_doze", &self.m33_can1_ipg_doze())
            .field("m33_can2_ipg_doze", &self.m33_can2_ipg_doze())
            .field("m33_can3_ipg_doze", &self.m33_can3_ipg_doze())
            .field("m33_lpuart1_ipg_doze", &self.m33_lpuart1_ipg_doze())
            .field("m33_lpuart2_ipg_doze", &self.m33_lpuart2_ipg_doze())
            .field("m33_lpuart3_ipg_doze", &self.m33_lpuart3_ipg_doze())
            .field("m33_lpuart4_ipg_doze", &self.m33_lpuart4_ipg_doze())
            .field("m33_lpuart5_ipg_doze", &self.m33_lpuart5_ipg_doze())
            .field("m33_lpuart6_ipg_doze", &self.m33_lpuart6_ipg_doze())
            .field("m33_lpuart7_ipg_doze", &self.m33_lpuart7_ipg_doze())
            .field("m33_lpuart8_ipg_doze", &self.m33_lpuart8_ipg_doze())
            .field("m33_lpuart9_ipg_doze", &self.m33_lpuart9_ipg_doze())
            .field("m33_lpuart10_ipg_doze", &self.m33_lpuart10_ipg_doze())
            .field("m33_lpuart11_ipg_doze", &self.m33_lpuart11_ipg_doze())
            .field("m33_lpuart12_ipg_doze", &self.m33_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10Clr {
            m33_adc1_ipg_doze: bool,
            m33_adc2_ipg_doze: bool,
            m33_flexspi1_ipg_doze: bool,
            m33_flexspi2_ipg_doze: bool,
            m33_flexio1_ipg_doze: bool,
            m33_flexio2_ipg_doze: bool,
            m33_lpit1_ipg_doze: bool,
            m33_lpit2_ipg_doze: bool,
            m33_lpit3_ipg_doze: bool,
            m33_tpm1_ipg_doze: bool,
            m33_tpm2_ipg_doze: bool,
            m33_tpm3_ipg_doze: bool,
            m33_tpm4_ipg_doze: bool,
            m33_tpm5_ipg_doze: bool,
            m33_tpm6_ipg_doze: bool,
            m33_gpt1_ipg_doze: bool,
            m33_gpt2_ipg_doze: bool,
            m33_can1_ipg_doze: bool,
            m33_can2_ipg_doze: bool,
            m33_can3_ipg_doze: bool,
            m33_lpuart1_ipg_doze: bool,
            m33_lpuart2_ipg_doze: bool,
            m33_lpuart3_ipg_doze: bool,
            m33_lpuart4_ipg_doze: bool,
            m33_lpuart5_ipg_doze: bool,
            m33_lpuart6_ipg_doze: bool,
            m33_lpuart7_ipg_doze: bool,
            m33_lpuart8_ipg_doze: bool,
            m33_lpuart9_ipg_doze: bool,
            m33_lpuart10_ipg_doze: bool,
            m33_lpuart11_ipg_doze: bool,
            m33_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared10Clr {
            m33_adc1_ipg_doze: self.m33_adc1_ipg_doze(),
            m33_adc2_ipg_doze: self.m33_adc2_ipg_doze(),
            m33_flexspi1_ipg_doze: self.m33_flexspi1_ipg_doze(),
            m33_flexspi2_ipg_doze: self.m33_flexspi2_ipg_doze(),
            m33_flexio1_ipg_doze: self.m33_flexio1_ipg_doze(),
            m33_flexio2_ipg_doze: self.m33_flexio2_ipg_doze(),
            m33_lpit1_ipg_doze: self.m33_lpit1_ipg_doze(),
            m33_lpit2_ipg_doze: self.m33_lpit2_ipg_doze(),
            m33_lpit3_ipg_doze: self.m33_lpit3_ipg_doze(),
            m33_tpm1_ipg_doze: self.m33_tpm1_ipg_doze(),
            m33_tpm2_ipg_doze: self.m33_tpm2_ipg_doze(),
            m33_tpm3_ipg_doze: self.m33_tpm3_ipg_doze(),
            m33_tpm4_ipg_doze: self.m33_tpm4_ipg_doze(),
            m33_tpm5_ipg_doze: self.m33_tpm5_ipg_doze(),
            m33_tpm6_ipg_doze: self.m33_tpm6_ipg_doze(),
            m33_gpt1_ipg_doze: self.m33_gpt1_ipg_doze(),
            m33_gpt2_ipg_doze: self.m33_gpt2_ipg_doze(),
            m33_can1_ipg_doze: self.m33_can1_ipg_doze(),
            m33_can2_ipg_doze: self.m33_can2_ipg_doze(),
            m33_can3_ipg_doze: self.m33_can3_ipg_doze(),
            m33_lpuart1_ipg_doze: self.m33_lpuart1_ipg_doze(),
            m33_lpuart2_ipg_doze: self.m33_lpuart2_ipg_doze(),
            m33_lpuart3_ipg_doze: self.m33_lpuart3_ipg_doze(),
            m33_lpuart4_ipg_doze: self.m33_lpuart4_ipg_doze(),
            m33_lpuart5_ipg_doze: self.m33_lpuart5_ipg_doze(),
            m33_lpuart6_ipg_doze: self.m33_lpuart6_ipg_doze(),
            m33_lpuart7_ipg_doze: self.m33_lpuart7_ipg_doze(),
            m33_lpuart8_ipg_doze: self.m33_lpuart8_ipg_doze(),
            m33_lpuart9_ipg_doze: self.m33_lpuart9_ipg_doze(),
            m33_lpuart10_ipg_doze: self.m33_lpuart10_ipg_doze(),
            m33_lpuart11_ipg_doze: self.m33_lpuart11_ipg_doze(),
            m33_lpuart12_ipg_doze: self.m33_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10Set(pub u32);
impl GprShared10Set {
    #[doc = "m33_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared10Set {
    #[inline(always)]
    fn default() -> GprShared10Set {
        GprShared10Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10Set")
            .field("m33_adc1_ipg_doze", &self.m33_adc1_ipg_doze())
            .field("m33_adc2_ipg_doze", &self.m33_adc2_ipg_doze())
            .field("m33_flexspi1_ipg_doze", &self.m33_flexspi1_ipg_doze())
            .field("m33_flexspi2_ipg_doze", &self.m33_flexspi2_ipg_doze())
            .field("m33_flexio1_ipg_doze", &self.m33_flexio1_ipg_doze())
            .field("m33_flexio2_ipg_doze", &self.m33_flexio2_ipg_doze())
            .field("m33_lpit1_ipg_doze", &self.m33_lpit1_ipg_doze())
            .field("m33_lpit2_ipg_doze", &self.m33_lpit2_ipg_doze())
            .field("m33_lpit3_ipg_doze", &self.m33_lpit3_ipg_doze())
            .field("m33_tpm1_ipg_doze", &self.m33_tpm1_ipg_doze())
            .field("m33_tpm2_ipg_doze", &self.m33_tpm2_ipg_doze())
            .field("m33_tpm3_ipg_doze", &self.m33_tpm3_ipg_doze())
            .field("m33_tpm4_ipg_doze", &self.m33_tpm4_ipg_doze())
            .field("m33_tpm5_ipg_doze", &self.m33_tpm5_ipg_doze())
            .field("m33_tpm6_ipg_doze", &self.m33_tpm6_ipg_doze())
            .field("m33_gpt1_ipg_doze", &self.m33_gpt1_ipg_doze())
            .field("m33_gpt2_ipg_doze", &self.m33_gpt2_ipg_doze())
            .field("m33_can1_ipg_doze", &self.m33_can1_ipg_doze())
            .field("m33_can2_ipg_doze", &self.m33_can2_ipg_doze())
            .field("m33_can3_ipg_doze", &self.m33_can3_ipg_doze())
            .field("m33_lpuart1_ipg_doze", &self.m33_lpuart1_ipg_doze())
            .field("m33_lpuart2_ipg_doze", &self.m33_lpuart2_ipg_doze())
            .field("m33_lpuart3_ipg_doze", &self.m33_lpuart3_ipg_doze())
            .field("m33_lpuart4_ipg_doze", &self.m33_lpuart4_ipg_doze())
            .field("m33_lpuart5_ipg_doze", &self.m33_lpuart5_ipg_doze())
            .field("m33_lpuart6_ipg_doze", &self.m33_lpuart6_ipg_doze())
            .field("m33_lpuart7_ipg_doze", &self.m33_lpuart7_ipg_doze())
            .field("m33_lpuart8_ipg_doze", &self.m33_lpuart8_ipg_doze())
            .field("m33_lpuart9_ipg_doze", &self.m33_lpuart9_ipg_doze())
            .field("m33_lpuart10_ipg_doze", &self.m33_lpuart10_ipg_doze())
            .field("m33_lpuart11_ipg_doze", &self.m33_lpuart11_ipg_doze())
            .field("m33_lpuart12_ipg_doze", &self.m33_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10Set {
            m33_adc1_ipg_doze: bool,
            m33_adc2_ipg_doze: bool,
            m33_flexspi1_ipg_doze: bool,
            m33_flexspi2_ipg_doze: bool,
            m33_flexio1_ipg_doze: bool,
            m33_flexio2_ipg_doze: bool,
            m33_lpit1_ipg_doze: bool,
            m33_lpit2_ipg_doze: bool,
            m33_lpit3_ipg_doze: bool,
            m33_tpm1_ipg_doze: bool,
            m33_tpm2_ipg_doze: bool,
            m33_tpm3_ipg_doze: bool,
            m33_tpm4_ipg_doze: bool,
            m33_tpm5_ipg_doze: bool,
            m33_tpm6_ipg_doze: bool,
            m33_gpt1_ipg_doze: bool,
            m33_gpt2_ipg_doze: bool,
            m33_can1_ipg_doze: bool,
            m33_can2_ipg_doze: bool,
            m33_can3_ipg_doze: bool,
            m33_lpuart1_ipg_doze: bool,
            m33_lpuart2_ipg_doze: bool,
            m33_lpuart3_ipg_doze: bool,
            m33_lpuart4_ipg_doze: bool,
            m33_lpuart5_ipg_doze: bool,
            m33_lpuart6_ipg_doze: bool,
            m33_lpuart7_ipg_doze: bool,
            m33_lpuart8_ipg_doze: bool,
            m33_lpuart9_ipg_doze: bool,
            m33_lpuart10_ipg_doze: bool,
            m33_lpuart11_ipg_doze: bool,
            m33_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared10Set {
            m33_adc1_ipg_doze: self.m33_adc1_ipg_doze(),
            m33_adc2_ipg_doze: self.m33_adc2_ipg_doze(),
            m33_flexspi1_ipg_doze: self.m33_flexspi1_ipg_doze(),
            m33_flexspi2_ipg_doze: self.m33_flexspi2_ipg_doze(),
            m33_flexio1_ipg_doze: self.m33_flexio1_ipg_doze(),
            m33_flexio2_ipg_doze: self.m33_flexio2_ipg_doze(),
            m33_lpit1_ipg_doze: self.m33_lpit1_ipg_doze(),
            m33_lpit2_ipg_doze: self.m33_lpit2_ipg_doze(),
            m33_lpit3_ipg_doze: self.m33_lpit3_ipg_doze(),
            m33_tpm1_ipg_doze: self.m33_tpm1_ipg_doze(),
            m33_tpm2_ipg_doze: self.m33_tpm2_ipg_doze(),
            m33_tpm3_ipg_doze: self.m33_tpm3_ipg_doze(),
            m33_tpm4_ipg_doze: self.m33_tpm4_ipg_doze(),
            m33_tpm5_ipg_doze: self.m33_tpm5_ipg_doze(),
            m33_tpm6_ipg_doze: self.m33_tpm6_ipg_doze(),
            m33_gpt1_ipg_doze: self.m33_gpt1_ipg_doze(),
            m33_gpt2_ipg_doze: self.m33_gpt2_ipg_doze(),
            m33_can1_ipg_doze: self.m33_can1_ipg_doze(),
            m33_can2_ipg_doze: self.m33_can2_ipg_doze(),
            m33_can3_ipg_doze: self.m33_can3_ipg_doze(),
            m33_lpuart1_ipg_doze: self.m33_lpuart1_ipg_doze(),
            m33_lpuart2_ipg_doze: self.m33_lpuart2_ipg_doze(),
            m33_lpuart3_ipg_doze: self.m33_lpuart3_ipg_doze(),
            m33_lpuart4_ipg_doze: self.m33_lpuart4_ipg_doze(),
            m33_lpuart5_ipg_doze: self.m33_lpuart5_ipg_doze(),
            m33_lpuart6_ipg_doze: self.m33_lpuart6_ipg_doze(),
            m33_lpuart7_ipg_doze: self.m33_lpuart7_ipg_doze(),
            m33_lpuart8_ipg_doze: self.m33_lpuart8_ipg_doze(),
            m33_lpuart9_ipg_doze: self.m33_lpuart9_ipg_doze(),
            m33_lpuart10_ipg_doze: self.m33_lpuart10_ipg_doze(),
            m33_lpuart11_ipg_doze: self.m33_lpuart11_ipg_doze(),
            m33_lpuart12_ipg_doze: self.m33_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared10Tog(pub u32);
impl GprShared10Tog {
    #[doc = "m33_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared10Tog {
    #[inline(always)]
    fn default() -> GprShared10Tog {
        GprShared10Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared10Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared10Tog")
            .field("m33_adc1_ipg_doze", &self.m33_adc1_ipg_doze())
            .field("m33_adc2_ipg_doze", &self.m33_adc2_ipg_doze())
            .field("m33_flexspi1_ipg_doze", &self.m33_flexspi1_ipg_doze())
            .field("m33_flexspi2_ipg_doze", &self.m33_flexspi2_ipg_doze())
            .field("m33_flexio1_ipg_doze", &self.m33_flexio1_ipg_doze())
            .field("m33_flexio2_ipg_doze", &self.m33_flexio2_ipg_doze())
            .field("m33_lpit1_ipg_doze", &self.m33_lpit1_ipg_doze())
            .field("m33_lpit2_ipg_doze", &self.m33_lpit2_ipg_doze())
            .field("m33_lpit3_ipg_doze", &self.m33_lpit3_ipg_doze())
            .field("m33_tpm1_ipg_doze", &self.m33_tpm1_ipg_doze())
            .field("m33_tpm2_ipg_doze", &self.m33_tpm2_ipg_doze())
            .field("m33_tpm3_ipg_doze", &self.m33_tpm3_ipg_doze())
            .field("m33_tpm4_ipg_doze", &self.m33_tpm4_ipg_doze())
            .field("m33_tpm5_ipg_doze", &self.m33_tpm5_ipg_doze())
            .field("m33_tpm6_ipg_doze", &self.m33_tpm6_ipg_doze())
            .field("m33_gpt1_ipg_doze", &self.m33_gpt1_ipg_doze())
            .field("m33_gpt2_ipg_doze", &self.m33_gpt2_ipg_doze())
            .field("m33_can1_ipg_doze", &self.m33_can1_ipg_doze())
            .field("m33_can2_ipg_doze", &self.m33_can2_ipg_doze())
            .field("m33_can3_ipg_doze", &self.m33_can3_ipg_doze())
            .field("m33_lpuart1_ipg_doze", &self.m33_lpuart1_ipg_doze())
            .field("m33_lpuart2_ipg_doze", &self.m33_lpuart2_ipg_doze())
            .field("m33_lpuart3_ipg_doze", &self.m33_lpuart3_ipg_doze())
            .field("m33_lpuart4_ipg_doze", &self.m33_lpuart4_ipg_doze())
            .field("m33_lpuart5_ipg_doze", &self.m33_lpuart5_ipg_doze())
            .field("m33_lpuart6_ipg_doze", &self.m33_lpuart6_ipg_doze())
            .field("m33_lpuart7_ipg_doze", &self.m33_lpuart7_ipg_doze())
            .field("m33_lpuart8_ipg_doze", &self.m33_lpuart8_ipg_doze())
            .field("m33_lpuart9_ipg_doze", &self.m33_lpuart9_ipg_doze())
            .field("m33_lpuart10_ipg_doze", &self.m33_lpuart10_ipg_doze())
            .field("m33_lpuart11_ipg_doze", &self.m33_lpuart11_ipg_doze())
            .field("m33_lpuart12_ipg_doze", &self.m33_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared10Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared10Tog {
            m33_adc1_ipg_doze: bool,
            m33_adc2_ipg_doze: bool,
            m33_flexspi1_ipg_doze: bool,
            m33_flexspi2_ipg_doze: bool,
            m33_flexio1_ipg_doze: bool,
            m33_flexio2_ipg_doze: bool,
            m33_lpit1_ipg_doze: bool,
            m33_lpit2_ipg_doze: bool,
            m33_lpit3_ipg_doze: bool,
            m33_tpm1_ipg_doze: bool,
            m33_tpm2_ipg_doze: bool,
            m33_tpm3_ipg_doze: bool,
            m33_tpm4_ipg_doze: bool,
            m33_tpm5_ipg_doze: bool,
            m33_tpm6_ipg_doze: bool,
            m33_gpt1_ipg_doze: bool,
            m33_gpt2_ipg_doze: bool,
            m33_can1_ipg_doze: bool,
            m33_can2_ipg_doze: bool,
            m33_can3_ipg_doze: bool,
            m33_lpuart1_ipg_doze: bool,
            m33_lpuart2_ipg_doze: bool,
            m33_lpuart3_ipg_doze: bool,
            m33_lpuart4_ipg_doze: bool,
            m33_lpuart5_ipg_doze: bool,
            m33_lpuart6_ipg_doze: bool,
            m33_lpuart7_ipg_doze: bool,
            m33_lpuart8_ipg_doze: bool,
            m33_lpuart9_ipg_doze: bool,
            m33_lpuart10_ipg_doze: bool,
            m33_lpuart11_ipg_doze: bool,
            m33_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared10Tog {
            m33_adc1_ipg_doze: self.m33_adc1_ipg_doze(),
            m33_adc2_ipg_doze: self.m33_adc2_ipg_doze(),
            m33_flexspi1_ipg_doze: self.m33_flexspi1_ipg_doze(),
            m33_flexspi2_ipg_doze: self.m33_flexspi2_ipg_doze(),
            m33_flexio1_ipg_doze: self.m33_flexio1_ipg_doze(),
            m33_flexio2_ipg_doze: self.m33_flexio2_ipg_doze(),
            m33_lpit1_ipg_doze: self.m33_lpit1_ipg_doze(),
            m33_lpit2_ipg_doze: self.m33_lpit2_ipg_doze(),
            m33_lpit3_ipg_doze: self.m33_lpit3_ipg_doze(),
            m33_tpm1_ipg_doze: self.m33_tpm1_ipg_doze(),
            m33_tpm2_ipg_doze: self.m33_tpm2_ipg_doze(),
            m33_tpm3_ipg_doze: self.m33_tpm3_ipg_doze(),
            m33_tpm4_ipg_doze: self.m33_tpm4_ipg_doze(),
            m33_tpm5_ipg_doze: self.m33_tpm5_ipg_doze(),
            m33_tpm6_ipg_doze: self.m33_tpm6_ipg_doze(),
            m33_gpt1_ipg_doze: self.m33_gpt1_ipg_doze(),
            m33_gpt2_ipg_doze: self.m33_gpt2_ipg_doze(),
            m33_can1_ipg_doze: self.m33_can1_ipg_doze(),
            m33_can2_ipg_doze: self.m33_can2_ipg_doze(),
            m33_can3_ipg_doze: self.m33_can3_ipg_doze(),
            m33_lpuart1_ipg_doze: self.m33_lpuart1_ipg_doze(),
            m33_lpuart2_ipg_doze: self.m33_lpuart2_ipg_doze(),
            m33_lpuart3_ipg_doze: self.m33_lpuart3_ipg_doze(),
            m33_lpuart4_ipg_doze: self.m33_lpuart4_ipg_doze(),
            m33_lpuart5_ipg_doze: self.m33_lpuart5_ipg_doze(),
            m33_lpuart6_ipg_doze: self.m33_lpuart6_ipg_doze(),
            m33_lpuart7_ipg_doze: self.m33_lpuart7_ipg_doze(),
            m33_lpuart8_ipg_doze: self.m33_lpuart8_ipg_doze(),
            m33_lpuart9_ipg_doze: self.m33_lpuart9_ipg_doze(),
            m33_lpuart10_ipg_doze: self.m33_lpuart10_ipg_doze(),
            m33_lpuart11_ipg_doze: self.m33_lpuart11_ipg_doze(),
            m33_lpuart12_ipg_doze: self.m33_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11(pub u32);
impl GprShared11 {
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared11 {
    #[inline(always)]
    fn default() -> GprShared11 {
        GprShared11(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11")
            .field("m33_lpi2c1_ipg_doze", &self.m33_lpi2c1_ipg_doze())
            .field("m33_lpi2c2_ipg_doze", &self.m33_lpi2c2_ipg_doze())
            .field("m33_lpi2c3_ipg_doze", &self.m33_lpi2c3_ipg_doze())
            .field("m33_lpi2c4_ipg_doze", &self.m33_lpi2c4_ipg_doze())
            .field("m33_lpi2c5_ipg_doze", &self.m33_lpi2c5_ipg_doze())
            .field("m33_lpi2c6_ipg_doze", &self.m33_lpi2c6_ipg_doze())
            .field("m33_lpspi1_ipg_doze", &self.m33_lpspi1_ipg_doze())
            .field("m33_lpspi2_ipg_doze", &self.m33_lpspi2_ipg_doze())
            .field("m33_lpspi3_ipg_doze", &self.m33_lpspi3_ipg_doze())
            .field("m33_lpspi4_ipg_doze", &self.m33_lpspi4_ipg_doze())
            .field("m33_lpspi5_ipg_doze", &self.m33_lpspi5_ipg_doze())
            .field("m33_lpspi6_ipg_doze", &self.m33_lpspi6_ipg_doze())
            .field("m33_sinc1_ipg_doze", &self.m33_sinc1_ipg_doze())
            .field("m33_sinc2_ipg_doze", &self.m33_sinc2_ipg_doze())
            .field("m33_sinc3_ipg_doze", &self.m33_sinc3_ipg_doze())
            .field("m33_mic_ipg_doze", &self.m33_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11 {
            m33_lpi2c1_ipg_doze: bool,
            m33_lpi2c2_ipg_doze: bool,
            m33_lpi2c3_ipg_doze: bool,
            m33_lpi2c4_ipg_doze: bool,
            m33_lpi2c5_ipg_doze: bool,
            m33_lpi2c6_ipg_doze: bool,
            m33_lpspi1_ipg_doze: bool,
            m33_lpspi2_ipg_doze: bool,
            m33_lpspi3_ipg_doze: bool,
            m33_lpspi4_ipg_doze: bool,
            m33_lpspi5_ipg_doze: bool,
            m33_lpspi6_ipg_doze: bool,
            m33_sinc1_ipg_doze: bool,
            m33_sinc2_ipg_doze: bool,
            m33_sinc3_ipg_doze: bool,
            m33_mic_ipg_doze: bool,
        }
        let proxy = GprShared11 {
            m33_lpi2c1_ipg_doze: self.m33_lpi2c1_ipg_doze(),
            m33_lpi2c2_ipg_doze: self.m33_lpi2c2_ipg_doze(),
            m33_lpi2c3_ipg_doze: self.m33_lpi2c3_ipg_doze(),
            m33_lpi2c4_ipg_doze: self.m33_lpi2c4_ipg_doze(),
            m33_lpi2c5_ipg_doze: self.m33_lpi2c5_ipg_doze(),
            m33_lpi2c6_ipg_doze: self.m33_lpi2c6_ipg_doze(),
            m33_lpspi1_ipg_doze: self.m33_lpspi1_ipg_doze(),
            m33_lpspi2_ipg_doze: self.m33_lpspi2_ipg_doze(),
            m33_lpspi3_ipg_doze: self.m33_lpspi3_ipg_doze(),
            m33_lpspi4_ipg_doze: self.m33_lpspi4_ipg_doze(),
            m33_lpspi5_ipg_doze: self.m33_lpspi5_ipg_doze(),
            m33_lpspi6_ipg_doze: self.m33_lpspi6_ipg_doze(),
            m33_sinc1_ipg_doze: self.m33_sinc1_ipg_doze(),
            m33_sinc2_ipg_doze: self.m33_sinc2_ipg_doze(),
            m33_sinc3_ipg_doze: self.m33_sinc3_ipg_doze(),
            m33_mic_ipg_doze: self.m33_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11Authen(pub u32);
impl GprShared11Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared11AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared11AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared11AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared11AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared11AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared11AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared11Authen {
    #[inline(always)]
    fn default() -> GprShared11Authen {
        GprShared11Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11Authen {
            tz_user: super::vals::GprShared11AuthenTzUser,
            tz_ns: super::vals::GprShared11AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared11Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11AuthenClr(pub u32);
impl GprShared11AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared11AuthenClr {
    #[inline(always)]
    fn default() -> GprShared11AuthenClr {
        GprShared11AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared11AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11AuthenSet(pub u32);
impl GprShared11AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared11AuthenSet {
    #[inline(always)]
    fn default() -> GprShared11AuthenSet {
        GprShared11AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared11AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11AuthenTog(pub u32);
impl GprShared11AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared11AuthenTog {
    #[inline(always)]
    fn default() -> GprShared11AuthenTog {
        GprShared11AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared11AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11Clr(pub u32);
impl GprShared11Clr {
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared11Clr {
    #[inline(always)]
    fn default() -> GprShared11Clr {
        GprShared11Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11Clr")
            .field("m33_lpi2c1_ipg_doze", &self.m33_lpi2c1_ipg_doze())
            .field("m33_lpi2c2_ipg_doze", &self.m33_lpi2c2_ipg_doze())
            .field("m33_lpi2c3_ipg_doze", &self.m33_lpi2c3_ipg_doze())
            .field("m33_lpi2c4_ipg_doze", &self.m33_lpi2c4_ipg_doze())
            .field("m33_lpi2c5_ipg_doze", &self.m33_lpi2c5_ipg_doze())
            .field("m33_lpi2c6_ipg_doze", &self.m33_lpi2c6_ipg_doze())
            .field("m33_lpspi1_ipg_doze", &self.m33_lpspi1_ipg_doze())
            .field("m33_lpspi2_ipg_doze", &self.m33_lpspi2_ipg_doze())
            .field("m33_lpspi3_ipg_doze", &self.m33_lpspi3_ipg_doze())
            .field("m33_lpspi4_ipg_doze", &self.m33_lpspi4_ipg_doze())
            .field("m33_lpspi5_ipg_doze", &self.m33_lpspi5_ipg_doze())
            .field("m33_lpspi6_ipg_doze", &self.m33_lpspi6_ipg_doze())
            .field("m33_sinc1_ipg_doze", &self.m33_sinc1_ipg_doze())
            .field("m33_sinc2_ipg_doze", &self.m33_sinc2_ipg_doze())
            .field("m33_sinc3_ipg_doze", &self.m33_sinc3_ipg_doze())
            .field("m33_mic_ipg_doze", &self.m33_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11Clr {
            m33_lpi2c1_ipg_doze: bool,
            m33_lpi2c2_ipg_doze: bool,
            m33_lpi2c3_ipg_doze: bool,
            m33_lpi2c4_ipg_doze: bool,
            m33_lpi2c5_ipg_doze: bool,
            m33_lpi2c6_ipg_doze: bool,
            m33_lpspi1_ipg_doze: bool,
            m33_lpspi2_ipg_doze: bool,
            m33_lpspi3_ipg_doze: bool,
            m33_lpspi4_ipg_doze: bool,
            m33_lpspi5_ipg_doze: bool,
            m33_lpspi6_ipg_doze: bool,
            m33_sinc1_ipg_doze: bool,
            m33_sinc2_ipg_doze: bool,
            m33_sinc3_ipg_doze: bool,
            m33_mic_ipg_doze: bool,
        }
        let proxy = GprShared11Clr {
            m33_lpi2c1_ipg_doze: self.m33_lpi2c1_ipg_doze(),
            m33_lpi2c2_ipg_doze: self.m33_lpi2c2_ipg_doze(),
            m33_lpi2c3_ipg_doze: self.m33_lpi2c3_ipg_doze(),
            m33_lpi2c4_ipg_doze: self.m33_lpi2c4_ipg_doze(),
            m33_lpi2c5_ipg_doze: self.m33_lpi2c5_ipg_doze(),
            m33_lpi2c6_ipg_doze: self.m33_lpi2c6_ipg_doze(),
            m33_lpspi1_ipg_doze: self.m33_lpspi1_ipg_doze(),
            m33_lpspi2_ipg_doze: self.m33_lpspi2_ipg_doze(),
            m33_lpspi3_ipg_doze: self.m33_lpspi3_ipg_doze(),
            m33_lpspi4_ipg_doze: self.m33_lpspi4_ipg_doze(),
            m33_lpspi5_ipg_doze: self.m33_lpspi5_ipg_doze(),
            m33_lpspi6_ipg_doze: self.m33_lpspi6_ipg_doze(),
            m33_sinc1_ipg_doze: self.m33_sinc1_ipg_doze(),
            m33_sinc2_ipg_doze: self.m33_sinc2_ipg_doze(),
            m33_sinc3_ipg_doze: self.m33_sinc3_ipg_doze(),
            m33_mic_ipg_doze: self.m33_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11Set(pub u32);
impl GprShared11Set {
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared11Set {
    #[inline(always)]
    fn default() -> GprShared11Set {
        GprShared11Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11Set")
            .field("m33_lpi2c1_ipg_doze", &self.m33_lpi2c1_ipg_doze())
            .field("m33_lpi2c2_ipg_doze", &self.m33_lpi2c2_ipg_doze())
            .field("m33_lpi2c3_ipg_doze", &self.m33_lpi2c3_ipg_doze())
            .field("m33_lpi2c4_ipg_doze", &self.m33_lpi2c4_ipg_doze())
            .field("m33_lpi2c5_ipg_doze", &self.m33_lpi2c5_ipg_doze())
            .field("m33_lpi2c6_ipg_doze", &self.m33_lpi2c6_ipg_doze())
            .field("m33_lpspi1_ipg_doze", &self.m33_lpspi1_ipg_doze())
            .field("m33_lpspi2_ipg_doze", &self.m33_lpspi2_ipg_doze())
            .field("m33_lpspi3_ipg_doze", &self.m33_lpspi3_ipg_doze())
            .field("m33_lpspi4_ipg_doze", &self.m33_lpspi4_ipg_doze())
            .field("m33_lpspi5_ipg_doze", &self.m33_lpspi5_ipg_doze())
            .field("m33_lpspi6_ipg_doze", &self.m33_lpspi6_ipg_doze())
            .field("m33_sinc1_ipg_doze", &self.m33_sinc1_ipg_doze())
            .field("m33_sinc2_ipg_doze", &self.m33_sinc2_ipg_doze())
            .field("m33_sinc3_ipg_doze", &self.m33_sinc3_ipg_doze())
            .field("m33_mic_ipg_doze", &self.m33_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11Set {
            m33_lpi2c1_ipg_doze: bool,
            m33_lpi2c2_ipg_doze: bool,
            m33_lpi2c3_ipg_doze: bool,
            m33_lpi2c4_ipg_doze: bool,
            m33_lpi2c5_ipg_doze: bool,
            m33_lpi2c6_ipg_doze: bool,
            m33_lpspi1_ipg_doze: bool,
            m33_lpspi2_ipg_doze: bool,
            m33_lpspi3_ipg_doze: bool,
            m33_lpspi4_ipg_doze: bool,
            m33_lpspi5_ipg_doze: bool,
            m33_lpspi6_ipg_doze: bool,
            m33_sinc1_ipg_doze: bool,
            m33_sinc2_ipg_doze: bool,
            m33_sinc3_ipg_doze: bool,
            m33_mic_ipg_doze: bool,
        }
        let proxy = GprShared11Set {
            m33_lpi2c1_ipg_doze: self.m33_lpi2c1_ipg_doze(),
            m33_lpi2c2_ipg_doze: self.m33_lpi2c2_ipg_doze(),
            m33_lpi2c3_ipg_doze: self.m33_lpi2c3_ipg_doze(),
            m33_lpi2c4_ipg_doze: self.m33_lpi2c4_ipg_doze(),
            m33_lpi2c5_ipg_doze: self.m33_lpi2c5_ipg_doze(),
            m33_lpi2c6_ipg_doze: self.m33_lpi2c6_ipg_doze(),
            m33_lpspi1_ipg_doze: self.m33_lpspi1_ipg_doze(),
            m33_lpspi2_ipg_doze: self.m33_lpspi2_ipg_doze(),
            m33_lpspi3_ipg_doze: self.m33_lpspi3_ipg_doze(),
            m33_lpspi4_ipg_doze: self.m33_lpspi4_ipg_doze(),
            m33_lpspi5_ipg_doze: self.m33_lpspi5_ipg_doze(),
            m33_lpspi6_ipg_doze: self.m33_lpspi6_ipg_doze(),
            m33_sinc1_ipg_doze: self.m33_sinc1_ipg_doze(),
            m33_sinc2_ipg_doze: self.m33_sinc2_ipg_doze(),
            m33_sinc3_ipg_doze: self.m33_sinc3_ipg_doze(),
            m33_mic_ipg_doze: self.m33_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared11Tog(pub u32);
impl GprShared11Tog {
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared11Tog {
    #[inline(always)]
    fn default() -> GprShared11Tog {
        GprShared11Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared11Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared11Tog")
            .field("m33_lpi2c1_ipg_doze", &self.m33_lpi2c1_ipg_doze())
            .field("m33_lpi2c2_ipg_doze", &self.m33_lpi2c2_ipg_doze())
            .field("m33_lpi2c3_ipg_doze", &self.m33_lpi2c3_ipg_doze())
            .field("m33_lpi2c4_ipg_doze", &self.m33_lpi2c4_ipg_doze())
            .field("m33_lpi2c5_ipg_doze", &self.m33_lpi2c5_ipg_doze())
            .field("m33_lpi2c6_ipg_doze", &self.m33_lpi2c6_ipg_doze())
            .field("m33_lpspi1_ipg_doze", &self.m33_lpspi1_ipg_doze())
            .field("m33_lpspi2_ipg_doze", &self.m33_lpspi2_ipg_doze())
            .field("m33_lpspi3_ipg_doze", &self.m33_lpspi3_ipg_doze())
            .field("m33_lpspi4_ipg_doze", &self.m33_lpspi4_ipg_doze())
            .field("m33_lpspi5_ipg_doze", &self.m33_lpspi5_ipg_doze())
            .field("m33_lpspi6_ipg_doze", &self.m33_lpspi6_ipg_doze())
            .field("m33_sinc1_ipg_doze", &self.m33_sinc1_ipg_doze())
            .field("m33_sinc2_ipg_doze", &self.m33_sinc2_ipg_doze())
            .field("m33_sinc3_ipg_doze", &self.m33_sinc3_ipg_doze())
            .field("m33_mic_ipg_doze", &self.m33_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared11Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared11Tog {
            m33_lpi2c1_ipg_doze: bool,
            m33_lpi2c2_ipg_doze: bool,
            m33_lpi2c3_ipg_doze: bool,
            m33_lpi2c4_ipg_doze: bool,
            m33_lpi2c5_ipg_doze: bool,
            m33_lpi2c6_ipg_doze: bool,
            m33_lpspi1_ipg_doze: bool,
            m33_lpspi2_ipg_doze: bool,
            m33_lpspi3_ipg_doze: bool,
            m33_lpspi4_ipg_doze: bool,
            m33_lpspi5_ipg_doze: bool,
            m33_lpspi6_ipg_doze: bool,
            m33_sinc1_ipg_doze: bool,
            m33_sinc2_ipg_doze: bool,
            m33_sinc3_ipg_doze: bool,
            m33_mic_ipg_doze: bool,
        }
        let proxy = GprShared11Tog {
            m33_lpi2c1_ipg_doze: self.m33_lpi2c1_ipg_doze(),
            m33_lpi2c2_ipg_doze: self.m33_lpi2c2_ipg_doze(),
            m33_lpi2c3_ipg_doze: self.m33_lpi2c3_ipg_doze(),
            m33_lpi2c4_ipg_doze: self.m33_lpi2c4_ipg_doze(),
            m33_lpi2c5_ipg_doze: self.m33_lpi2c5_ipg_doze(),
            m33_lpi2c6_ipg_doze: self.m33_lpi2c6_ipg_doze(),
            m33_lpspi1_ipg_doze: self.m33_lpspi1_ipg_doze(),
            m33_lpspi2_ipg_doze: self.m33_lpspi2_ipg_doze(),
            m33_lpspi3_ipg_doze: self.m33_lpspi3_ipg_doze(),
            m33_lpspi4_ipg_doze: self.m33_lpspi4_ipg_doze(),
            m33_lpspi5_ipg_doze: self.m33_lpspi5_ipg_doze(),
            m33_lpspi6_ipg_doze: self.m33_lpspi6_ipg_doze(),
            m33_sinc1_ipg_doze: self.m33_sinc1_ipg_doze(),
            m33_sinc2_ipg_doze: self.m33_sinc2_ipg_doze(),
            m33_sinc3_ipg_doze: self.m33_sinc3_ipg_doze(),
            m33_mic_ipg_doze: self.m33_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12(pub u32);
impl GprShared12 {
    #[doc = "m7_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared12 {
    #[inline(always)]
    fn default() -> GprShared12 {
        GprShared12(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12")
            .field("m7_cm7_ipg_stop", &self.m7_cm7_ipg_stop())
            .field("m7_cm33_ipg_stop", &self.m7_cm33_ipg_stop())
            .field("m7_edma3_ipg_stop", &self.m7_edma3_ipg_stop())
            .field("m7_edma4_ipg_stop", &self.m7_edma4_ipg_stop())
            .field("m7_netc_ipg_stop", &self.m7_netc_ipg_stop())
            .field("m7_sim_aon_ipg_stop", &self.m7_sim_aon_ipg_stop())
            .field("m7_adc1_ipg_stop", &self.m7_adc1_ipg_stop())
            .field("m7_adc2_ipg_stop", &self.m7_adc2_ipg_stop())
            .field("m7_flexspi1_ipg_stop", &self.m7_flexspi1_ipg_stop())
            .field("m7_flexspi2_ipg_stop", &self.m7_flexspi2_ipg_stop())
            .field("m7_trdc_ipg_stop", &self.m7_trdc_ipg_stop())
            .field("m7_semc_ipg_stop", &self.m7_semc_ipg_stop())
            .field("m7_iee_ipg_stop", &self.m7_iee_ipg_stop())
            .field("m7_gpio1_ipg_stop", &self.m7_gpio1_ipg_stop())
            .field("m7_gpio2_ipg_stop", &self.m7_gpio2_ipg_stop())
            .field("m7_gpio3_ipg_stop", &self.m7_gpio3_ipg_stop())
            .field("m7_gpio4_ipg_stop", &self.m7_gpio4_ipg_stop())
            .field("m7_gpio5_ipg_stop", &self.m7_gpio5_ipg_stop())
            .field("m7_gpio6_ipg_stop", &self.m7_gpio6_ipg_stop())
            .field("m7_flexio1_ipg_stop", &self.m7_flexio1_ipg_stop())
            .field("m7_flexio2_ipg_stop", &self.m7_flexio2_ipg_stop())
            .field("m7_can1_ipg_stop", &self.m7_can1_ipg_stop())
            .field("m7_can2_ipg_stop", &self.m7_can2_ipg_stop())
            .field("m7_can3_ipg_stop", &self.m7_can3_ipg_stop())
            .field("m7_lpuart1_ipg_stop", &self.m7_lpuart1_ipg_stop())
            .field("m7_lpuart2_ipg_stop", &self.m7_lpuart2_ipg_stop())
            .field("m7_lpuart3_ipg_stop", &self.m7_lpuart3_ipg_stop())
            .field("m7_lpuart4_ipg_stop", &self.m7_lpuart4_ipg_stop())
            .field("m7_lpuart5_ipg_stop", &self.m7_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12 {
            m7_cm7_ipg_stop: bool,
            m7_cm33_ipg_stop: bool,
            m7_edma3_ipg_stop: bool,
            m7_edma4_ipg_stop: bool,
            m7_netc_ipg_stop: bool,
            m7_sim_aon_ipg_stop: bool,
            m7_adc1_ipg_stop: bool,
            m7_adc2_ipg_stop: bool,
            m7_flexspi1_ipg_stop: bool,
            m7_flexspi2_ipg_stop: bool,
            m7_trdc_ipg_stop: bool,
            m7_semc_ipg_stop: bool,
            m7_iee_ipg_stop: bool,
            m7_gpio1_ipg_stop: bool,
            m7_gpio2_ipg_stop: bool,
            m7_gpio3_ipg_stop: bool,
            m7_gpio4_ipg_stop: bool,
            m7_gpio5_ipg_stop: bool,
            m7_gpio6_ipg_stop: bool,
            m7_flexio1_ipg_stop: bool,
            m7_flexio2_ipg_stop: bool,
            m7_can1_ipg_stop: bool,
            m7_can2_ipg_stop: bool,
            m7_can3_ipg_stop: bool,
            m7_lpuart1_ipg_stop: bool,
            m7_lpuart2_ipg_stop: bool,
            m7_lpuart3_ipg_stop: bool,
            m7_lpuart4_ipg_stop: bool,
            m7_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared12 {
            m7_cm7_ipg_stop: self.m7_cm7_ipg_stop(),
            m7_cm33_ipg_stop: self.m7_cm33_ipg_stop(),
            m7_edma3_ipg_stop: self.m7_edma3_ipg_stop(),
            m7_edma4_ipg_stop: self.m7_edma4_ipg_stop(),
            m7_netc_ipg_stop: self.m7_netc_ipg_stop(),
            m7_sim_aon_ipg_stop: self.m7_sim_aon_ipg_stop(),
            m7_adc1_ipg_stop: self.m7_adc1_ipg_stop(),
            m7_adc2_ipg_stop: self.m7_adc2_ipg_stop(),
            m7_flexspi1_ipg_stop: self.m7_flexspi1_ipg_stop(),
            m7_flexspi2_ipg_stop: self.m7_flexspi2_ipg_stop(),
            m7_trdc_ipg_stop: self.m7_trdc_ipg_stop(),
            m7_semc_ipg_stop: self.m7_semc_ipg_stop(),
            m7_iee_ipg_stop: self.m7_iee_ipg_stop(),
            m7_gpio1_ipg_stop: self.m7_gpio1_ipg_stop(),
            m7_gpio2_ipg_stop: self.m7_gpio2_ipg_stop(),
            m7_gpio3_ipg_stop: self.m7_gpio3_ipg_stop(),
            m7_gpio4_ipg_stop: self.m7_gpio4_ipg_stop(),
            m7_gpio5_ipg_stop: self.m7_gpio5_ipg_stop(),
            m7_gpio6_ipg_stop: self.m7_gpio6_ipg_stop(),
            m7_flexio1_ipg_stop: self.m7_flexio1_ipg_stop(),
            m7_flexio2_ipg_stop: self.m7_flexio2_ipg_stop(),
            m7_can1_ipg_stop: self.m7_can1_ipg_stop(),
            m7_can2_ipg_stop: self.m7_can2_ipg_stop(),
            m7_can3_ipg_stop: self.m7_can3_ipg_stop(),
            m7_lpuart1_ipg_stop: self.m7_lpuart1_ipg_stop(),
            m7_lpuart2_ipg_stop: self.m7_lpuart2_ipg_stop(),
            m7_lpuart3_ipg_stop: self.m7_lpuart3_ipg_stop(),
            m7_lpuart4_ipg_stop: self.m7_lpuart4_ipg_stop(),
            m7_lpuart5_ipg_stop: self.m7_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12Authen(pub u32);
impl GprShared12Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared12AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared12AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared12AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared12AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared12AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared12AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared12Authen {
    #[inline(always)]
    fn default() -> GprShared12Authen {
        GprShared12Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12Authen {
            tz_user: super::vals::GprShared12AuthenTzUser,
            tz_ns: super::vals::GprShared12AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared12Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12AuthenClr(pub u32);
impl GprShared12AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared12AuthenClr {
    #[inline(always)]
    fn default() -> GprShared12AuthenClr {
        GprShared12AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared12AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12AuthenSet(pub u32);
impl GprShared12AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared12AuthenSet {
    #[inline(always)]
    fn default() -> GprShared12AuthenSet {
        GprShared12AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared12AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12AuthenTog(pub u32);
impl GprShared12AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared12AuthenTog {
    #[inline(always)]
    fn default() -> GprShared12AuthenTog {
        GprShared12AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared12AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12Clr(pub u32);
impl GprShared12Clr {
    #[doc = "m7_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared12Clr {
    #[inline(always)]
    fn default() -> GprShared12Clr {
        GprShared12Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12Clr")
            .field("m7_cm7_ipg_stop", &self.m7_cm7_ipg_stop())
            .field("m7_cm33_ipg_stop", &self.m7_cm33_ipg_stop())
            .field("m7_edma3_ipg_stop", &self.m7_edma3_ipg_stop())
            .field("m7_edma4_ipg_stop", &self.m7_edma4_ipg_stop())
            .field("m7_netc_ipg_stop", &self.m7_netc_ipg_stop())
            .field("m7_sim_aon_ipg_stop", &self.m7_sim_aon_ipg_stop())
            .field("m7_adc1_ipg_stop", &self.m7_adc1_ipg_stop())
            .field("m7_adc2_ipg_stop", &self.m7_adc2_ipg_stop())
            .field("m7_flexspi1_ipg_stop", &self.m7_flexspi1_ipg_stop())
            .field("m7_flexspi2_ipg_stop", &self.m7_flexspi2_ipg_stop())
            .field("m7_trdc_ipg_stop", &self.m7_trdc_ipg_stop())
            .field("m7_semc_ipg_stop", &self.m7_semc_ipg_stop())
            .field("m7_iee_ipg_stop", &self.m7_iee_ipg_stop())
            .field("m7_gpio1_ipg_stop", &self.m7_gpio1_ipg_stop())
            .field("m7_gpio2_ipg_stop", &self.m7_gpio2_ipg_stop())
            .field("m7_gpio3_ipg_stop", &self.m7_gpio3_ipg_stop())
            .field("m7_gpio4_ipg_stop", &self.m7_gpio4_ipg_stop())
            .field("m7_gpio5_ipg_stop", &self.m7_gpio5_ipg_stop())
            .field("m7_gpio6_ipg_stop", &self.m7_gpio6_ipg_stop())
            .field("m7_flexio1_ipg_stop", &self.m7_flexio1_ipg_stop())
            .field("m7_flexio2_ipg_stop", &self.m7_flexio2_ipg_stop())
            .field("m7_can1_ipg_stop", &self.m7_can1_ipg_stop())
            .field("m7_can2_ipg_stop", &self.m7_can2_ipg_stop())
            .field("m7_can3_ipg_stop", &self.m7_can3_ipg_stop())
            .field("m7_lpuart1_ipg_stop", &self.m7_lpuart1_ipg_stop())
            .field("m7_lpuart2_ipg_stop", &self.m7_lpuart2_ipg_stop())
            .field("m7_lpuart3_ipg_stop", &self.m7_lpuart3_ipg_stop())
            .field("m7_lpuart4_ipg_stop", &self.m7_lpuart4_ipg_stop())
            .field("m7_lpuart5_ipg_stop", &self.m7_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12Clr {
            m7_cm7_ipg_stop: bool,
            m7_cm33_ipg_stop: bool,
            m7_edma3_ipg_stop: bool,
            m7_edma4_ipg_stop: bool,
            m7_netc_ipg_stop: bool,
            m7_sim_aon_ipg_stop: bool,
            m7_adc1_ipg_stop: bool,
            m7_adc2_ipg_stop: bool,
            m7_flexspi1_ipg_stop: bool,
            m7_flexspi2_ipg_stop: bool,
            m7_trdc_ipg_stop: bool,
            m7_semc_ipg_stop: bool,
            m7_iee_ipg_stop: bool,
            m7_gpio1_ipg_stop: bool,
            m7_gpio2_ipg_stop: bool,
            m7_gpio3_ipg_stop: bool,
            m7_gpio4_ipg_stop: bool,
            m7_gpio5_ipg_stop: bool,
            m7_gpio6_ipg_stop: bool,
            m7_flexio1_ipg_stop: bool,
            m7_flexio2_ipg_stop: bool,
            m7_can1_ipg_stop: bool,
            m7_can2_ipg_stop: bool,
            m7_can3_ipg_stop: bool,
            m7_lpuart1_ipg_stop: bool,
            m7_lpuart2_ipg_stop: bool,
            m7_lpuart3_ipg_stop: bool,
            m7_lpuart4_ipg_stop: bool,
            m7_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared12Clr {
            m7_cm7_ipg_stop: self.m7_cm7_ipg_stop(),
            m7_cm33_ipg_stop: self.m7_cm33_ipg_stop(),
            m7_edma3_ipg_stop: self.m7_edma3_ipg_stop(),
            m7_edma4_ipg_stop: self.m7_edma4_ipg_stop(),
            m7_netc_ipg_stop: self.m7_netc_ipg_stop(),
            m7_sim_aon_ipg_stop: self.m7_sim_aon_ipg_stop(),
            m7_adc1_ipg_stop: self.m7_adc1_ipg_stop(),
            m7_adc2_ipg_stop: self.m7_adc2_ipg_stop(),
            m7_flexspi1_ipg_stop: self.m7_flexspi1_ipg_stop(),
            m7_flexspi2_ipg_stop: self.m7_flexspi2_ipg_stop(),
            m7_trdc_ipg_stop: self.m7_trdc_ipg_stop(),
            m7_semc_ipg_stop: self.m7_semc_ipg_stop(),
            m7_iee_ipg_stop: self.m7_iee_ipg_stop(),
            m7_gpio1_ipg_stop: self.m7_gpio1_ipg_stop(),
            m7_gpio2_ipg_stop: self.m7_gpio2_ipg_stop(),
            m7_gpio3_ipg_stop: self.m7_gpio3_ipg_stop(),
            m7_gpio4_ipg_stop: self.m7_gpio4_ipg_stop(),
            m7_gpio5_ipg_stop: self.m7_gpio5_ipg_stop(),
            m7_gpio6_ipg_stop: self.m7_gpio6_ipg_stop(),
            m7_flexio1_ipg_stop: self.m7_flexio1_ipg_stop(),
            m7_flexio2_ipg_stop: self.m7_flexio2_ipg_stop(),
            m7_can1_ipg_stop: self.m7_can1_ipg_stop(),
            m7_can2_ipg_stop: self.m7_can2_ipg_stop(),
            m7_can3_ipg_stop: self.m7_can3_ipg_stop(),
            m7_lpuart1_ipg_stop: self.m7_lpuart1_ipg_stop(),
            m7_lpuart2_ipg_stop: self.m7_lpuart2_ipg_stop(),
            m7_lpuart3_ipg_stop: self.m7_lpuart3_ipg_stop(),
            m7_lpuart4_ipg_stop: self.m7_lpuart4_ipg_stop(),
            m7_lpuart5_ipg_stop: self.m7_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12Set(pub u32);
impl GprShared12Set {
    #[doc = "m7_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared12Set {
    #[inline(always)]
    fn default() -> GprShared12Set {
        GprShared12Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12Set")
            .field("m7_cm7_ipg_stop", &self.m7_cm7_ipg_stop())
            .field("m7_cm33_ipg_stop", &self.m7_cm33_ipg_stop())
            .field("m7_edma3_ipg_stop", &self.m7_edma3_ipg_stop())
            .field("m7_edma4_ipg_stop", &self.m7_edma4_ipg_stop())
            .field("m7_netc_ipg_stop", &self.m7_netc_ipg_stop())
            .field("m7_sim_aon_ipg_stop", &self.m7_sim_aon_ipg_stop())
            .field("m7_adc1_ipg_stop", &self.m7_adc1_ipg_stop())
            .field("m7_adc2_ipg_stop", &self.m7_adc2_ipg_stop())
            .field("m7_flexspi1_ipg_stop", &self.m7_flexspi1_ipg_stop())
            .field("m7_flexspi2_ipg_stop", &self.m7_flexspi2_ipg_stop())
            .field("m7_trdc_ipg_stop", &self.m7_trdc_ipg_stop())
            .field("m7_semc_ipg_stop", &self.m7_semc_ipg_stop())
            .field("m7_iee_ipg_stop", &self.m7_iee_ipg_stop())
            .field("m7_gpio1_ipg_stop", &self.m7_gpio1_ipg_stop())
            .field("m7_gpio2_ipg_stop", &self.m7_gpio2_ipg_stop())
            .field("m7_gpio3_ipg_stop", &self.m7_gpio3_ipg_stop())
            .field("m7_gpio4_ipg_stop", &self.m7_gpio4_ipg_stop())
            .field("m7_gpio5_ipg_stop", &self.m7_gpio5_ipg_stop())
            .field("m7_gpio6_ipg_stop", &self.m7_gpio6_ipg_stop())
            .field("m7_flexio1_ipg_stop", &self.m7_flexio1_ipg_stop())
            .field("m7_flexio2_ipg_stop", &self.m7_flexio2_ipg_stop())
            .field("m7_can1_ipg_stop", &self.m7_can1_ipg_stop())
            .field("m7_can2_ipg_stop", &self.m7_can2_ipg_stop())
            .field("m7_can3_ipg_stop", &self.m7_can3_ipg_stop())
            .field("m7_lpuart1_ipg_stop", &self.m7_lpuart1_ipg_stop())
            .field("m7_lpuart2_ipg_stop", &self.m7_lpuart2_ipg_stop())
            .field("m7_lpuart3_ipg_stop", &self.m7_lpuart3_ipg_stop())
            .field("m7_lpuart4_ipg_stop", &self.m7_lpuart4_ipg_stop())
            .field("m7_lpuart5_ipg_stop", &self.m7_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12Set {
            m7_cm7_ipg_stop: bool,
            m7_cm33_ipg_stop: bool,
            m7_edma3_ipg_stop: bool,
            m7_edma4_ipg_stop: bool,
            m7_netc_ipg_stop: bool,
            m7_sim_aon_ipg_stop: bool,
            m7_adc1_ipg_stop: bool,
            m7_adc2_ipg_stop: bool,
            m7_flexspi1_ipg_stop: bool,
            m7_flexspi2_ipg_stop: bool,
            m7_trdc_ipg_stop: bool,
            m7_semc_ipg_stop: bool,
            m7_iee_ipg_stop: bool,
            m7_gpio1_ipg_stop: bool,
            m7_gpio2_ipg_stop: bool,
            m7_gpio3_ipg_stop: bool,
            m7_gpio4_ipg_stop: bool,
            m7_gpio5_ipg_stop: bool,
            m7_gpio6_ipg_stop: bool,
            m7_flexio1_ipg_stop: bool,
            m7_flexio2_ipg_stop: bool,
            m7_can1_ipg_stop: bool,
            m7_can2_ipg_stop: bool,
            m7_can3_ipg_stop: bool,
            m7_lpuart1_ipg_stop: bool,
            m7_lpuart2_ipg_stop: bool,
            m7_lpuart3_ipg_stop: bool,
            m7_lpuart4_ipg_stop: bool,
            m7_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared12Set {
            m7_cm7_ipg_stop: self.m7_cm7_ipg_stop(),
            m7_cm33_ipg_stop: self.m7_cm33_ipg_stop(),
            m7_edma3_ipg_stop: self.m7_edma3_ipg_stop(),
            m7_edma4_ipg_stop: self.m7_edma4_ipg_stop(),
            m7_netc_ipg_stop: self.m7_netc_ipg_stop(),
            m7_sim_aon_ipg_stop: self.m7_sim_aon_ipg_stop(),
            m7_adc1_ipg_stop: self.m7_adc1_ipg_stop(),
            m7_adc2_ipg_stop: self.m7_adc2_ipg_stop(),
            m7_flexspi1_ipg_stop: self.m7_flexspi1_ipg_stop(),
            m7_flexspi2_ipg_stop: self.m7_flexspi2_ipg_stop(),
            m7_trdc_ipg_stop: self.m7_trdc_ipg_stop(),
            m7_semc_ipg_stop: self.m7_semc_ipg_stop(),
            m7_iee_ipg_stop: self.m7_iee_ipg_stop(),
            m7_gpio1_ipg_stop: self.m7_gpio1_ipg_stop(),
            m7_gpio2_ipg_stop: self.m7_gpio2_ipg_stop(),
            m7_gpio3_ipg_stop: self.m7_gpio3_ipg_stop(),
            m7_gpio4_ipg_stop: self.m7_gpio4_ipg_stop(),
            m7_gpio5_ipg_stop: self.m7_gpio5_ipg_stop(),
            m7_gpio6_ipg_stop: self.m7_gpio6_ipg_stop(),
            m7_flexio1_ipg_stop: self.m7_flexio1_ipg_stop(),
            m7_flexio2_ipg_stop: self.m7_flexio2_ipg_stop(),
            m7_can1_ipg_stop: self.m7_can1_ipg_stop(),
            m7_can2_ipg_stop: self.m7_can2_ipg_stop(),
            m7_can3_ipg_stop: self.m7_can3_ipg_stop(),
            m7_lpuart1_ipg_stop: self.m7_lpuart1_ipg_stop(),
            m7_lpuart2_ipg_stop: self.m7_lpuart2_ipg_stop(),
            m7_lpuart3_ipg_stop: self.m7_lpuart3_ipg_stop(),
            m7_lpuart4_ipg_stop: self.m7_lpuart4_ipg_stop(),
            m7_lpuart5_ipg_stop: self.m7_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared12Tog(pub u32);
impl GprShared12Tog {
    #[doc = "m7_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared12Tog {
    #[inline(always)]
    fn default() -> GprShared12Tog {
        GprShared12Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared12Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared12Tog")
            .field("m7_cm7_ipg_stop", &self.m7_cm7_ipg_stop())
            .field("m7_cm33_ipg_stop", &self.m7_cm33_ipg_stop())
            .field("m7_edma3_ipg_stop", &self.m7_edma3_ipg_stop())
            .field("m7_edma4_ipg_stop", &self.m7_edma4_ipg_stop())
            .field("m7_netc_ipg_stop", &self.m7_netc_ipg_stop())
            .field("m7_sim_aon_ipg_stop", &self.m7_sim_aon_ipg_stop())
            .field("m7_adc1_ipg_stop", &self.m7_adc1_ipg_stop())
            .field("m7_adc2_ipg_stop", &self.m7_adc2_ipg_stop())
            .field("m7_flexspi1_ipg_stop", &self.m7_flexspi1_ipg_stop())
            .field("m7_flexspi2_ipg_stop", &self.m7_flexspi2_ipg_stop())
            .field("m7_trdc_ipg_stop", &self.m7_trdc_ipg_stop())
            .field("m7_semc_ipg_stop", &self.m7_semc_ipg_stop())
            .field("m7_iee_ipg_stop", &self.m7_iee_ipg_stop())
            .field("m7_gpio1_ipg_stop", &self.m7_gpio1_ipg_stop())
            .field("m7_gpio2_ipg_stop", &self.m7_gpio2_ipg_stop())
            .field("m7_gpio3_ipg_stop", &self.m7_gpio3_ipg_stop())
            .field("m7_gpio4_ipg_stop", &self.m7_gpio4_ipg_stop())
            .field("m7_gpio5_ipg_stop", &self.m7_gpio5_ipg_stop())
            .field("m7_gpio6_ipg_stop", &self.m7_gpio6_ipg_stop())
            .field("m7_flexio1_ipg_stop", &self.m7_flexio1_ipg_stop())
            .field("m7_flexio2_ipg_stop", &self.m7_flexio2_ipg_stop())
            .field("m7_can1_ipg_stop", &self.m7_can1_ipg_stop())
            .field("m7_can2_ipg_stop", &self.m7_can2_ipg_stop())
            .field("m7_can3_ipg_stop", &self.m7_can3_ipg_stop())
            .field("m7_lpuart1_ipg_stop", &self.m7_lpuart1_ipg_stop())
            .field("m7_lpuart2_ipg_stop", &self.m7_lpuart2_ipg_stop())
            .field("m7_lpuart3_ipg_stop", &self.m7_lpuart3_ipg_stop())
            .field("m7_lpuart4_ipg_stop", &self.m7_lpuart4_ipg_stop())
            .field("m7_lpuart5_ipg_stop", &self.m7_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared12Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared12Tog {
            m7_cm7_ipg_stop: bool,
            m7_cm33_ipg_stop: bool,
            m7_edma3_ipg_stop: bool,
            m7_edma4_ipg_stop: bool,
            m7_netc_ipg_stop: bool,
            m7_sim_aon_ipg_stop: bool,
            m7_adc1_ipg_stop: bool,
            m7_adc2_ipg_stop: bool,
            m7_flexspi1_ipg_stop: bool,
            m7_flexspi2_ipg_stop: bool,
            m7_trdc_ipg_stop: bool,
            m7_semc_ipg_stop: bool,
            m7_iee_ipg_stop: bool,
            m7_gpio1_ipg_stop: bool,
            m7_gpio2_ipg_stop: bool,
            m7_gpio3_ipg_stop: bool,
            m7_gpio4_ipg_stop: bool,
            m7_gpio5_ipg_stop: bool,
            m7_gpio6_ipg_stop: bool,
            m7_flexio1_ipg_stop: bool,
            m7_flexio2_ipg_stop: bool,
            m7_can1_ipg_stop: bool,
            m7_can2_ipg_stop: bool,
            m7_can3_ipg_stop: bool,
            m7_lpuart1_ipg_stop: bool,
            m7_lpuart2_ipg_stop: bool,
            m7_lpuart3_ipg_stop: bool,
            m7_lpuart4_ipg_stop: bool,
            m7_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared12Tog {
            m7_cm7_ipg_stop: self.m7_cm7_ipg_stop(),
            m7_cm33_ipg_stop: self.m7_cm33_ipg_stop(),
            m7_edma3_ipg_stop: self.m7_edma3_ipg_stop(),
            m7_edma4_ipg_stop: self.m7_edma4_ipg_stop(),
            m7_netc_ipg_stop: self.m7_netc_ipg_stop(),
            m7_sim_aon_ipg_stop: self.m7_sim_aon_ipg_stop(),
            m7_adc1_ipg_stop: self.m7_adc1_ipg_stop(),
            m7_adc2_ipg_stop: self.m7_adc2_ipg_stop(),
            m7_flexspi1_ipg_stop: self.m7_flexspi1_ipg_stop(),
            m7_flexspi2_ipg_stop: self.m7_flexspi2_ipg_stop(),
            m7_trdc_ipg_stop: self.m7_trdc_ipg_stop(),
            m7_semc_ipg_stop: self.m7_semc_ipg_stop(),
            m7_iee_ipg_stop: self.m7_iee_ipg_stop(),
            m7_gpio1_ipg_stop: self.m7_gpio1_ipg_stop(),
            m7_gpio2_ipg_stop: self.m7_gpio2_ipg_stop(),
            m7_gpio3_ipg_stop: self.m7_gpio3_ipg_stop(),
            m7_gpio4_ipg_stop: self.m7_gpio4_ipg_stop(),
            m7_gpio5_ipg_stop: self.m7_gpio5_ipg_stop(),
            m7_gpio6_ipg_stop: self.m7_gpio6_ipg_stop(),
            m7_flexio1_ipg_stop: self.m7_flexio1_ipg_stop(),
            m7_flexio2_ipg_stop: self.m7_flexio2_ipg_stop(),
            m7_can1_ipg_stop: self.m7_can1_ipg_stop(),
            m7_can2_ipg_stop: self.m7_can2_ipg_stop(),
            m7_can3_ipg_stop: self.m7_can3_ipg_stop(),
            m7_lpuart1_ipg_stop: self.m7_lpuart1_ipg_stop(),
            m7_lpuart2_ipg_stop: self.m7_lpuart2_ipg_stop(),
            m7_lpuart3_ipg_stop: self.m7_lpuart3_ipg_stop(),
            m7_lpuart4_ipg_stop: self.m7_lpuart4_ipg_stop(),
            m7_lpuart5_ipg_stop: self.m7_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13(pub u32);
impl GprShared13 {
    #[doc = "m7_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared13 {
    #[inline(always)]
    fn default() -> GprShared13 {
        GprShared13(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13")
            .field("m7_lpuart6_ipg_stop", &self.m7_lpuart6_ipg_stop())
            .field("m7_lpuart7_ipg_stop", &self.m7_lpuart7_ipg_stop())
            .field("m7_lpuart8_ipg_stop", &self.m7_lpuart8_ipg_stop())
            .field("m7_lpuart9_ipg_stop", &self.m7_lpuart9_ipg_stop())
            .field("m7_lpuart10_ipg_stop", &self.m7_lpuart10_ipg_stop())
            .field("m7_lpuart11_ipg_stop", &self.m7_lpuart11_ipg_stop())
            .field("m7_lpuart12_ipg_stop", &self.m7_lpuart12_ipg_stop())
            .field("m7_lpi2c1_ipg_stop", &self.m7_lpi2c1_ipg_stop())
            .field("m7_lpi2c2_ipg_stop", &self.m7_lpi2c2_ipg_stop())
            .field("m7_lpi2c3_ipg_stop", &self.m7_lpi2c3_ipg_stop())
            .field("m7_lpi2c4_ipg_stop", &self.m7_lpi2c4_ipg_stop())
            .field("m7_lpi2c5_ipg_stop", &self.m7_lpi2c5_ipg_stop())
            .field("m7_lpi2c6_ipg_stop", &self.m7_lpi2c6_ipg_stop())
            .field("m7_lpspi1_ipg_stop", &self.m7_lpspi1_ipg_stop())
            .field("m7_lpspi2_ipg_stop", &self.m7_lpspi2_ipg_stop())
            .field("m7_lpspi3_ipg_stop", &self.m7_lpspi3_ipg_stop())
            .field("m7_lpspi4_ipg_stop", &self.m7_lpspi4_ipg_stop())
            .field("m7_lpspi5_ipg_stop", &self.m7_lpspi5_ipg_stop())
            .field("m7_lpspi6_ipg_stop", &self.m7_lpspi6_ipg_stop())
            .field("m7_sinc1_ipg_stop", &self.m7_sinc1_ipg_stop())
            .field("m7_sinc2_ipg_stop", &self.m7_sinc2_ipg_stop())
            .field("m7_sinc3_ipg_stop", &self.m7_sinc3_ipg_stop())
            .field("m7_sai1_ipg_stop", &self.m7_sai1_ipg_stop())
            .field("m7_sai2_ipg_stop", &self.m7_sai2_ipg_stop())
            .field("m7_sai3_ipg_stop", &self.m7_sai3_ipg_stop())
            .field("m7_sai4_ipg_stop", &self.m7_sai4_ipg_stop())
            .field("m7_mic_ipg_stop", &self.m7_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13 {
            m7_lpuart6_ipg_stop: bool,
            m7_lpuart7_ipg_stop: bool,
            m7_lpuart8_ipg_stop: bool,
            m7_lpuart9_ipg_stop: bool,
            m7_lpuart10_ipg_stop: bool,
            m7_lpuart11_ipg_stop: bool,
            m7_lpuart12_ipg_stop: bool,
            m7_lpi2c1_ipg_stop: bool,
            m7_lpi2c2_ipg_stop: bool,
            m7_lpi2c3_ipg_stop: bool,
            m7_lpi2c4_ipg_stop: bool,
            m7_lpi2c5_ipg_stop: bool,
            m7_lpi2c6_ipg_stop: bool,
            m7_lpspi1_ipg_stop: bool,
            m7_lpspi2_ipg_stop: bool,
            m7_lpspi3_ipg_stop: bool,
            m7_lpspi4_ipg_stop: bool,
            m7_lpspi5_ipg_stop: bool,
            m7_lpspi6_ipg_stop: bool,
            m7_sinc1_ipg_stop: bool,
            m7_sinc2_ipg_stop: bool,
            m7_sinc3_ipg_stop: bool,
            m7_sai1_ipg_stop: bool,
            m7_sai2_ipg_stop: bool,
            m7_sai3_ipg_stop: bool,
            m7_sai4_ipg_stop: bool,
            m7_mic_ipg_stop: bool,
        }
        let proxy = GprShared13 {
            m7_lpuart6_ipg_stop: self.m7_lpuart6_ipg_stop(),
            m7_lpuart7_ipg_stop: self.m7_lpuart7_ipg_stop(),
            m7_lpuart8_ipg_stop: self.m7_lpuart8_ipg_stop(),
            m7_lpuart9_ipg_stop: self.m7_lpuart9_ipg_stop(),
            m7_lpuart10_ipg_stop: self.m7_lpuart10_ipg_stop(),
            m7_lpuart11_ipg_stop: self.m7_lpuart11_ipg_stop(),
            m7_lpuart12_ipg_stop: self.m7_lpuart12_ipg_stop(),
            m7_lpi2c1_ipg_stop: self.m7_lpi2c1_ipg_stop(),
            m7_lpi2c2_ipg_stop: self.m7_lpi2c2_ipg_stop(),
            m7_lpi2c3_ipg_stop: self.m7_lpi2c3_ipg_stop(),
            m7_lpi2c4_ipg_stop: self.m7_lpi2c4_ipg_stop(),
            m7_lpi2c5_ipg_stop: self.m7_lpi2c5_ipg_stop(),
            m7_lpi2c6_ipg_stop: self.m7_lpi2c6_ipg_stop(),
            m7_lpspi1_ipg_stop: self.m7_lpspi1_ipg_stop(),
            m7_lpspi2_ipg_stop: self.m7_lpspi2_ipg_stop(),
            m7_lpspi3_ipg_stop: self.m7_lpspi3_ipg_stop(),
            m7_lpspi4_ipg_stop: self.m7_lpspi4_ipg_stop(),
            m7_lpspi5_ipg_stop: self.m7_lpspi5_ipg_stop(),
            m7_lpspi6_ipg_stop: self.m7_lpspi6_ipg_stop(),
            m7_sinc1_ipg_stop: self.m7_sinc1_ipg_stop(),
            m7_sinc2_ipg_stop: self.m7_sinc2_ipg_stop(),
            m7_sinc3_ipg_stop: self.m7_sinc3_ipg_stop(),
            m7_sai1_ipg_stop: self.m7_sai1_ipg_stop(),
            m7_sai2_ipg_stop: self.m7_sai2_ipg_stop(),
            m7_sai3_ipg_stop: self.m7_sai3_ipg_stop(),
            m7_sai4_ipg_stop: self.m7_sai4_ipg_stop(),
            m7_mic_ipg_stop: self.m7_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13Authen(pub u32);
impl GprShared13Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared13AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared13AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared13AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared13AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared13AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared13AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared13Authen {
    #[inline(always)]
    fn default() -> GprShared13Authen {
        GprShared13Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13Authen {
            tz_user: super::vals::GprShared13AuthenTzUser,
            tz_ns: super::vals::GprShared13AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared13Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13AuthenClr(pub u32);
impl GprShared13AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared13AuthenClr {
    #[inline(always)]
    fn default() -> GprShared13AuthenClr {
        GprShared13AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared13AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13AuthenSet(pub u32);
impl GprShared13AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared13AuthenSet {
    #[inline(always)]
    fn default() -> GprShared13AuthenSet {
        GprShared13AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared13AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13AuthenTog(pub u32);
impl GprShared13AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared13AuthenTog {
    #[inline(always)]
    fn default() -> GprShared13AuthenTog {
        GprShared13AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared13AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13Clr(pub u32);
impl GprShared13Clr {
    #[doc = "m7_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared13Clr {
    #[inline(always)]
    fn default() -> GprShared13Clr {
        GprShared13Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13Clr")
            .field("m7_lpuart6_ipg_stop", &self.m7_lpuart6_ipg_stop())
            .field("m7_lpuart7_ipg_stop", &self.m7_lpuart7_ipg_stop())
            .field("m7_lpuart8_ipg_stop", &self.m7_lpuart8_ipg_stop())
            .field("m7_lpuart9_ipg_stop", &self.m7_lpuart9_ipg_stop())
            .field("m7_lpuart10_ipg_stop", &self.m7_lpuart10_ipg_stop())
            .field("m7_lpuart11_ipg_stop", &self.m7_lpuart11_ipg_stop())
            .field("m7_lpuart12_ipg_stop", &self.m7_lpuart12_ipg_stop())
            .field("m7_lpi2c1_ipg_stop", &self.m7_lpi2c1_ipg_stop())
            .field("m7_lpi2c2_ipg_stop", &self.m7_lpi2c2_ipg_stop())
            .field("m7_lpi2c3_ipg_stop", &self.m7_lpi2c3_ipg_stop())
            .field("m7_lpi2c4_ipg_stop", &self.m7_lpi2c4_ipg_stop())
            .field("m7_lpi2c5_ipg_stop", &self.m7_lpi2c5_ipg_stop())
            .field("m7_lpi2c6_ipg_stop", &self.m7_lpi2c6_ipg_stop())
            .field("m7_lpspi1_ipg_stop", &self.m7_lpspi1_ipg_stop())
            .field("m7_lpspi2_ipg_stop", &self.m7_lpspi2_ipg_stop())
            .field("m7_lpspi3_ipg_stop", &self.m7_lpspi3_ipg_stop())
            .field("m7_lpspi4_ipg_stop", &self.m7_lpspi4_ipg_stop())
            .field("m7_lpspi5_ipg_stop", &self.m7_lpspi5_ipg_stop())
            .field("m7_lpspi6_ipg_stop", &self.m7_lpspi6_ipg_stop())
            .field("m7_sinc1_ipg_stop", &self.m7_sinc1_ipg_stop())
            .field("m7_sinc2_ipg_stop", &self.m7_sinc2_ipg_stop())
            .field("m7_sinc3_ipg_stop", &self.m7_sinc3_ipg_stop())
            .field("m7_sai1_ipg_stop", &self.m7_sai1_ipg_stop())
            .field("m7_sai2_ipg_stop", &self.m7_sai2_ipg_stop())
            .field("m7_sai3_ipg_stop", &self.m7_sai3_ipg_stop())
            .field("m7_sai4_ipg_stop", &self.m7_sai4_ipg_stop())
            .field("m7_mic_ipg_stop", &self.m7_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13Clr {
            m7_lpuart6_ipg_stop: bool,
            m7_lpuart7_ipg_stop: bool,
            m7_lpuart8_ipg_stop: bool,
            m7_lpuart9_ipg_stop: bool,
            m7_lpuart10_ipg_stop: bool,
            m7_lpuart11_ipg_stop: bool,
            m7_lpuart12_ipg_stop: bool,
            m7_lpi2c1_ipg_stop: bool,
            m7_lpi2c2_ipg_stop: bool,
            m7_lpi2c3_ipg_stop: bool,
            m7_lpi2c4_ipg_stop: bool,
            m7_lpi2c5_ipg_stop: bool,
            m7_lpi2c6_ipg_stop: bool,
            m7_lpspi1_ipg_stop: bool,
            m7_lpspi2_ipg_stop: bool,
            m7_lpspi3_ipg_stop: bool,
            m7_lpspi4_ipg_stop: bool,
            m7_lpspi5_ipg_stop: bool,
            m7_lpspi6_ipg_stop: bool,
            m7_sinc1_ipg_stop: bool,
            m7_sinc2_ipg_stop: bool,
            m7_sinc3_ipg_stop: bool,
            m7_sai1_ipg_stop: bool,
            m7_sai2_ipg_stop: bool,
            m7_sai3_ipg_stop: bool,
            m7_sai4_ipg_stop: bool,
            m7_mic_ipg_stop: bool,
        }
        let proxy = GprShared13Clr {
            m7_lpuart6_ipg_stop: self.m7_lpuart6_ipg_stop(),
            m7_lpuart7_ipg_stop: self.m7_lpuart7_ipg_stop(),
            m7_lpuart8_ipg_stop: self.m7_lpuart8_ipg_stop(),
            m7_lpuart9_ipg_stop: self.m7_lpuart9_ipg_stop(),
            m7_lpuart10_ipg_stop: self.m7_lpuart10_ipg_stop(),
            m7_lpuart11_ipg_stop: self.m7_lpuart11_ipg_stop(),
            m7_lpuart12_ipg_stop: self.m7_lpuart12_ipg_stop(),
            m7_lpi2c1_ipg_stop: self.m7_lpi2c1_ipg_stop(),
            m7_lpi2c2_ipg_stop: self.m7_lpi2c2_ipg_stop(),
            m7_lpi2c3_ipg_stop: self.m7_lpi2c3_ipg_stop(),
            m7_lpi2c4_ipg_stop: self.m7_lpi2c4_ipg_stop(),
            m7_lpi2c5_ipg_stop: self.m7_lpi2c5_ipg_stop(),
            m7_lpi2c6_ipg_stop: self.m7_lpi2c6_ipg_stop(),
            m7_lpspi1_ipg_stop: self.m7_lpspi1_ipg_stop(),
            m7_lpspi2_ipg_stop: self.m7_lpspi2_ipg_stop(),
            m7_lpspi3_ipg_stop: self.m7_lpspi3_ipg_stop(),
            m7_lpspi4_ipg_stop: self.m7_lpspi4_ipg_stop(),
            m7_lpspi5_ipg_stop: self.m7_lpspi5_ipg_stop(),
            m7_lpspi6_ipg_stop: self.m7_lpspi6_ipg_stop(),
            m7_sinc1_ipg_stop: self.m7_sinc1_ipg_stop(),
            m7_sinc2_ipg_stop: self.m7_sinc2_ipg_stop(),
            m7_sinc3_ipg_stop: self.m7_sinc3_ipg_stop(),
            m7_sai1_ipg_stop: self.m7_sai1_ipg_stop(),
            m7_sai2_ipg_stop: self.m7_sai2_ipg_stop(),
            m7_sai3_ipg_stop: self.m7_sai3_ipg_stop(),
            m7_sai4_ipg_stop: self.m7_sai4_ipg_stop(),
            m7_mic_ipg_stop: self.m7_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13Set(pub u32);
impl GprShared13Set {
    #[doc = "m7_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared13Set {
    #[inline(always)]
    fn default() -> GprShared13Set {
        GprShared13Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13Set")
            .field("m7_lpuart6_ipg_stop", &self.m7_lpuart6_ipg_stop())
            .field("m7_lpuart7_ipg_stop", &self.m7_lpuart7_ipg_stop())
            .field("m7_lpuart8_ipg_stop", &self.m7_lpuart8_ipg_stop())
            .field("m7_lpuart9_ipg_stop", &self.m7_lpuart9_ipg_stop())
            .field("m7_lpuart10_ipg_stop", &self.m7_lpuart10_ipg_stop())
            .field("m7_lpuart11_ipg_stop", &self.m7_lpuart11_ipg_stop())
            .field("m7_lpuart12_ipg_stop", &self.m7_lpuart12_ipg_stop())
            .field("m7_lpi2c1_ipg_stop", &self.m7_lpi2c1_ipg_stop())
            .field("m7_lpi2c2_ipg_stop", &self.m7_lpi2c2_ipg_stop())
            .field("m7_lpi2c3_ipg_stop", &self.m7_lpi2c3_ipg_stop())
            .field("m7_lpi2c4_ipg_stop", &self.m7_lpi2c4_ipg_stop())
            .field("m7_lpi2c5_ipg_stop", &self.m7_lpi2c5_ipg_stop())
            .field("m7_lpi2c6_ipg_stop", &self.m7_lpi2c6_ipg_stop())
            .field("m7_lpspi1_ipg_stop", &self.m7_lpspi1_ipg_stop())
            .field("m7_lpspi2_ipg_stop", &self.m7_lpspi2_ipg_stop())
            .field("m7_lpspi3_ipg_stop", &self.m7_lpspi3_ipg_stop())
            .field("m7_lpspi4_ipg_stop", &self.m7_lpspi4_ipg_stop())
            .field("m7_lpspi5_ipg_stop", &self.m7_lpspi5_ipg_stop())
            .field("m7_lpspi6_ipg_stop", &self.m7_lpspi6_ipg_stop())
            .field("m7_sinc1_ipg_stop", &self.m7_sinc1_ipg_stop())
            .field("m7_sinc2_ipg_stop", &self.m7_sinc2_ipg_stop())
            .field("m7_sinc3_ipg_stop", &self.m7_sinc3_ipg_stop())
            .field("m7_sai1_ipg_stop", &self.m7_sai1_ipg_stop())
            .field("m7_sai2_ipg_stop", &self.m7_sai2_ipg_stop())
            .field("m7_sai3_ipg_stop", &self.m7_sai3_ipg_stop())
            .field("m7_sai4_ipg_stop", &self.m7_sai4_ipg_stop())
            .field("m7_mic_ipg_stop", &self.m7_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13Set {
            m7_lpuart6_ipg_stop: bool,
            m7_lpuart7_ipg_stop: bool,
            m7_lpuart8_ipg_stop: bool,
            m7_lpuart9_ipg_stop: bool,
            m7_lpuart10_ipg_stop: bool,
            m7_lpuart11_ipg_stop: bool,
            m7_lpuart12_ipg_stop: bool,
            m7_lpi2c1_ipg_stop: bool,
            m7_lpi2c2_ipg_stop: bool,
            m7_lpi2c3_ipg_stop: bool,
            m7_lpi2c4_ipg_stop: bool,
            m7_lpi2c5_ipg_stop: bool,
            m7_lpi2c6_ipg_stop: bool,
            m7_lpspi1_ipg_stop: bool,
            m7_lpspi2_ipg_stop: bool,
            m7_lpspi3_ipg_stop: bool,
            m7_lpspi4_ipg_stop: bool,
            m7_lpspi5_ipg_stop: bool,
            m7_lpspi6_ipg_stop: bool,
            m7_sinc1_ipg_stop: bool,
            m7_sinc2_ipg_stop: bool,
            m7_sinc3_ipg_stop: bool,
            m7_sai1_ipg_stop: bool,
            m7_sai2_ipg_stop: bool,
            m7_sai3_ipg_stop: bool,
            m7_sai4_ipg_stop: bool,
            m7_mic_ipg_stop: bool,
        }
        let proxy = GprShared13Set {
            m7_lpuart6_ipg_stop: self.m7_lpuart6_ipg_stop(),
            m7_lpuart7_ipg_stop: self.m7_lpuart7_ipg_stop(),
            m7_lpuart8_ipg_stop: self.m7_lpuart8_ipg_stop(),
            m7_lpuart9_ipg_stop: self.m7_lpuart9_ipg_stop(),
            m7_lpuart10_ipg_stop: self.m7_lpuart10_ipg_stop(),
            m7_lpuart11_ipg_stop: self.m7_lpuart11_ipg_stop(),
            m7_lpuart12_ipg_stop: self.m7_lpuart12_ipg_stop(),
            m7_lpi2c1_ipg_stop: self.m7_lpi2c1_ipg_stop(),
            m7_lpi2c2_ipg_stop: self.m7_lpi2c2_ipg_stop(),
            m7_lpi2c3_ipg_stop: self.m7_lpi2c3_ipg_stop(),
            m7_lpi2c4_ipg_stop: self.m7_lpi2c4_ipg_stop(),
            m7_lpi2c5_ipg_stop: self.m7_lpi2c5_ipg_stop(),
            m7_lpi2c6_ipg_stop: self.m7_lpi2c6_ipg_stop(),
            m7_lpspi1_ipg_stop: self.m7_lpspi1_ipg_stop(),
            m7_lpspi2_ipg_stop: self.m7_lpspi2_ipg_stop(),
            m7_lpspi3_ipg_stop: self.m7_lpspi3_ipg_stop(),
            m7_lpspi4_ipg_stop: self.m7_lpspi4_ipg_stop(),
            m7_lpspi5_ipg_stop: self.m7_lpspi5_ipg_stop(),
            m7_lpspi6_ipg_stop: self.m7_lpspi6_ipg_stop(),
            m7_sinc1_ipg_stop: self.m7_sinc1_ipg_stop(),
            m7_sinc2_ipg_stop: self.m7_sinc2_ipg_stop(),
            m7_sinc3_ipg_stop: self.m7_sinc3_ipg_stop(),
            m7_sai1_ipg_stop: self.m7_sai1_ipg_stop(),
            m7_sai2_ipg_stop: self.m7_sai2_ipg_stop(),
            m7_sai3_ipg_stop: self.m7_sai3_ipg_stop(),
            m7_sai4_ipg_stop: self.m7_sai4_ipg_stop(),
            m7_mic_ipg_stop: self.m7_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared13Tog(pub u32);
impl GprShared13Tog {
    #[doc = "m7_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared13Tog {
    #[inline(always)]
    fn default() -> GprShared13Tog {
        GprShared13Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared13Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared13Tog")
            .field("m7_lpuart6_ipg_stop", &self.m7_lpuart6_ipg_stop())
            .field("m7_lpuart7_ipg_stop", &self.m7_lpuart7_ipg_stop())
            .field("m7_lpuart8_ipg_stop", &self.m7_lpuart8_ipg_stop())
            .field("m7_lpuart9_ipg_stop", &self.m7_lpuart9_ipg_stop())
            .field("m7_lpuart10_ipg_stop", &self.m7_lpuart10_ipg_stop())
            .field("m7_lpuart11_ipg_stop", &self.m7_lpuart11_ipg_stop())
            .field("m7_lpuart12_ipg_stop", &self.m7_lpuart12_ipg_stop())
            .field("m7_lpi2c1_ipg_stop", &self.m7_lpi2c1_ipg_stop())
            .field("m7_lpi2c2_ipg_stop", &self.m7_lpi2c2_ipg_stop())
            .field("m7_lpi2c3_ipg_stop", &self.m7_lpi2c3_ipg_stop())
            .field("m7_lpi2c4_ipg_stop", &self.m7_lpi2c4_ipg_stop())
            .field("m7_lpi2c5_ipg_stop", &self.m7_lpi2c5_ipg_stop())
            .field("m7_lpi2c6_ipg_stop", &self.m7_lpi2c6_ipg_stop())
            .field("m7_lpspi1_ipg_stop", &self.m7_lpspi1_ipg_stop())
            .field("m7_lpspi2_ipg_stop", &self.m7_lpspi2_ipg_stop())
            .field("m7_lpspi3_ipg_stop", &self.m7_lpspi3_ipg_stop())
            .field("m7_lpspi4_ipg_stop", &self.m7_lpspi4_ipg_stop())
            .field("m7_lpspi5_ipg_stop", &self.m7_lpspi5_ipg_stop())
            .field("m7_lpspi6_ipg_stop", &self.m7_lpspi6_ipg_stop())
            .field("m7_sinc1_ipg_stop", &self.m7_sinc1_ipg_stop())
            .field("m7_sinc2_ipg_stop", &self.m7_sinc2_ipg_stop())
            .field("m7_sinc3_ipg_stop", &self.m7_sinc3_ipg_stop())
            .field("m7_sai1_ipg_stop", &self.m7_sai1_ipg_stop())
            .field("m7_sai2_ipg_stop", &self.m7_sai2_ipg_stop())
            .field("m7_sai3_ipg_stop", &self.m7_sai3_ipg_stop())
            .field("m7_sai4_ipg_stop", &self.m7_sai4_ipg_stop())
            .field("m7_mic_ipg_stop", &self.m7_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared13Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared13Tog {
            m7_lpuart6_ipg_stop: bool,
            m7_lpuart7_ipg_stop: bool,
            m7_lpuart8_ipg_stop: bool,
            m7_lpuart9_ipg_stop: bool,
            m7_lpuart10_ipg_stop: bool,
            m7_lpuart11_ipg_stop: bool,
            m7_lpuart12_ipg_stop: bool,
            m7_lpi2c1_ipg_stop: bool,
            m7_lpi2c2_ipg_stop: bool,
            m7_lpi2c3_ipg_stop: bool,
            m7_lpi2c4_ipg_stop: bool,
            m7_lpi2c5_ipg_stop: bool,
            m7_lpi2c6_ipg_stop: bool,
            m7_lpspi1_ipg_stop: bool,
            m7_lpspi2_ipg_stop: bool,
            m7_lpspi3_ipg_stop: bool,
            m7_lpspi4_ipg_stop: bool,
            m7_lpspi5_ipg_stop: bool,
            m7_lpspi6_ipg_stop: bool,
            m7_sinc1_ipg_stop: bool,
            m7_sinc2_ipg_stop: bool,
            m7_sinc3_ipg_stop: bool,
            m7_sai1_ipg_stop: bool,
            m7_sai2_ipg_stop: bool,
            m7_sai3_ipg_stop: bool,
            m7_sai4_ipg_stop: bool,
            m7_mic_ipg_stop: bool,
        }
        let proxy = GprShared13Tog {
            m7_lpuart6_ipg_stop: self.m7_lpuart6_ipg_stop(),
            m7_lpuart7_ipg_stop: self.m7_lpuart7_ipg_stop(),
            m7_lpuart8_ipg_stop: self.m7_lpuart8_ipg_stop(),
            m7_lpuart9_ipg_stop: self.m7_lpuart9_ipg_stop(),
            m7_lpuart10_ipg_stop: self.m7_lpuart10_ipg_stop(),
            m7_lpuart11_ipg_stop: self.m7_lpuart11_ipg_stop(),
            m7_lpuart12_ipg_stop: self.m7_lpuart12_ipg_stop(),
            m7_lpi2c1_ipg_stop: self.m7_lpi2c1_ipg_stop(),
            m7_lpi2c2_ipg_stop: self.m7_lpi2c2_ipg_stop(),
            m7_lpi2c3_ipg_stop: self.m7_lpi2c3_ipg_stop(),
            m7_lpi2c4_ipg_stop: self.m7_lpi2c4_ipg_stop(),
            m7_lpi2c5_ipg_stop: self.m7_lpi2c5_ipg_stop(),
            m7_lpi2c6_ipg_stop: self.m7_lpi2c6_ipg_stop(),
            m7_lpspi1_ipg_stop: self.m7_lpspi1_ipg_stop(),
            m7_lpspi2_ipg_stop: self.m7_lpspi2_ipg_stop(),
            m7_lpspi3_ipg_stop: self.m7_lpspi3_ipg_stop(),
            m7_lpspi4_ipg_stop: self.m7_lpspi4_ipg_stop(),
            m7_lpspi5_ipg_stop: self.m7_lpspi5_ipg_stop(),
            m7_lpspi6_ipg_stop: self.m7_lpspi6_ipg_stop(),
            m7_sinc1_ipg_stop: self.m7_sinc1_ipg_stop(),
            m7_sinc2_ipg_stop: self.m7_sinc2_ipg_stop(),
            m7_sinc3_ipg_stop: self.m7_sinc3_ipg_stop(),
            m7_sai1_ipg_stop: self.m7_sai1_ipg_stop(),
            m7_sai2_ipg_stop: self.m7_sai2_ipg_stop(),
            m7_sai3_ipg_stop: self.m7_sai3_ipg_stop(),
            m7_sai4_ipg_stop: self.m7_sai4_ipg_stop(),
            m7_mic_ipg_stop: self.m7_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14(pub u32);
impl GprShared14 {
    #[doc = "m7_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared14 {
    #[inline(always)]
    fn default() -> GprShared14 {
        GprShared14(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14")
            .field("m7_adc1_ipg_doze", &self.m7_adc1_ipg_doze())
            .field("m7_adc2_ipg_doze", &self.m7_adc2_ipg_doze())
            .field("m7_flexspi1_ipg_doze", &self.m7_flexspi1_ipg_doze())
            .field("m7_flexspi2_ipg_doze", &self.m7_flexspi2_ipg_doze())
            .field("m7_flexio1_ipg_doze", &self.m7_flexio1_ipg_doze())
            .field("m7_flexio2_ipg_doze", &self.m7_flexio2_ipg_doze())
            .field("m7_lpit1_ipg_doze", &self.m7_lpit1_ipg_doze())
            .field("m7_lpit2_ipg_doze", &self.m7_lpit2_ipg_doze())
            .field("m7_lpit3_ipg_doze", &self.m7_lpit3_ipg_doze())
            .field("m7_tpm1_ipg_doze", &self.m7_tpm1_ipg_doze())
            .field("m7_tpm2_ipg_doze", &self.m7_tpm2_ipg_doze())
            .field("m7_tpm3_ipg_doze", &self.m7_tpm3_ipg_doze())
            .field("m7_tpm4_ipg_doze", &self.m7_tpm4_ipg_doze())
            .field("m7_tpm5_ipg_doze", &self.m7_tpm5_ipg_doze())
            .field("m7_tpm6_ipg_doze", &self.m7_tpm6_ipg_doze())
            .field("m7_gpt1_ipg_doze", &self.m7_gpt1_ipg_doze())
            .field("m7_gpt2_ipg_doze", &self.m7_gpt2_ipg_doze())
            .field("m7_can1_ipg_doze", &self.m7_can1_ipg_doze())
            .field("m7_can2_ipg_doze", &self.m7_can2_ipg_doze())
            .field("m7_can3_ipg_doze", &self.m7_can3_ipg_doze())
            .field("m7_lpuart1_ipg_doze", &self.m7_lpuart1_ipg_doze())
            .field("m7_lpuart2_ipg_doze", &self.m7_lpuart2_ipg_doze())
            .field("m7_lpuart3_ipg_doze", &self.m7_lpuart3_ipg_doze())
            .field("m7_lpuart4_ipg_doze", &self.m7_lpuart4_ipg_doze())
            .field("m7_lpuart5_ipg_doze", &self.m7_lpuart5_ipg_doze())
            .field("m7_lpuart6_ipg_doze", &self.m7_lpuart6_ipg_doze())
            .field("m7_lpuart7_ipg_doze", &self.m7_lpuart7_ipg_doze())
            .field("m7_lpuart8_ipg_doze", &self.m7_lpuart8_ipg_doze())
            .field("m7_lpuart9_ipg_doze", &self.m7_lpuart9_ipg_doze())
            .field("m7_lpuart10_ipg_doze", &self.m7_lpuart10_ipg_doze())
            .field("m7_lpuart11_ipg_doze", &self.m7_lpuart11_ipg_doze())
            .field("m7_lpuart12_ipg_doze", &self.m7_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14 {
            m7_adc1_ipg_doze: bool,
            m7_adc2_ipg_doze: bool,
            m7_flexspi1_ipg_doze: bool,
            m7_flexspi2_ipg_doze: bool,
            m7_flexio1_ipg_doze: bool,
            m7_flexio2_ipg_doze: bool,
            m7_lpit1_ipg_doze: bool,
            m7_lpit2_ipg_doze: bool,
            m7_lpit3_ipg_doze: bool,
            m7_tpm1_ipg_doze: bool,
            m7_tpm2_ipg_doze: bool,
            m7_tpm3_ipg_doze: bool,
            m7_tpm4_ipg_doze: bool,
            m7_tpm5_ipg_doze: bool,
            m7_tpm6_ipg_doze: bool,
            m7_gpt1_ipg_doze: bool,
            m7_gpt2_ipg_doze: bool,
            m7_can1_ipg_doze: bool,
            m7_can2_ipg_doze: bool,
            m7_can3_ipg_doze: bool,
            m7_lpuart1_ipg_doze: bool,
            m7_lpuart2_ipg_doze: bool,
            m7_lpuart3_ipg_doze: bool,
            m7_lpuart4_ipg_doze: bool,
            m7_lpuart5_ipg_doze: bool,
            m7_lpuart6_ipg_doze: bool,
            m7_lpuart7_ipg_doze: bool,
            m7_lpuart8_ipg_doze: bool,
            m7_lpuart9_ipg_doze: bool,
            m7_lpuart10_ipg_doze: bool,
            m7_lpuart11_ipg_doze: bool,
            m7_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared14 {
            m7_adc1_ipg_doze: self.m7_adc1_ipg_doze(),
            m7_adc2_ipg_doze: self.m7_adc2_ipg_doze(),
            m7_flexspi1_ipg_doze: self.m7_flexspi1_ipg_doze(),
            m7_flexspi2_ipg_doze: self.m7_flexspi2_ipg_doze(),
            m7_flexio1_ipg_doze: self.m7_flexio1_ipg_doze(),
            m7_flexio2_ipg_doze: self.m7_flexio2_ipg_doze(),
            m7_lpit1_ipg_doze: self.m7_lpit1_ipg_doze(),
            m7_lpit2_ipg_doze: self.m7_lpit2_ipg_doze(),
            m7_lpit3_ipg_doze: self.m7_lpit3_ipg_doze(),
            m7_tpm1_ipg_doze: self.m7_tpm1_ipg_doze(),
            m7_tpm2_ipg_doze: self.m7_tpm2_ipg_doze(),
            m7_tpm3_ipg_doze: self.m7_tpm3_ipg_doze(),
            m7_tpm4_ipg_doze: self.m7_tpm4_ipg_doze(),
            m7_tpm5_ipg_doze: self.m7_tpm5_ipg_doze(),
            m7_tpm6_ipg_doze: self.m7_tpm6_ipg_doze(),
            m7_gpt1_ipg_doze: self.m7_gpt1_ipg_doze(),
            m7_gpt2_ipg_doze: self.m7_gpt2_ipg_doze(),
            m7_can1_ipg_doze: self.m7_can1_ipg_doze(),
            m7_can2_ipg_doze: self.m7_can2_ipg_doze(),
            m7_can3_ipg_doze: self.m7_can3_ipg_doze(),
            m7_lpuart1_ipg_doze: self.m7_lpuart1_ipg_doze(),
            m7_lpuart2_ipg_doze: self.m7_lpuart2_ipg_doze(),
            m7_lpuart3_ipg_doze: self.m7_lpuart3_ipg_doze(),
            m7_lpuart4_ipg_doze: self.m7_lpuart4_ipg_doze(),
            m7_lpuart5_ipg_doze: self.m7_lpuart5_ipg_doze(),
            m7_lpuart6_ipg_doze: self.m7_lpuart6_ipg_doze(),
            m7_lpuart7_ipg_doze: self.m7_lpuart7_ipg_doze(),
            m7_lpuart8_ipg_doze: self.m7_lpuart8_ipg_doze(),
            m7_lpuart9_ipg_doze: self.m7_lpuart9_ipg_doze(),
            m7_lpuart10_ipg_doze: self.m7_lpuart10_ipg_doze(),
            m7_lpuart11_ipg_doze: self.m7_lpuart11_ipg_doze(),
            m7_lpuart12_ipg_doze: self.m7_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14Authen(pub u32);
impl GprShared14Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared14AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared14AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared14AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared14AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared14AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared14AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared14Authen {
    #[inline(always)]
    fn default() -> GprShared14Authen {
        GprShared14Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14Authen {
            tz_user: super::vals::GprShared14AuthenTzUser,
            tz_ns: super::vals::GprShared14AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared14Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14AuthenClr(pub u32);
impl GprShared14AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared14AuthenClr {
    #[inline(always)]
    fn default() -> GprShared14AuthenClr {
        GprShared14AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared14AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14AuthenSet(pub u32);
impl GprShared14AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared14AuthenSet {
    #[inline(always)]
    fn default() -> GprShared14AuthenSet {
        GprShared14AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared14AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14AuthenTog(pub u32);
impl GprShared14AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared14AuthenTog {
    #[inline(always)]
    fn default() -> GprShared14AuthenTog {
        GprShared14AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared14AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14Clr(pub u32);
impl GprShared14Clr {
    #[doc = "m7_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared14Clr {
    #[inline(always)]
    fn default() -> GprShared14Clr {
        GprShared14Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14Clr")
            .field("m7_adc1_ipg_doze", &self.m7_adc1_ipg_doze())
            .field("m7_adc2_ipg_doze", &self.m7_adc2_ipg_doze())
            .field("m7_flexspi1_ipg_doze", &self.m7_flexspi1_ipg_doze())
            .field("m7_flexspi2_ipg_doze", &self.m7_flexspi2_ipg_doze())
            .field("m7_flexio1_ipg_doze", &self.m7_flexio1_ipg_doze())
            .field("m7_flexio2_ipg_doze", &self.m7_flexio2_ipg_doze())
            .field("m7_lpit1_ipg_doze", &self.m7_lpit1_ipg_doze())
            .field("m7_lpit2_ipg_doze", &self.m7_lpit2_ipg_doze())
            .field("m7_lpit3_ipg_doze", &self.m7_lpit3_ipg_doze())
            .field("m7_tpm1_ipg_doze", &self.m7_tpm1_ipg_doze())
            .field("m7_tpm2_ipg_doze", &self.m7_tpm2_ipg_doze())
            .field("m7_tpm3_ipg_doze", &self.m7_tpm3_ipg_doze())
            .field("m7_tpm4_ipg_doze", &self.m7_tpm4_ipg_doze())
            .field("m7_tpm5_ipg_doze", &self.m7_tpm5_ipg_doze())
            .field("m7_tpm6_ipg_doze", &self.m7_tpm6_ipg_doze())
            .field("m7_gpt1_ipg_doze", &self.m7_gpt1_ipg_doze())
            .field("m7_gpt2_ipg_doze", &self.m7_gpt2_ipg_doze())
            .field("m7_can1_ipg_doze", &self.m7_can1_ipg_doze())
            .field("m7_can2_ipg_doze", &self.m7_can2_ipg_doze())
            .field("m7_can3_ipg_doze", &self.m7_can3_ipg_doze())
            .field("m7_lpuart1_ipg_doze", &self.m7_lpuart1_ipg_doze())
            .field("m7_lpuart2_ipg_doze", &self.m7_lpuart2_ipg_doze())
            .field("m7_lpuart3_ipg_doze", &self.m7_lpuart3_ipg_doze())
            .field("m7_lpuart4_ipg_doze", &self.m7_lpuart4_ipg_doze())
            .field("m7_lpuart5_ipg_doze", &self.m7_lpuart5_ipg_doze())
            .field("m7_lpuart6_ipg_doze", &self.m7_lpuart6_ipg_doze())
            .field("m7_lpuart7_ipg_doze", &self.m7_lpuart7_ipg_doze())
            .field("m7_lpuart8_ipg_doze", &self.m7_lpuart8_ipg_doze())
            .field("m7_lpuart9_ipg_doze", &self.m7_lpuart9_ipg_doze())
            .field("m7_lpuart10_ipg_doze", &self.m7_lpuart10_ipg_doze())
            .field("m7_lpuart11_ipg_doze", &self.m7_lpuart11_ipg_doze())
            .field("m7_lpuart12_ipg_doze", &self.m7_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14Clr {
            m7_adc1_ipg_doze: bool,
            m7_adc2_ipg_doze: bool,
            m7_flexspi1_ipg_doze: bool,
            m7_flexspi2_ipg_doze: bool,
            m7_flexio1_ipg_doze: bool,
            m7_flexio2_ipg_doze: bool,
            m7_lpit1_ipg_doze: bool,
            m7_lpit2_ipg_doze: bool,
            m7_lpit3_ipg_doze: bool,
            m7_tpm1_ipg_doze: bool,
            m7_tpm2_ipg_doze: bool,
            m7_tpm3_ipg_doze: bool,
            m7_tpm4_ipg_doze: bool,
            m7_tpm5_ipg_doze: bool,
            m7_tpm6_ipg_doze: bool,
            m7_gpt1_ipg_doze: bool,
            m7_gpt2_ipg_doze: bool,
            m7_can1_ipg_doze: bool,
            m7_can2_ipg_doze: bool,
            m7_can3_ipg_doze: bool,
            m7_lpuart1_ipg_doze: bool,
            m7_lpuart2_ipg_doze: bool,
            m7_lpuart3_ipg_doze: bool,
            m7_lpuart4_ipg_doze: bool,
            m7_lpuart5_ipg_doze: bool,
            m7_lpuart6_ipg_doze: bool,
            m7_lpuart7_ipg_doze: bool,
            m7_lpuart8_ipg_doze: bool,
            m7_lpuart9_ipg_doze: bool,
            m7_lpuart10_ipg_doze: bool,
            m7_lpuart11_ipg_doze: bool,
            m7_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared14Clr {
            m7_adc1_ipg_doze: self.m7_adc1_ipg_doze(),
            m7_adc2_ipg_doze: self.m7_adc2_ipg_doze(),
            m7_flexspi1_ipg_doze: self.m7_flexspi1_ipg_doze(),
            m7_flexspi2_ipg_doze: self.m7_flexspi2_ipg_doze(),
            m7_flexio1_ipg_doze: self.m7_flexio1_ipg_doze(),
            m7_flexio2_ipg_doze: self.m7_flexio2_ipg_doze(),
            m7_lpit1_ipg_doze: self.m7_lpit1_ipg_doze(),
            m7_lpit2_ipg_doze: self.m7_lpit2_ipg_doze(),
            m7_lpit3_ipg_doze: self.m7_lpit3_ipg_doze(),
            m7_tpm1_ipg_doze: self.m7_tpm1_ipg_doze(),
            m7_tpm2_ipg_doze: self.m7_tpm2_ipg_doze(),
            m7_tpm3_ipg_doze: self.m7_tpm3_ipg_doze(),
            m7_tpm4_ipg_doze: self.m7_tpm4_ipg_doze(),
            m7_tpm5_ipg_doze: self.m7_tpm5_ipg_doze(),
            m7_tpm6_ipg_doze: self.m7_tpm6_ipg_doze(),
            m7_gpt1_ipg_doze: self.m7_gpt1_ipg_doze(),
            m7_gpt2_ipg_doze: self.m7_gpt2_ipg_doze(),
            m7_can1_ipg_doze: self.m7_can1_ipg_doze(),
            m7_can2_ipg_doze: self.m7_can2_ipg_doze(),
            m7_can3_ipg_doze: self.m7_can3_ipg_doze(),
            m7_lpuart1_ipg_doze: self.m7_lpuart1_ipg_doze(),
            m7_lpuart2_ipg_doze: self.m7_lpuart2_ipg_doze(),
            m7_lpuart3_ipg_doze: self.m7_lpuart3_ipg_doze(),
            m7_lpuart4_ipg_doze: self.m7_lpuart4_ipg_doze(),
            m7_lpuart5_ipg_doze: self.m7_lpuart5_ipg_doze(),
            m7_lpuart6_ipg_doze: self.m7_lpuart6_ipg_doze(),
            m7_lpuart7_ipg_doze: self.m7_lpuart7_ipg_doze(),
            m7_lpuart8_ipg_doze: self.m7_lpuart8_ipg_doze(),
            m7_lpuart9_ipg_doze: self.m7_lpuart9_ipg_doze(),
            m7_lpuart10_ipg_doze: self.m7_lpuart10_ipg_doze(),
            m7_lpuart11_ipg_doze: self.m7_lpuart11_ipg_doze(),
            m7_lpuart12_ipg_doze: self.m7_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14Set(pub u32);
impl GprShared14Set {
    #[doc = "m7_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared14Set {
    #[inline(always)]
    fn default() -> GprShared14Set {
        GprShared14Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14Set")
            .field("m7_adc1_ipg_doze", &self.m7_adc1_ipg_doze())
            .field("m7_adc2_ipg_doze", &self.m7_adc2_ipg_doze())
            .field("m7_flexspi1_ipg_doze", &self.m7_flexspi1_ipg_doze())
            .field("m7_flexspi2_ipg_doze", &self.m7_flexspi2_ipg_doze())
            .field("m7_flexio1_ipg_doze", &self.m7_flexio1_ipg_doze())
            .field("m7_flexio2_ipg_doze", &self.m7_flexio2_ipg_doze())
            .field("m7_lpit1_ipg_doze", &self.m7_lpit1_ipg_doze())
            .field("m7_lpit2_ipg_doze", &self.m7_lpit2_ipg_doze())
            .field("m7_lpit3_ipg_doze", &self.m7_lpit3_ipg_doze())
            .field("m7_tpm1_ipg_doze", &self.m7_tpm1_ipg_doze())
            .field("m7_tpm2_ipg_doze", &self.m7_tpm2_ipg_doze())
            .field("m7_tpm3_ipg_doze", &self.m7_tpm3_ipg_doze())
            .field("m7_tpm4_ipg_doze", &self.m7_tpm4_ipg_doze())
            .field("m7_tpm5_ipg_doze", &self.m7_tpm5_ipg_doze())
            .field("m7_tpm6_ipg_doze", &self.m7_tpm6_ipg_doze())
            .field("m7_gpt1_ipg_doze", &self.m7_gpt1_ipg_doze())
            .field("m7_gpt2_ipg_doze", &self.m7_gpt2_ipg_doze())
            .field("m7_can1_ipg_doze", &self.m7_can1_ipg_doze())
            .field("m7_can2_ipg_doze", &self.m7_can2_ipg_doze())
            .field("m7_can3_ipg_doze", &self.m7_can3_ipg_doze())
            .field("m7_lpuart1_ipg_doze", &self.m7_lpuart1_ipg_doze())
            .field("m7_lpuart2_ipg_doze", &self.m7_lpuart2_ipg_doze())
            .field("m7_lpuart3_ipg_doze", &self.m7_lpuart3_ipg_doze())
            .field("m7_lpuart4_ipg_doze", &self.m7_lpuart4_ipg_doze())
            .field("m7_lpuart5_ipg_doze", &self.m7_lpuart5_ipg_doze())
            .field("m7_lpuart6_ipg_doze", &self.m7_lpuart6_ipg_doze())
            .field("m7_lpuart7_ipg_doze", &self.m7_lpuart7_ipg_doze())
            .field("m7_lpuart8_ipg_doze", &self.m7_lpuart8_ipg_doze())
            .field("m7_lpuart9_ipg_doze", &self.m7_lpuart9_ipg_doze())
            .field("m7_lpuart10_ipg_doze", &self.m7_lpuart10_ipg_doze())
            .field("m7_lpuart11_ipg_doze", &self.m7_lpuart11_ipg_doze())
            .field("m7_lpuart12_ipg_doze", &self.m7_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14Set {
            m7_adc1_ipg_doze: bool,
            m7_adc2_ipg_doze: bool,
            m7_flexspi1_ipg_doze: bool,
            m7_flexspi2_ipg_doze: bool,
            m7_flexio1_ipg_doze: bool,
            m7_flexio2_ipg_doze: bool,
            m7_lpit1_ipg_doze: bool,
            m7_lpit2_ipg_doze: bool,
            m7_lpit3_ipg_doze: bool,
            m7_tpm1_ipg_doze: bool,
            m7_tpm2_ipg_doze: bool,
            m7_tpm3_ipg_doze: bool,
            m7_tpm4_ipg_doze: bool,
            m7_tpm5_ipg_doze: bool,
            m7_tpm6_ipg_doze: bool,
            m7_gpt1_ipg_doze: bool,
            m7_gpt2_ipg_doze: bool,
            m7_can1_ipg_doze: bool,
            m7_can2_ipg_doze: bool,
            m7_can3_ipg_doze: bool,
            m7_lpuart1_ipg_doze: bool,
            m7_lpuart2_ipg_doze: bool,
            m7_lpuart3_ipg_doze: bool,
            m7_lpuart4_ipg_doze: bool,
            m7_lpuart5_ipg_doze: bool,
            m7_lpuart6_ipg_doze: bool,
            m7_lpuart7_ipg_doze: bool,
            m7_lpuart8_ipg_doze: bool,
            m7_lpuart9_ipg_doze: bool,
            m7_lpuart10_ipg_doze: bool,
            m7_lpuart11_ipg_doze: bool,
            m7_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared14Set {
            m7_adc1_ipg_doze: self.m7_adc1_ipg_doze(),
            m7_adc2_ipg_doze: self.m7_adc2_ipg_doze(),
            m7_flexspi1_ipg_doze: self.m7_flexspi1_ipg_doze(),
            m7_flexspi2_ipg_doze: self.m7_flexspi2_ipg_doze(),
            m7_flexio1_ipg_doze: self.m7_flexio1_ipg_doze(),
            m7_flexio2_ipg_doze: self.m7_flexio2_ipg_doze(),
            m7_lpit1_ipg_doze: self.m7_lpit1_ipg_doze(),
            m7_lpit2_ipg_doze: self.m7_lpit2_ipg_doze(),
            m7_lpit3_ipg_doze: self.m7_lpit3_ipg_doze(),
            m7_tpm1_ipg_doze: self.m7_tpm1_ipg_doze(),
            m7_tpm2_ipg_doze: self.m7_tpm2_ipg_doze(),
            m7_tpm3_ipg_doze: self.m7_tpm3_ipg_doze(),
            m7_tpm4_ipg_doze: self.m7_tpm4_ipg_doze(),
            m7_tpm5_ipg_doze: self.m7_tpm5_ipg_doze(),
            m7_tpm6_ipg_doze: self.m7_tpm6_ipg_doze(),
            m7_gpt1_ipg_doze: self.m7_gpt1_ipg_doze(),
            m7_gpt2_ipg_doze: self.m7_gpt2_ipg_doze(),
            m7_can1_ipg_doze: self.m7_can1_ipg_doze(),
            m7_can2_ipg_doze: self.m7_can2_ipg_doze(),
            m7_can3_ipg_doze: self.m7_can3_ipg_doze(),
            m7_lpuart1_ipg_doze: self.m7_lpuart1_ipg_doze(),
            m7_lpuart2_ipg_doze: self.m7_lpuart2_ipg_doze(),
            m7_lpuart3_ipg_doze: self.m7_lpuart3_ipg_doze(),
            m7_lpuart4_ipg_doze: self.m7_lpuart4_ipg_doze(),
            m7_lpuart5_ipg_doze: self.m7_lpuart5_ipg_doze(),
            m7_lpuart6_ipg_doze: self.m7_lpuart6_ipg_doze(),
            m7_lpuart7_ipg_doze: self.m7_lpuart7_ipg_doze(),
            m7_lpuart8_ipg_doze: self.m7_lpuart8_ipg_doze(),
            m7_lpuart9_ipg_doze: self.m7_lpuart9_ipg_doze(),
            m7_lpuart10_ipg_doze: self.m7_lpuart10_ipg_doze(),
            m7_lpuart11_ipg_doze: self.m7_lpuart11_ipg_doze(),
            m7_lpuart12_ipg_doze: self.m7_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared14Tog(pub u32);
impl GprShared14Tog {
    #[doc = "m7_adc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_adc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_adc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_adc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_flexio2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_flexio2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_flexio2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpit3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpit3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpit3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_tpm6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_tpm6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_tpm6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_gpt2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_gpt2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_gpt2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_can1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_can2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_can3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_can3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_can3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_can3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart7_ipg_doze(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart7_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart7_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart8_ipg_doze(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart8_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart8_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart9_ipg_doze(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart9_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart9_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart10_ipg_doze(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart10_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart10_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart11_ipg_doze(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart11_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart11_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpuart12_ipg_doze(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpuart12_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpuart12_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared14Tog {
    #[inline(always)]
    fn default() -> GprShared14Tog {
        GprShared14Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared14Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared14Tog")
            .field("m7_adc1_ipg_doze", &self.m7_adc1_ipg_doze())
            .field("m7_adc2_ipg_doze", &self.m7_adc2_ipg_doze())
            .field("m7_flexspi1_ipg_doze", &self.m7_flexspi1_ipg_doze())
            .field("m7_flexspi2_ipg_doze", &self.m7_flexspi2_ipg_doze())
            .field("m7_flexio1_ipg_doze", &self.m7_flexio1_ipg_doze())
            .field("m7_flexio2_ipg_doze", &self.m7_flexio2_ipg_doze())
            .field("m7_lpit1_ipg_doze", &self.m7_lpit1_ipg_doze())
            .field("m7_lpit2_ipg_doze", &self.m7_lpit2_ipg_doze())
            .field("m7_lpit3_ipg_doze", &self.m7_lpit3_ipg_doze())
            .field("m7_tpm1_ipg_doze", &self.m7_tpm1_ipg_doze())
            .field("m7_tpm2_ipg_doze", &self.m7_tpm2_ipg_doze())
            .field("m7_tpm3_ipg_doze", &self.m7_tpm3_ipg_doze())
            .field("m7_tpm4_ipg_doze", &self.m7_tpm4_ipg_doze())
            .field("m7_tpm5_ipg_doze", &self.m7_tpm5_ipg_doze())
            .field("m7_tpm6_ipg_doze", &self.m7_tpm6_ipg_doze())
            .field("m7_gpt1_ipg_doze", &self.m7_gpt1_ipg_doze())
            .field("m7_gpt2_ipg_doze", &self.m7_gpt2_ipg_doze())
            .field("m7_can1_ipg_doze", &self.m7_can1_ipg_doze())
            .field("m7_can2_ipg_doze", &self.m7_can2_ipg_doze())
            .field("m7_can3_ipg_doze", &self.m7_can3_ipg_doze())
            .field("m7_lpuart1_ipg_doze", &self.m7_lpuart1_ipg_doze())
            .field("m7_lpuart2_ipg_doze", &self.m7_lpuart2_ipg_doze())
            .field("m7_lpuart3_ipg_doze", &self.m7_lpuart3_ipg_doze())
            .field("m7_lpuart4_ipg_doze", &self.m7_lpuart4_ipg_doze())
            .field("m7_lpuart5_ipg_doze", &self.m7_lpuart5_ipg_doze())
            .field("m7_lpuart6_ipg_doze", &self.m7_lpuart6_ipg_doze())
            .field("m7_lpuart7_ipg_doze", &self.m7_lpuart7_ipg_doze())
            .field("m7_lpuart8_ipg_doze", &self.m7_lpuart8_ipg_doze())
            .field("m7_lpuart9_ipg_doze", &self.m7_lpuart9_ipg_doze())
            .field("m7_lpuart10_ipg_doze", &self.m7_lpuart10_ipg_doze())
            .field("m7_lpuart11_ipg_doze", &self.m7_lpuart11_ipg_doze())
            .field("m7_lpuart12_ipg_doze", &self.m7_lpuart12_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared14Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared14Tog {
            m7_adc1_ipg_doze: bool,
            m7_adc2_ipg_doze: bool,
            m7_flexspi1_ipg_doze: bool,
            m7_flexspi2_ipg_doze: bool,
            m7_flexio1_ipg_doze: bool,
            m7_flexio2_ipg_doze: bool,
            m7_lpit1_ipg_doze: bool,
            m7_lpit2_ipg_doze: bool,
            m7_lpit3_ipg_doze: bool,
            m7_tpm1_ipg_doze: bool,
            m7_tpm2_ipg_doze: bool,
            m7_tpm3_ipg_doze: bool,
            m7_tpm4_ipg_doze: bool,
            m7_tpm5_ipg_doze: bool,
            m7_tpm6_ipg_doze: bool,
            m7_gpt1_ipg_doze: bool,
            m7_gpt2_ipg_doze: bool,
            m7_can1_ipg_doze: bool,
            m7_can2_ipg_doze: bool,
            m7_can3_ipg_doze: bool,
            m7_lpuart1_ipg_doze: bool,
            m7_lpuart2_ipg_doze: bool,
            m7_lpuart3_ipg_doze: bool,
            m7_lpuart4_ipg_doze: bool,
            m7_lpuart5_ipg_doze: bool,
            m7_lpuart6_ipg_doze: bool,
            m7_lpuart7_ipg_doze: bool,
            m7_lpuart8_ipg_doze: bool,
            m7_lpuart9_ipg_doze: bool,
            m7_lpuart10_ipg_doze: bool,
            m7_lpuart11_ipg_doze: bool,
            m7_lpuart12_ipg_doze: bool,
        }
        let proxy = GprShared14Tog {
            m7_adc1_ipg_doze: self.m7_adc1_ipg_doze(),
            m7_adc2_ipg_doze: self.m7_adc2_ipg_doze(),
            m7_flexspi1_ipg_doze: self.m7_flexspi1_ipg_doze(),
            m7_flexspi2_ipg_doze: self.m7_flexspi2_ipg_doze(),
            m7_flexio1_ipg_doze: self.m7_flexio1_ipg_doze(),
            m7_flexio2_ipg_doze: self.m7_flexio2_ipg_doze(),
            m7_lpit1_ipg_doze: self.m7_lpit1_ipg_doze(),
            m7_lpit2_ipg_doze: self.m7_lpit2_ipg_doze(),
            m7_lpit3_ipg_doze: self.m7_lpit3_ipg_doze(),
            m7_tpm1_ipg_doze: self.m7_tpm1_ipg_doze(),
            m7_tpm2_ipg_doze: self.m7_tpm2_ipg_doze(),
            m7_tpm3_ipg_doze: self.m7_tpm3_ipg_doze(),
            m7_tpm4_ipg_doze: self.m7_tpm4_ipg_doze(),
            m7_tpm5_ipg_doze: self.m7_tpm5_ipg_doze(),
            m7_tpm6_ipg_doze: self.m7_tpm6_ipg_doze(),
            m7_gpt1_ipg_doze: self.m7_gpt1_ipg_doze(),
            m7_gpt2_ipg_doze: self.m7_gpt2_ipg_doze(),
            m7_can1_ipg_doze: self.m7_can1_ipg_doze(),
            m7_can2_ipg_doze: self.m7_can2_ipg_doze(),
            m7_can3_ipg_doze: self.m7_can3_ipg_doze(),
            m7_lpuart1_ipg_doze: self.m7_lpuart1_ipg_doze(),
            m7_lpuart2_ipg_doze: self.m7_lpuart2_ipg_doze(),
            m7_lpuart3_ipg_doze: self.m7_lpuart3_ipg_doze(),
            m7_lpuart4_ipg_doze: self.m7_lpuart4_ipg_doze(),
            m7_lpuart5_ipg_doze: self.m7_lpuart5_ipg_doze(),
            m7_lpuart6_ipg_doze: self.m7_lpuart6_ipg_doze(),
            m7_lpuart7_ipg_doze: self.m7_lpuart7_ipg_doze(),
            m7_lpuart8_ipg_doze: self.m7_lpuart8_ipg_doze(),
            m7_lpuart9_ipg_doze: self.m7_lpuart9_ipg_doze(),
            m7_lpuart10_ipg_doze: self.m7_lpuart10_ipg_doze(),
            m7_lpuart11_ipg_doze: self.m7_lpuart11_ipg_doze(),
            m7_lpuart12_ipg_doze: self.m7_lpuart12_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15(pub u32);
impl GprShared15 {
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared15 {
    #[inline(always)]
    fn default() -> GprShared15 {
        GprShared15(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15")
            .field("m7_lpi2c1_ipg_doze", &self.m7_lpi2c1_ipg_doze())
            .field("m7_lpi2c2_ipg_doze", &self.m7_lpi2c2_ipg_doze())
            .field("m7_lpi2c3_ipg_doze", &self.m7_lpi2c3_ipg_doze())
            .field("m7_lpi2c4_ipg_doze", &self.m7_lpi2c4_ipg_doze())
            .field("m7_lpi2c5_ipg_doze", &self.m7_lpi2c5_ipg_doze())
            .field("m7_lpi2c6_ipg_doze", &self.m7_lpi2c6_ipg_doze())
            .field("m7_lpspi1_ipg_doze", &self.m7_lpspi1_ipg_doze())
            .field("m7_lpspi2_ipg_doze", &self.m7_lpspi2_ipg_doze())
            .field("m7_lpspi3_ipg_doze", &self.m7_lpspi3_ipg_doze())
            .field("m7_lpspi4_ipg_doze", &self.m7_lpspi4_ipg_doze())
            .field("m7_lpspi5_ipg_doze", &self.m7_lpspi5_ipg_doze())
            .field("m7_lpspi6_ipg_doze", &self.m7_lpspi6_ipg_doze())
            .field("m7_sinc1_ipg_doze", &self.m7_sinc1_ipg_doze())
            .field("m7_sinc2_ipg_doze", &self.m7_sinc2_ipg_doze())
            .field("m7_sinc3_ipg_doze", &self.m7_sinc3_ipg_doze())
            .field("m7_mic_ipg_doze", &self.m7_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15 {
            m7_lpi2c1_ipg_doze: bool,
            m7_lpi2c2_ipg_doze: bool,
            m7_lpi2c3_ipg_doze: bool,
            m7_lpi2c4_ipg_doze: bool,
            m7_lpi2c5_ipg_doze: bool,
            m7_lpi2c6_ipg_doze: bool,
            m7_lpspi1_ipg_doze: bool,
            m7_lpspi2_ipg_doze: bool,
            m7_lpspi3_ipg_doze: bool,
            m7_lpspi4_ipg_doze: bool,
            m7_lpspi5_ipg_doze: bool,
            m7_lpspi6_ipg_doze: bool,
            m7_sinc1_ipg_doze: bool,
            m7_sinc2_ipg_doze: bool,
            m7_sinc3_ipg_doze: bool,
            m7_mic_ipg_doze: bool,
        }
        let proxy = GprShared15 {
            m7_lpi2c1_ipg_doze: self.m7_lpi2c1_ipg_doze(),
            m7_lpi2c2_ipg_doze: self.m7_lpi2c2_ipg_doze(),
            m7_lpi2c3_ipg_doze: self.m7_lpi2c3_ipg_doze(),
            m7_lpi2c4_ipg_doze: self.m7_lpi2c4_ipg_doze(),
            m7_lpi2c5_ipg_doze: self.m7_lpi2c5_ipg_doze(),
            m7_lpi2c6_ipg_doze: self.m7_lpi2c6_ipg_doze(),
            m7_lpspi1_ipg_doze: self.m7_lpspi1_ipg_doze(),
            m7_lpspi2_ipg_doze: self.m7_lpspi2_ipg_doze(),
            m7_lpspi3_ipg_doze: self.m7_lpspi3_ipg_doze(),
            m7_lpspi4_ipg_doze: self.m7_lpspi4_ipg_doze(),
            m7_lpspi5_ipg_doze: self.m7_lpspi5_ipg_doze(),
            m7_lpspi6_ipg_doze: self.m7_lpspi6_ipg_doze(),
            m7_sinc1_ipg_doze: self.m7_sinc1_ipg_doze(),
            m7_sinc2_ipg_doze: self.m7_sinc2_ipg_doze(),
            m7_sinc3_ipg_doze: self.m7_sinc3_ipg_doze(),
            m7_mic_ipg_doze: self.m7_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15Authen(pub u32);
impl GprShared15Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared15AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared15AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared15AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared15AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared15AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared15AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared15Authen {
    #[inline(always)]
    fn default() -> GprShared15Authen {
        GprShared15Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15Authen {
            tz_user: super::vals::GprShared15AuthenTzUser,
            tz_ns: super::vals::GprShared15AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared15Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15AuthenClr(pub u32);
impl GprShared15AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared15AuthenClr {
    #[inline(always)]
    fn default() -> GprShared15AuthenClr {
        GprShared15AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared15AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15AuthenSet(pub u32);
impl GprShared15AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared15AuthenSet {
    #[inline(always)]
    fn default() -> GprShared15AuthenSet {
        GprShared15AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared15AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15AuthenTog(pub u32);
impl GprShared15AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared15AuthenTog {
    #[inline(always)]
    fn default() -> GprShared15AuthenTog {
        GprShared15AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared15AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15Clr(pub u32);
impl GprShared15Clr {
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared15Clr {
    #[inline(always)]
    fn default() -> GprShared15Clr {
        GprShared15Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15Clr")
            .field("m7_lpi2c1_ipg_doze", &self.m7_lpi2c1_ipg_doze())
            .field("m7_lpi2c2_ipg_doze", &self.m7_lpi2c2_ipg_doze())
            .field("m7_lpi2c3_ipg_doze", &self.m7_lpi2c3_ipg_doze())
            .field("m7_lpi2c4_ipg_doze", &self.m7_lpi2c4_ipg_doze())
            .field("m7_lpi2c5_ipg_doze", &self.m7_lpi2c5_ipg_doze())
            .field("m7_lpi2c6_ipg_doze", &self.m7_lpi2c6_ipg_doze())
            .field("m7_lpspi1_ipg_doze", &self.m7_lpspi1_ipg_doze())
            .field("m7_lpspi2_ipg_doze", &self.m7_lpspi2_ipg_doze())
            .field("m7_lpspi3_ipg_doze", &self.m7_lpspi3_ipg_doze())
            .field("m7_lpspi4_ipg_doze", &self.m7_lpspi4_ipg_doze())
            .field("m7_lpspi5_ipg_doze", &self.m7_lpspi5_ipg_doze())
            .field("m7_lpspi6_ipg_doze", &self.m7_lpspi6_ipg_doze())
            .field("m7_sinc1_ipg_doze", &self.m7_sinc1_ipg_doze())
            .field("m7_sinc2_ipg_doze", &self.m7_sinc2_ipg_doze())
            .field("m7_sinc3_ipg_doze", &self.m7_sinc3_ipg_doze())
            .field("m7_mic_ipg_doze", &self.m7_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15Clr {
            m7_lpi2c1_ipg_doze: bool,
            m7_lpi2c2_ipg_doze: bool,
            m7_lpi2c3_ipg_doze: bool,
            m7_lpi2c4_ipg_doze: bool,
            m7_lpi2c5_ipg_doze: bool,
            m7_lpi2c6_ipg_doze: bool,
            m7_lpspi1_ipg_doze: bool,
            m7_lpspi2_ipg_doze: bool,
            m7_lpspi3_ipg_doze: bool,
            m7_lpspi4_ipg_doze: bool,
            m7_lpspi5_ipg_doze: bool,
            m7_lpspi6_ipg_doze: bool,
            m7_sinc1_ipg_doze: bool,
            m7_sinc2_ipg_doze: bool,
            m7_sinc3_ipg_doze: bool,
            m7_mic_ipg_doze: bool,
        }
        let proxy = GprShared15Clr {
            m7_lpi2c1_ipg_doze: self.m7_lpi2c1_ipg_doze(),
            m7_lpi2c2_ipg_doze: self.m7_lpi2c2_ipg_doze(),
            m7_lpi2c3_ipg_doze: self.m7_lpi2c3_ipg_doze(),
            m7_lpi2c4_ipg_doze: self.m7_lpi2c4_ipg_doze(),
            m7_lpi2c5_ipg_doze: self.m7_lpi2c5_ipg_doze(),
            m7_lpi2c6_ipg_doze: self.m7_lpi2c6_ipg_doze(),
            m7_lpspi1_ipg_doze: self.m7_lpspi1_ipg_doze(),
            m7_lpspi2_ipg_doze: self.m7_lpspi2_ipg_doze(),
            m7_lpspi3_ipg_doze: self.m7_lpspi3_ipg_doze(),
            m7_lpspi4_ipg_doze: self.m7_lpspi4_ipg_doze(),
            m7_lpspi5_ipg_doze: self.m7_lpspi5_ipg_doze(),
            m7_lpspi6_ipg_doze: self.m7_lpspi6_ipg_doze(),
            m7_sinc1_ipg_doze: self.m7_sinc1_ipg_doze(),
            m7_sinc2_ipg_doze: self.m7_sinc2_ipg_doze(),
            m7_sinc3_ipg_doze: self.m7_sinc3_ipg_doze(),
            m7_mic_ipg_doze: self.m7_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15Set(pub u32);
impl GprShared15Set {
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared15Set {
    #[inline(always)]
    fn default() -> GprShared15Set {
        GprShared15Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15Set")
            .field("m7_lpi2c1_ipg_doze", &self.m7_lpi2c1_ipg_doze())
            .field("m7_lpi2c2_ipg_doze", &self.m7_lpi2c2_ipg_doze())
            .field("m7_lpi2c3_ipg_doze", &self.m7_lpi2c3_ipg_doze())
            .field("m7_lpi2c4_ipg_doze", &self.m7_lpi2c4_ipg_doze())
            .field("m7_lpi2c5_ipg_doze", &self.m7_lpi2c5_ipg_doze())
            .field("m7_lpi2c6_ipg_doze", &self.m7_lpi2c6_ipg_doze())
            .field("m7_lpspi1_ipg_doze", &self.m7_lpspi1_ipg_doze())
            .field("m7_lpspi2_ipg_doze", &self.m7_lpspi2_ipg_doze())
            .field("m7_lpspi3_ipg_doze", &self.m7_lpspi3_ipg_doze())
            .field("m7_lpspi4_ipg_doze", &self.m7_lpspi4_ipg_doze())
            .field("m7_lpspi5_ipg_doze", &self.m7_lpspi5_ipg_doze())
            .field("m7_lpspi6_ipg_doze", &self.m7_lpspi6_ipg_doze())
            .field("m7_sinc1_ipg_doze", &self.m7_sinc1_ipg_doze())
            .field("m7_sinc2_ipg_doze", &self.m7_sinc2_ipg_doze())
            .field("m7_sinc3_ipg_doze", &self.m7_sinc3_ipg_doze())
            .field("m7_mic_ipg_doze", &self.m7_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15Set {
            m7_lpi2c1_ipg_doze: bool,
            m7_lpi2c2_ipg_doze: bool,
            m7_lpi2c3_ipg_doze: bool,
            m7_lpi2c4_ipg_doze: bool,
            m7_lpi2c5_ipg_doze: bool,
            m7_lpi2c6_ipg_doze: bool,
            m7_lpspi1_ipg_doze: bool,
            m7_lpspi2_ipg_doze: bool,
            m7_lpspi3_ipg_doze: bool,
            m7_lpspi4_ipg_doze: bool,
            m7_lpspi5_ipg_doze: bool,
            m7_lpspi6_ipg_doze: bool,
            m7_sinc1_ipg_doze: bool,
            m7_sinc2_ipg_doze: bool,
            m7_sinc3_ipg_doze: bool,
            m7_mic_ipg_doze: bool,
        }
        let proxy = GprShared15Set {
            m7_lpi2c1_ipg_doze: self.m7_lpi2c1_ipg_doze(),
            m7_lpi2c2_ipg_doze: self.m7_lpi2c2_ipg_doze(),
            m7_lpi2c3_ipg_doze: self.m7_lpi2c3_ipg_doze(),
            m7_lpi2c4_ipg_doze: self.m7_lpi2c4_ipg_doze(),
            m7_lpi2c5_ipg_doze: self.m7_lpi2c5_ipg_doze(),
            m7_lpi2c6_ipg_doze: self.m7_lpi2c6_ipg_doze(),
            m7_lpspi1_ipg_doze: self.m7_lpspi1_ipg_doze(),
            m7_lpspi2_ipg_doze: self.m7_lpspi2_ipg_doze(),
            m7_lpspi3_ipg_doze: self.m7_lpspi3_ipg_doze(),
            m7_lpspi4_ipg_doze: self.m7_lpspi4_ipg_doze(),
            m7_lpspi5_ipg_doze: self.m7_lpspi5_ipg_doze(),
            m7_lpspi6_ipg_doze: self.m7_lpspi6_ipg_doze(),
            m7_sinc1_ipg_doze: self.m7_sinc1_ipg_doze(),
            m7_sinc2_ipg_doze: self.m7_sinc2_ipg_doze(),
            m7_sinc3_ipg_doze: self.m7_sinc3_ipg_doze(),
            m7_mic_ipg_doze: self.m7_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared15Tog(pub u32);
impl GprShared15Tog {
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpi2c6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpi2c6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpi2c6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi4_ipg_doze(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi4_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi4_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi5_ipg_doze(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi5_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi5_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_lpspi6_ipg_doze(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_lpspi6_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_lpspi6_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc1_ipg_doze(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc1_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc1_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc2_ipg_doze(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc2_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc2_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_sinc3_ipg_doze(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_sinc3_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_sinc3_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mic_ipg_doze"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mic_ipg_doze(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mic_ipg_doze"]
    #[inline(always)]
    pub const fn set_m7_mic_ipg_doze(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
}
impl Default for GprShared15Tog {
    #[inline(always)]
    fn default() -> GprShared15Tog {
        GprShared15Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared15Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared15Tog")
            .field("m7_lpi2c1_ipg_doze", &self.m7_lpi2c1_ipg_doze())
            .field("m7_lpi2c2_ipg_doze", &self.m7_lpi2c2_ipg_doze())
            .field("m7_lpi2c3_ipg_doze", &self.m7_lpi2c3_ipg_doze())
            .field("m7_lpi2c4_ipg_doze", &self.m7_lpi2c4_ipg_doze())
            .field("m7_lpi2c5_ipg_doze", &self.m7_lpi2c5_ipg_doze())
            .field("m7_lpi2c6_ipg_doze", &self.m7_lpi2c6_ipg_doze())
            .field("m7_lpspi1_ipg_doze", &self.m7_lpspi1_ipg_doze())
            .field("m7_lpspi2_ipg_doze", &self.m7_lpspi2_ipg_doze())
            .field("m7_lpspi3_ipg_doze", &self.m7_lpspi3_ipg_doze())
            .field("m7_lpspi4_ipg_doze", &self.m7_lpspi4_ipg_doze())
            .field("m7_lpspi5_ipg_doze", &self.m7_lpspi5_ipg_doze())
            .field("m7_lpspi6_ipg_doze", &self.m7_lpspi6_ipg_doze())
            .field("m7_sinc1_ipg_doze", &self.m7_sinc1_ipg_doze())
            .field("m7_sinc2_ipg_doze", &self.m7_sinc2_ipg_doze())
            .field("m7_sinc3_ipg_doze", &self.m7_sinc3_ipg_doze())
            .field("m7_mic_ipg_doze", &self.m7_mic_ipg_doze())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared15Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared15Tog {
            m7_lpi2c1_ipg_doze: bool,
            m7_lpi2c2_ipg_doze: bool,
            m7_lpi2c3_ipg_doze: bool,
            m7_lpi2c4_ipg_doze: bool,
            m7_lpi2c5_ipg_doze: bool,
            m7_lpi2c6_ipg_doze: bool,
            m7_lpspi1_ipg_doze: bool,
            m7_lpspi2_ipg_doze: bool,
            m7_lpspi3_ipg_doze: bool,
            m7_lpspi4_ipg_doze: bool,
            m7_lpspi5_ipg_doze: bool,
            m7_lpspi6_ipg_doze: bool,
            m7_sinc1_ipg_doze: bool,
            m7_sinc2_ipg_doze: bool,
            m7_sinc3_ipg_doze: bool,
            m7_mic_ipg_doze: bool,
        }
        let proxy = GprShared15Tog {
            m7_lpi2c1_ipg_doze: self.m7_lpi2c1_ipg_doze(),
            m7_lpi2c2_ipg_doze: self.m7_lpi2c2_ipg_doze(),
            m7_lpi2c3_ipg_doze: self.m7_lpi2c3_ipg_doze(),
            m7_lpi2c4_ipg_doze: self.m7_lpi2c4_ipg_doze(),
            m7_lpi2c5_ipg_doze: self.m7_lpi2c5_ipg_doze(),
            m7_lpi2c6_ipg_doze: self.m7_lpi2c6_ipg_doze(),
            m7_lpspi1_ipg_doze: self.m7_lpspi1_ipg_doze(),
            m7_lpspi2_ipg_doze: self.m7_lpspi2_ipg_doze(),
            m7_lpspi3_ipg_doze: self.m7_lpspi3_ipg_doze(),
            m7_lpspi4_ipg_doze: self.m7_lpspi4_ipg_doze(),
            m7_lpspi5_ipg_doze: self.m7_lpspi5_ipg_doze(),
            m7_lpspi6_ipg_doze: self.m7_lpspi6_ipg_doze(),
            m7_sinc1_ipg_doze: self.m7_sinc1_ipg_doze(),
            m7_sinc2_ipg_doze: self.m7_sinc2_ipg_doze(),
            m7_sinc3_ipg_doze: self.m7_sinc3_ipg_doze(),
            m7_mic_ipg_doze: self.m7_mic_ipg_doze(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared1Authen(pub u32);
impl GprShared1Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared1AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared1AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared1AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared1AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared1AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared1AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared1Authen {
    #[inline(always)]
    fn default() -> GprShared1Authen {
        GprShared1Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared1Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared1Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared1Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared1Authen {
            tz_user: super::vals::GprShared1AuthenTzUser,
            tz_ns: super::vals::GprShared1AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared1Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared1AuthenClr(pub u32);
impl GprShared1AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared1AuthenClr {
    #[inline(always)]
    fn default() -> GprShared1AuthenClr {
        GprShared1AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared1AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared1AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared1AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared1AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared1AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared1AuthenSet(pub u32);
impl GprShared1AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared1AuthenSet {
    #[inline(always)]
    fn default() -> GprShared1AuthenSet {
        GprShared1AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared1AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared1AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared1AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared1AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared1AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared1AuthenTog(pub u32);
impl GprShared1AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared1AuthenTog {
    #[inline(always)]
    fn default() -> GprShared1AuthenTog {
        GprShared1AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared1AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared1AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared1AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared1AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared1AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2(pub u32);
impl GprShared2 {
    #[doc = "m33_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm7"]
    #[inline(always)]
    pub const fn set_m33_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm33"]
    #[inline(always)]
    pub const fn set_m33_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma3"]
    #[inline(always)]
    pub const fn set_m33_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma4"]
    #[inline(always)]
    pub const fn set_m33_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_netc"]
    #[inline(always)]
    pub const fn set_m33_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m33_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc1"]
    #[inline(always)]
    pub const fn set_m33_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc2"]
    #[inline(always)]
    pub const fn set_m33_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_trdc"]
    #[inline(always)]
    pub const fn set_m33_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_semc"]
    #[inline(always)]
    pub const fn set_m33_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_iee"]
    #[inline(always)]
    pub const fn set_m33_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared2 {
    #[inline(always)]
    fn default() -> GprShared2 {
        GprShared2(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2")
            .field("m33_mask_cm7", &self.m33_mask_cm7())
            .field("m33_mask_cm33", &self.m33_mask_cm33())
            .field("m33_mask_edma3", &self.m33_mask_edma3())
            .field("m33_mask_edma4", &self.m33_mask_edma4())
            .field("m33_mask_netc", &self.m33_mask_netc())
            .field("m33_mask_sim_aon", &self.m33_mask_sim_aon())
            .field("m33_mask_adc1", &self.m33_mask_adc1())
            .field("m33_mask_adc2", &self.m33_mask_adc2())
            .field("m33_mask_flexspi1", &self.m33_mask_flexspi1())
            .field("m33_mask_flexspi2", &self.m33_mask_flexspi2())
            .field("m33_mask_trdc", &self.m33_mask_trdc())
            .field("m33_mask_semc", &self.m33_mask_semc())
            .field("m33_mask_iee", &self.m33_mask_iee())
            .field("m33_mask_gpio1", &self.m33_mask_gpio1())
            .field("m33_mask_gpio2", &self.m33_mask_gpio2())
            .field("m33_mask_gpio3", &self.m33_mask_gpio3())
            .field("m33_mask_gpio4", &self.m33_mask_gpio4())
            .field("m33_mask_gpio5", &self.m33_mask_gpio5())
            .field("m33_mask_gpio6", &self.m33_mask_gpio6())
            .field("m33_mask_flexio1", &self.m33_mask_flexio1())
            .field("m33_mask_flexio2", &self.m33_mask_flexio2())
            .field("m33_mask_lpit1", &self.m33_mask_lpit1())
            .field("m33_mask_lpit2", &self.m33_mask_lpit2())
            .field("m33_mask_lpit3", &self.m33_mask_lpit3())
            .field("m33_mask_tpm1", &self.m33_mask_tpm1())
            .field("m33_mask_tpm2", &self.m33_mask_tpm2())
            .field("m33_mask_tpm3", &self.m33_mask_tpm3())
            .field("m33_mask_tpm4", &self.m33_mask_tpm4())
            .field("m33_mask_tpm5", &self.m33_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2 {
            m33_mask_cm7: bool,
            m33_mask_cm33: bool,
            m33_mask_edma3: bool,
            m33_mask_edma4: bool,
            m33_mask_netc: bool,
            m33_mask_sim_aon: bool,
            m33_mask_adc1: bool,
            m33_mask_adc2: bool,
            m33_mask_flexspi1: bool,
            m33_mask_flexspi2: bool,
            m33_mask_trdc: bool,
            m33_mask_semc: bool,
            m33_mask_iee: bool,
            m33_mask_gpio1: bool,
            m33_mask_gpio2: bool,
            m33_mask_gpio3: bool,
            m33_mask_gpio4: bool,
            m33_mask_gpio5: bool,
            m33_mask_gpio6: bool,
            m33_mask_flexio1: bool,
            m33_mask_flexio2: bool,
            m33_mask_lpit1: bool,
            m33_mask_lpit2: bool,
            m33_mask_lpit3: bool,
            m33_mask_tpm1: bool,
            m33_mask_tpm2: bool,
            m33_mask_tpm3: bool,
            m33_mask_tpm4: bool,
            m33_mask_tpm5: bool,
        }
        let proxy = GprShared2 {
            m33_mask_cm7: self.m33_mask_cm7(),
            m33_mask_cm33: self.m33_mask_cm33(),
            m33_mask_edma3: self.m33_mask_edma3(),
            m33_mask_edma4: self.m33_mask_edma4(),
            m33_mask_netc: self.m33_mask_netc(),
            m33_mask_sim_aon: self.m33_mask_sim_aon(),
            m33_mask_adc1: self.m33_mask_adc1(),
            m33_mask_adc2: self.m33_mask_adc2(),
            m33_mask_flexspi1: self.m33_mask_flexspi1(),
            m33_mask_flexspi2: self.m33_mask_flexspi2(),
            m33_mask_trdc: self.m33_mask_trdc(),
            m33_mask_semc: self.m33_mask_semc(),
            m33_mask_iee: self.m33_mask_iee(),
            m33_mask_gpio1: self.m33_mask_gpio1(),
            m33_mask_gpio2: self.m33_mask_gpio2(),
            m33_mask_gpio3: self.m33_mask_gpio3(),
            m33_mask_gpio4: self.m33_mask_gpio4(),
            m33_mask_gpio5: self.m33_mask_gpio5(),
            m33_mask_gpio6: self.m33_mask_gpio6(),
            m33_mask_flexio1: self.m33_mask_flexio1(),
            m33_mask_flexio2: self.m33_mask_flexio2(),
            m33_mask_lpit1: self.m33_mask_lpit1(),
            m33_mask_lpit2: self.m33_mask_lpit2(),
            m33_mask_lpit3: self.m33_mask_lpit3(),
            m33_mask_tpm1: self.m33_mask_tpm1(),
            m33_mask_tpm2: self.m33_mask_tpm2(),
            m33_mask_tpm3: self.m33_mask_tpm3(),
            m33_mask_tpm4: self.m33_mask_tpm4(),
            m33_mask_tpm5: self.m33_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2Authen(pub u32);
impl GprShared2Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared2AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared2AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared2AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared2AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared2AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared2AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared2Authen {
    #[inline(always)]
    fn default() -> GprShared2Authen {
        GprShared2Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2Authen {
            tz_user: super::vals::GprShared2AuthenTzUser,
            tz_ns: super::vals::GprShared2AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared2Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2AuthenClr(pub u32);
impl GprShared2AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared2AuthenClr {
    #[inline(always)]
    fn default() -> GprShared2AuthenClr {
        GprShared2AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared2AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2AuthenSet(pub u32);
impl GprShared2AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared2AuthenSet {
    #[inline(always)]
    fn default() -> GprShared2AuthenSet {
        GprShared2AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared2AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2AuthenTog(pub u32);
impl GprShared2AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared2AuthenTog {
    #[inline(always)]
    fn default() -> GprShared2AuthenTog {
        GprShared2AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared2AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2Clr(pub u32);
impl GprShared2Clr {
    #[doc = "m33_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm7"]
    #[inline(always)]
    pub const fn set_m33_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm33"]
    #[inline(always)]
    pub const fn set_m33_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma3"]
    #[inline(always)]
    pub const fn set_m33_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma4"]
    #[inline(always)]
    pub const fn set_m33_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_netc"]
    #[inline(always)]
    pub const fn set_m33_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m33_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc1"]
    #[inline(always)]
    pub const fn set_m33_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc2"]
    #[inline(always)]
    pub const fn set_m33_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_trdc"]
    #[inline(always)]
    pub const fn set_m33_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_semc"]
    #[inline(always)]
    pub const fn set_m33_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_iee"]
    #[inline(always)]
    pub const fn set_m33_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared2Clr {
    #[inline(always)]
    fn default() -> GprShared2Clr {
        GprShared2Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2Clr")
            .field("m33_mask_cm7", &self.m33_mask_cm7())
            .field("m33_mask_cm33", &self.m33_mask_cm33())
            .field("m33_mask_edma3", &self.m33_mask_edma3())
            .field("m33_mask_edma4", &self.m33_mask_edma4())
            .field("m33_mask_netc", &self.m33_mask_netc())
            .field("m33_mask_sim_aon", &self.m33_mask_sim_aon())
            .field("m33_mask_adc1", &self.m33_mask_adc1())
            .field("m33_mask_adc2", &self.m33_mask_adc2())
            .field("m33_mask_flexspi1", &self.m33_mask_flexspi1())
            .field("m33_mask_flexspi2", &self.m33_mask_flexspi2())
            .field("m33_mask_trdc", &self.m33_mask_trdc())
            .field("m33_mask_semc", &self.m33_mask_semc())
            .field("m33_mask_iee", &self.m33_mask_iee())
            .field("m33_mask_gpio1", &self.m33_mask_gpio1())
            .field("m33_mask_gpio2", &self.m33_mask_gpio2())
            .field("m33_mask_gpio3", &self.m33_mask_gpio3())
            .field("m33_mask_gpio4", &self.m33_mask_gpio4())
            .field("m33_mask_gpio5", &self.m33_mask_gpio5())
            .field("m33_mask_gpio6", &self.m33_mask_gpio6())
            .field("m33_mask_flexio1", &self.m33_mask_flexio1())
            .field("m33_mask_flexio2", &self.m33_mask_flexio2())
            .field("m33_mask_lpit1", &self.m33_mask_lpit1())
            .field("m33_mask_lpit2", &self.m33_mask_lpit2())
            .field("m33_mask_lpit3", &self.m33_mask_lpit3())
            .field("m33_mask_tpm1", &self.m33_mask_tpm1())
            .field("m33_mask_tpm2", &self.m33_mask_tpm2())
            .field("m33_mask_tpm3", &self.m33_mask_tpm3())
            .field("m33_mask_tpm4", &self.m33_mask_tpm4())
            .field("m33_mask_tpm5", &self.m33_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2Clr {
            m33_mask_cm7: bool,
            m33_mask_cm33: bool,
            m33_mask_edma3: bool,
            m33_mask_edma4: bool,
            m33_mask_netc: bool,
            m33_mask_sim_aon: bool,
            m33_mask_adc1: bool,
            m33_mask_adc2: bool,
            m33_mask_flexspi1: bool,
            m33_mask_flexspi2: bool,
            m33_mask_trdc: bool,
            m33_mask_semc: bool,
            m33_mask_iee: bool,
            m33_mask_gpio1: bool,
            m33_mask_gpio2: bool,
            m33_mask_gpio3: bool,
            m33_mask_gpio4: bool,
            m33_mask_gpio5: bool,
            m33_mask_gpio6: bool,
            m33_mask_flexio1: bool,
            m33_mask_flexio2: bool,
            m33_mask_lpit1: bool,
            m33_mask_lpit2: bool,
            m33_mask_lpit3: bool,
            m33_mask_tpm1: bool,
            m33_mask_tpm2: bool,
            m33_mask_tpm3: bool,
            m33_mask_tpm4: bool,
            m33_mask_tpm5: bool,
        }
        let proxy = GprShared2Clr {
            m33_mask_cm7: self.m33_mask_cm7(),
            m33_mask_cm33: self.m33_mask_cm33(),
            m33_mask_edma3: self.m33_mask_edma3(),
            m33_mask_edma4: self.m33_mask_edma4(),
            m33_mask_netc: self.m33_mask_netc(),
            m33_mask_sim_aon: self.m33_mask_sim_aon(),
            m33_mask_adc1: self.m33_mask_adc1(),
            m33_mask_adc2: self.m33_mask_adc2(),
            m33_mask_flexspi1: self.m33_mask_flexspi1(),
            m33_mask_flexspi2: self.m33_mask_flexspi2(),
            m33_mask_trdc: self.m33_mask_trdc(),
            m33_mask_semc: self.m33_mask_semc(),
            m33_mask_iee: self.m33_mask_iee(),
            m33_mask_gpio1: self.m33_mask_gpio1(),
            m33_mask_gpio2: self.m33_mask_gpio2(),
            m33_mask_gpio3: self.m33_mask_gpio3(),
            m33_mask_gpio4: self.m33_mask_gpio4(),
            m33_mask_gpio5: self.m33_mask_gpio5(),
            m33_mask_gpio6: self.m33_mask_gpio6(),
            m33_mask_flexio1: self.m33_mask_flexio1(),
            m33_mask_flexio2: self.m33_mask_flexio2(),
            m33_mask_lpit1: self.m33_mask_lpit1(),
            m33_mask_lpit2: self.m33_mask_lpit2(),
            m33_mask_lpit3: self.m33_mask_lpit3(),
            m33_mask_tpm1: self.m33_mask_tpm1(),
            m33_mask_tpm2: self.m33_mask_tpm2(),
            m33_mask_tpm3: self.m33_mask_tpm3(),
            m33_mask_tpm4: self.m33_mask_tpm4(),
            m33_mask_tpm5: self.m33_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2Set(pub u32);
impl GprShared2Set {
    #[doc = "m33_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm7"]
    #[inline(always)]
    pub const fn set_m33_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm33"]
    #[inline(always)]
    pub const fn set_m33_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma3"]
    #[inline(always)]
    pub const fn set_m33_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma4"]
    #[inline(always)]
    pub const fn set_m33_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_netc"]
    #[inline(always)]
    pub const fn set_m33_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m33_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc1"]
    #[inline(always)]
    pub const fn set_m33_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc2"]
    #[inline(always)]
    pub const fn set_m33_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_trdc"]
    #[inline(always)]
    pub const fn set_m33_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_semc"]
    #[inline(always)]
    pub const fn set_m33_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_iee"]
    #[inline(always)]
    pub const fn set_m33_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared2Set {
    #[inline(always)]
    fn default() -> GprShared2Set {
        GprShared2Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2Set")
            .field("m33_mask_cm7", &self.m33_mask_cm7())
            .field("m33_mask_cm33", &self.m33_mask_cm33())
            .field("m33_mask_edma3", &self.m33_mask_edma3())
            .field("m33_mask_edma4", &self.m33_mask_edma4())
            .field("m33_mask_netc", &self.m33_mask_netc())
            .field("m33_mask_sim_aon", &self.m33_mask_sim_aon())
            .field("m33_mask_adc1", &self.m33_mask_adc1())
            .field("m33_mask_adc2", &self.m33_mask_adc2())
            .field("m33_mask_flexspi1", &self.m33_mask_flexspi1())
            .field("m33_mask_flexspi2", &self.m33_mask_flexspi2())
            .field("m33_mask_trdc", &self.m33_mask_trdc())
            .field("m33_mask_semc", &self.m33_mask_semc())
            .field("m33_mask_iee", &self.m33_mask_iee())
            .field("m33_mask_gpio1", &self.m33_mask_gpio1())
            .field("m33_mask_gpio2", &self.m33_mask_gpio2())
            .field("m33_mask_gpio3", &self.m33_mask_gpio3())
            .field("m33_mask_gpio4", &self.m33_mask_gpio4())
            .field("m33_mask_gpio5", &self.m33_mask_gpio5())
            .field("m33_mask_gpio6", &self.m33_mask_gpio6())
            .field("m33_mask_flexio1", &self.m33_mask_flexio1())
            .field("m33_mask_flexio2", &self.m33_mask_flexio2())
            .field("m33_mask_lpit1", &self.m33_mask_lpit1())
            .field("m33_mask_lpit2", &self.m33_mask_lpit2())
            .field("m33_mask_lpit3", &self.m33_mask_lpit3())
            .field("m33_mask_tpm1", &self.m33_mask_tpm1())
            .field("m33_mask_tpm2", &self.m33_mask_tpm2())
            .field("m33_mask_tpm3", &self.m33_mask_tpm3())
            .field("m33_mask_tpm4", &self.m33_mask_tpm4())
            .field("m33_mask_tpm5", &self.m33_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2Set {
            m33_mask_cm7: bool,
            m33_mask_cm33: bool,
            m33_mask_edma3: bool,
            m33_mask_edma4: bool,
            m33_mask_netc: bool,
            m33_mask_sim_aon: bool,
            m33_mask_adc1: bool,
            m33_mask_adc2: bool,
            m33_mask_flexspi1: bool,
            m33_mask_flexspi2: bool,
            m33_mask_trdc: bool,
            m33_mask_semc: bool,
            m33_mask_iee: bool,
            m33_mask_gpio1: bool,
            m33_mask_gpio2: bool,
            m33_mask_gpio3: bool,
            m33_mask_gpio4: bool,
            m33_mask_gpio5: bool,
            m33_mask_gpio6: bool,
            m33_mask_flexio1: bool,
            m33_mask_flexio2: bool,
            m33_mask_lpit1: bool,
            m33_mask_lpit2: bool,
            m33_mask_lpit3: bool,
            m33_mask_tpm1: bool,
            m33_mask_tpm2: bool,
            m33_mask_tpm3: bool,
            m33_mask_tpm4: bool,
            m33_mask_tpm5: bool,
        }
        let proxy = GprShared2Set {
            m33_mask_cm7: self.m33_mask_cm7(),
            m33_mask_cm33: self.m33_mask_cm33(),
            m33_mask_edma3: self.m33_mask_edma3(),
            m33_mask_edma4: self.m33_mask_edma4(),
            m33_mask_netc: self.m33_mask_netc(),
            m33_mask_sim_aon: self.m33_mask_sim_aon(),
            m33_mask_adc1: self.m33_mask_adc1(),
            m33_mask_adc2: self.m33_mask_adc2(),
            m33_mask_flexspi1: self.m33_mask_flexspi1(),
            m33_mask_flexspi2: self.m33_mask_flexspi2(),
            m33_mask_trdc: self.m33_mask_trdc(),
            m33_mask_semc: self.m33_mask_semc(),
            m33_mask_iee: self.m33_mask_iee(),
            m33_mask_gpio1: self.m33_mask_gpio1(),
            m33_mask_gpio2: self.m33_mask_gpio2(),
            m33_mask_gpio3: self.m33_mask_gpio3(),
            m33_mask_gpio4: self.m33_mask_gpio4(),
            m33_mask_gpio5: self.m33_mask_gpio5(),
            m33_mask_gpio6: self.m33_mask_gpio6(),
            m33_mask_flexio1: self.m33_mask_flexio1(),
            m33_mask_flexio2: self.m33_mask_flexio2(),
            m33_mask_lpit1: self.m33_mask_lpit1(),
            m33_mask_lpit2: self.m33_mask_lpit2(),
            m33_mask_lpit3: self.m33_mask_lpit3(),
            m33_mask_tpm1: self.m33_mask_tpm1(),
            m33_mask_tpm2: self.m33_mask_tpm2(),
            m33_mask_tpm3: self.m33_mask_tpm3(),
            m33_mask_tpm4: self.m33_mask_tpm4(),
            m33_mask_tpm5: self.m33_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared2Tog(pub u32);
impl GprShared2Tog {
    #[doc = "m33_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm7"]
    #[inline(always)]
    pub const fn set_m33_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_cm33"]
    #[inline(always)]
    pub const fn set_m33_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma3"]
    #[inline(always)]
    pub const fn set_m33_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_edma4"]
    #[inline(always)]
    pub const fn set_m33_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_netc"]
    #[inline(always)]
    pub const fn set_m33_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m33_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc1"]
    #[inline(always)]
    pub const fn set_m33_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_adc2"]
    #[inline(always)]
    pub const fn set_m33_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_trdc"]
    #[inline(always)]
    pub const fn set_m33_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_semc"]
    #[inline(always)]
    pub const fn set_m33_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_iee"]
    #[inline(always)]
    pub const fn set_m33_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m33_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m33_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared2Tog {
    #[inline(always)]
    fn default() -> GprShared2Tog {
        GprShared2Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared2Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared2Tog")
            .field("m33_mask_cm7", &self.m33_mask_cm7())
            .field("m33_mask_cm33", &self.m33_mask_cm33())
            .field("m33_mask_edma3", &self.m33_mask_edma3())
            .field("m33_mask_edma4", &self.m33_mask_edma4())
            .field("m33_mask_netc", &self.m33_mask_netc())
            .field("m33_mask_sim_aon", &self.m33_mask_sim_aon())
            .field("m33_mask_adc1", &self.m33_mask_adc1())
            .field("m33_mask_adc2", &self.m33_mask_adc2())
            .field("m33_mask_flexspi1", &self.m33_mask_flexspi1())
            .field("m33_mask_flexspi2", &self.m33_mask_flexspi2())
            .field("m33_mask_trdc", &self.m33_mask_trdc())
            .field("m33_mask_semc", &self.m33_mask_semc())
            .field("m33_mask_iee", &self.m33_mask_iee())
            .field("m33_mask_gpio1", &self.m33_mask_gpio1())
            .field("m33_mask_gpio2", &self.m33_mask_gpio2())
            .field("m33_mask_gpio3", &self.m33_mask_gpio3())
            .field("m33_mask_gpio4", &self.m33_mask_gpio4())
            .field("m33_mask_gpio5", &self.m33_mask_gpio5())
            .field("m33_mask_gpio6", &self.m33_mask_gpio6())
            .field("m33_mask_flexio1", &self.m33_mask_flexio1())
            .field("m33_mask_flexio2", &self.m33_mask_flexio2())
            .field("m33_mask_lpit1", &self.m33_mask_lpit1())
            .field("m33_mask_lpit2", &self.m33_mask_lpit2())
            .field("m33_mask_lpit3", &self.m33_mask_lpit3())
            .field("m33_mask_tpm1", &self.m33_mask_tpm1())
            .field("m33_mask_tpm2", &self.m33_mask_tpm2())
            .field("m33_mask_tpm3", &self.m33_mask_tpm3())
            .field("m33_mask_tpm4", &self.m33_mask_tpm4())
            .field("m33_mask_tpm5", &self.m33_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared2Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared2Tog {
            m33_mask_cm7: bool,
            m33_mask_cm33: bool,
            m33_mask_edma3: bool,
            m33_mask_edma4: bool,
            m33_mask_netc: bool,
            m33_mask_sim_aon: bool,
            m33_mask_adc1: bool,
            m33_mask_adc2: bool,
            m33_mask_flexspi1: bool,
            m33_mask_flexspi2: bool,
            m33_mask_trdc: bool,
            m33_mask_semc: bool,
            m33_mask_iee: bool,
            m33_mask_gpio1: bool,
            m33_mask_gpio2: bool,
            m33_mask_gpio3: bool,
            m33_mask_gpio4: bool,
            m33_mask_gpio5: bool,
            m33_mask_gpio6: bool,
            m33_mask_flexio1: bool,
            m33_mask_flexio2: bool,
            m33_mask_lpit1: bool,
            m33_mask_lpit2: bool,
            m33_mask_lpit3: bool,
            m33_mask_tpm1: bool,
            m33_mask_tpm2: bool,
            m33_mask_tpm3: bool,
            m33_mask_tpm4: bool,
            m33_mask_tpm5: bool,
        }
        let proxy = GprShared2Tog {
            m33_mask_cm7: self.m33_mask_cm7(),
            m33_mask_cm33: self.m33_mask_cm33(),
            m33_mask_edma3: self.m33_mask_edma3(),
            m33_mask_edma4: self.m33_mask_edma4(),
            m33_mask_netc: self.m33_mask_netc(),
            m33_mask_sim_aon: self.m33_mask_sim_aon(),
            m33_mask_adc1: self.m33_mask_adc1(),
            m33_mask_adc2: self.m33_mask_adc2(),
            m33_mask_flexspi1: self.m33_mask_flexspi1(),
            m33_mask_flexspi2: self.m33_mask_flexspi2(),
            m33_mask_trdc: self.m33_mask_trdc(),
            m33_mask_semc: self.m33_mask_semc(),
            m33_mask_iee: self.m33_mask_iee(),
            m33_mask_gpio1: self.m33_mask_gpio1(),
            m33_mask_gpio2: self.m33_mask_gpio2(),
            m33_mask_gpio3: self.m33_mask_gpio3(),
            m33_mask_gpio4: self.m33_mask_gpio4(),
            m33_mask_gpio5: self.m33_mask_gpio5(),
            m33_mask_gpio6: self.m33_mask_gpio6(),
            m33_mask_flexio1: self.m33_mask_flexio1(),
            m33_mask_flexio2: self.m33_mask_flexio2(),
            m33_mask_lpit1: self.m33_mask_lpit1(),
            m33_mask_lpit2: self.m33_mask_lpit2(),
            m33_mask_lpit3: self.m33_mask_lpit3(),
            m33_mask_tpm1: self.m33_mask_tpm1(),
            m33_mask_tpm2: self.m33_mask_tpm2(),
            m33_mask_tpm3: self.m33_mask_tpm3(),
            m33_mask_tpm4: self.m33_mask_tpm4(),
            m33_mask_tpm5: self.m33_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3(pub u32);
impl GprShared3 {
    #[doc = "m33_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can1"]
    #[inline(always)]
    pub const fn set_m33_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can2"]
    #[inline(always)]
    pub const fn set_m33_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can3"]
    #[inline(always)]
    pub const fn set_m33_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared3 {
    #[inline(always)]
    fn default() -> GprShared3 {
        GprShared3(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3")
            .field("m33_mask_tpm6", &self.m33_mask_tpm6())
            .field("m33_mask_gpt1", &self.m33_mask_gpt1())
            .field("m33_mask_gpt2", &self.m33_mask_gpt2())
            .field("m33_mask_can1", &self.m33_mask_can1())
            .field("m33_mask_can2", &self.m33_mask_can2())
            .field("m33_mask_can3", &self.m33_mask_can3())
            .field("m33_mask_lpuart1", &self.m33_mask_lpuart1())
            .field("m33_mask_lpuart2", &self.m33_mask_lpuart2())
            .field("m33_mask_lpuart3", &self.m33_mask_lpuart3())
            .field("m33_mask_lpuart4", &self.m33_mask_lpuart4())
            .field("m33_mask_lpuart5", &self.m33_mask_lpuart5())
            .field("m33_mask_lpuart6", &self.m33_mask_lpuart6())
            .field("m33_mask_lpuart7", &self.m33_mask_lpuart7())
            .field("m33_mask_lpuart8", &self.m33_mask_lpuart8())
            .field("m33_mask_lpuart9", &self.m33_mask_lpuart9())
            .field("m33_mask_lpuart10", &self.m33_mask_lpuart10())
            .field("m33_mask_lpuart11", &self.m33_mask_lpuart11())
            .field("m33_mask_lpuart12", &self.m33_mask_lpuart12())
            .field("m33_mask_lpi2c1", &self.m33_mask_lpi2c1())
            .field("m33_mask_lpi2c2", &self.m33_mask_lpi2c2())
            .field("m33_mask_lpi2c3", &self.m33_mask_lpi2c3())
            .field("m33_mask_lpi2c4", &self.m33_mask_lpi2c4())
            .field("m33_mask_lpi2c5", &self.m33_mask_lpi2c5())
            .field("m33_mask_lpi2c6", &self.m33_mask_lpi2c6())
            .field("m33_mask_lpspi1", &self.m33_mask_lpspi1())
            .field("m33_mask_lpspi2", &self.m33_mask_lpspi2())
            .field("m33_mask_lpspi3", &self.m33_mask_lpspi3())
            .field("m33_mask_lpspi4", &self.m33_mask_lpspi4())
            .field("m33_mask_lpspi5", &self.m33_mask_lpspi5())
            .field("m33_mask_lpspi6", &self.m33_mask_lpspi6())
            .field("m33_mask_sinc1", &self.m33_mask_sinc1())
            .field("m33_mask_sinc2", &self.m33_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3 {
            m33_mask_tpm6: bool,
            m33_mask_gpt1: bool,
            m33_mask_gpt2: bool,
            m33_mask_can1: bool,
            m33_mask_can2: bool,
            m33_mask_can3: bool,
            m33_mask_lpuart1: bool,
            m33_mask_lpuart2: bool,
            m33_mask_lpuart3: bool,
            m33_mask_lpuart4: bool,
            m33_mask_lpuart5: bool,
            m33_mask_lpuart6: bool,
            m33_mask_lpuart7: bool,
            m33_mask_lpuart8: bool,
            m33_mask_lpuart9: bool,
            m33_mask_lpuart10: bool,
            m33_mask_lpuart11: bool,
            m33_mask_lpuart12: bool,
            m33_mask_lpi2c1: bool,
            m33_mask_lpi2c2: bool,
            m33_mask_lpi2c3: bool,
            m33_mask_lpi2c4: bool,
            m33_mask_lpi2c5: bool,
            m33_mask_lpi2c6: bool,
            m33_mask_lpspi1: bool,
            m33_mask_lpspi2: bool,
            m33_mask_lpspi3: bool,
            m33_mask_lpspi4: bool,
            m33_mask_lpspi5: bool,
            m33_mask_lpspi6: bool,
            m33_mask_sinc1: bool,
            m33_mask_sinc2: bool,
        }
        let proxy = GprShared3 {
            m33_mask_tpm6: self.m33_mask_tpm6(),
            m33_mask_gpt1: self.m33_mask_gpt1(),
            m33_mask_gpt2: self.m33_mask_gpt2(),
            m33_mask_can1: self.m33_mask_can1(),
            m33_mask_can2: self.m33_mask_can2(),
            m33_mask_can3: self.m33_mask_can3(),
            m33_mask_lpuart1: self.m33_mask_lpuart1(),
            m33_mask_lpuart2: self.m33_mask_lpuart2(),
            m33_mask_lpuart3: self.m33_mask_lpuart3(),
            m33_mask_lpuart4: self.m33_mask_lpuart4(),
            m33_mask_lpuart5: self.m33_mask_lpuart5(),
            m33_mask_lpuart6: self.m33_mask_lpuart6(),
            m33_mask_lpuart7: self.m33_mask_lpuart7(),
            m33_mask_lpuart8: self.m33_mask_lpuart8(),
            m33_mask_lpuart9: self.m33_mask_lpuart9(),
            m33_mask_lpuart10: self.m33_mask_lpuart10(),
            m33_mask_lpuart11: self.m33_mask_lpuart11(),
            m33_mask_lpuart12: self.m33_mask_lpuart12(),
            m33_mask_lpi2c1: self.m33_mask_lpi2c1(),
            m33_mask_lpi2c2: self.m33_mask_lpi2c2(),
            m33_mask_lpi2c3: self.m33_mask_lpi2c3(),
            m33_mask_lpi2c4: self.m33_mask_lpi2c4(),
            m33_mask_lpi2c5: self.m33_mask_lpi2c5(),
            m33_mask_lpi2c6: self.m33_mask_lpi2c6(),
            m33_mask_lpspi1: self.m33_mask_lpspi1(),
            m33_mask_lpspi2: self.m33_mask_lpspi2(),
            m33_mask_lpspi3: self.m33_mask_lpspi3(),
            m33_mask_lpspi4: self.m33_mask_lpspi4(),
            m33_mask_lpspi5: self.m33_mask_lpspi5(),
            m33_mask_lpspi6: self.m33_mask_lpspi6(),
            m33_mask_sinc1: self.m33_mask_sinc1(),
            m33_mask_sinc2: self.m33_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3Authen(pub u32);
impl GprShared3Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared3AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared3AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared3AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared3AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared3AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared3AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared3Authen {
    #[inline(always)]
    fn default() -> GprShared3Authen {
        GprShared3Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3Authen {
            tz_user: super::vals::GprShared3AuthenTzUser,
            tz_ns: super::vals::GprShared3AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared3Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3AuthenClr(pub u32);
impl GprShared3AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared3AuthenClr {
    #[inline(always)]
    fn default() -> GprShared3AuthenClr {
        GprShared3AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared3AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3AuthenSet(pub u32);
impl GprShared3AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared3AuthenSet {
    #[inline(always)]
    fn default() -> GprShared3AuthenSet {
        GprShared3AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared3AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3AuthenTog(pub u32);
impl GprShared3AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared3AuthenTog {
    #[inline(always)]
    fn default() -> GprShared3AuthenTog {
        GprShared3AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared3AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3Clr(pub u32);
impl GprShared3Clr {
    #[doc = "m33_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can1"]
    #[inline(always)]
    pub const fn set_m33_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can2"]
    #[inline(always)]
    pub const fn set_m33_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can3"]
    #[inline(always)]
    pub const fn set_m33_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared3Clr {
    #[inline(always)]
    fn default() -> GprShared3Clr {
        GprShared3Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3Clr")
            .field("m33_mask_tpm6", &self.m33_mask_tpm6())
            .field("m33_mask_gpt1", &self.m33_mask_gpt1())
            .field("m33_mask_gpt2", &self.m33_mask_gpt2())
            .field("m33_mask_can1", &self.m33_mask_can1())
            .field("m33_mask_can2", &self.m33_mask_can2())
            .field("m33_mask_can3", &self.m33_mask_can3())
            .field("m33_mask_lpuart1", &self.m33_mask_lpuart1())
            .field("m33_mask_lpuart2", &self.m33_mask_lpuart2())
            .field("m33_mask_lpuart3", &self.m33_mask_lpuart3())
            .field("m33_mask_lpuart4", &self.m33_mask_lpuart4())
            .field("m33_mask_lpuart5", &self.m33_mask_lpuart5())
            .field("m33_mask_lpuart6", &self.m33_mask_lpuart6())
            .field("m33_mask_lpuart7", &self.m33_mask_lpuart7())
            .field("m33_mask_lpuart8", &self.m33_mask_lpuart8())
            .field("m33_mask_lpuart9", &self.m33_mask_lpuart9())
            .field("m33_mask_lpuart10", &self.m33_mask_lpuart10())
            .field("m33_mask_lpuart11", &self.m33_mask_lpuart11())
            .field("m33_mask_lpuart12", &self.m33_mask_lpuart12())
            .field("m33_mask_lpi2c1", &self.m33_mask_lpi2c1())
            .field("m33_mask_lpi2c2", &self.m33_mask_lpi2c2())
            .field("m33_mask_lpi2c3", &self.m33_mask_lpi2c3())
            .field("m33_mask_lpi2c4", &self.m33_mask_lpi2c4())
            .field("m33_mask_lpi2c5", &self.m33_mask_lpi2c5())
            .field("m33_mask_lpi2c6", &self.m33_mask_lpi2c6())
            .field("m33_mask_lpspi1", &self.m33_mask_lpspi1())
            .field("m33_mask_lpspi2", &self.m33_mask_lpspi2())
            .field("m33_mask_lpspi3", &self.m33_mask_lpspi3())
            .field("m33_mask_lpspi4", &self.m33_mask_lpspi4())
            .field("m33_mask_lpspi5", &self.m33_mask_lpspi5())
            .field("m33_mask_lpspi6", &self.m33_mask_lpspi6())
            .field("m33_mask_sinc1", &self.m33_mask_sinc1())
            .field("m33_mask_sinc2", &self.m33_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3Clr {
            m33_mask_tpm6: bool,
            m33_mask_gpt1: bool,
            m33_mask_gpt2: bool,
            m33_mask_can1: bool,
            m33_mask_can2: bool,
            m33_mask_can3: bool,
            m33_mask_lpuart1: bool,
            m33_mask_lpuart2: bool,
            m33_mask_lpuart3: bool,
            m33_mask_lpuart4: bool,
            m33_mask_lpuart5: bool,
            m33_mask_lpuart6: bool,
            m33_mask_lpuart7: bool,
            m33_mask_lpuart8: bool,
            m33_mask_lpuart9: bool,
            m33_mask_lpuart10: bool,
            m33_mask_lpuart11: bool,
            m33_mask_lpuart12: bool,
            m33_mask_lpi2c1: bool,
            m33_mask_lpi2c2: bool,
            m33_mask_lpi2c3: bool,
            m33_mask_lpi2c4: bool,
            m33_mask_lpi2c5: bool,
            m33_mask_lpi2c6: bool,
            m33_mask_lpspi1: bool,
            m33_mask_lpspi2: bool,
            m33_mask_lpspi3: bool,
            m33_mask_lpspi4: bool,
            m33_mask_lpspi5: bool,
            m33_mask_lpspi6: bool,
            m33_mask_sinc1: bool,
            m33_mask_sinc2: bool,
        }
        let proxy = GprShared3Clr {
            m33_mask_tpm6: self.m33_mask_tpm6(),
            m33_mask_gpt1: self.m33_mask_gpt1(),
            m33_mask_gpt2: self.m33_mask_gpt2(),
            m33_mask_can1: self.m33_mask_can1(),
            m33_mask_can2: self.m33_mask_can2(),
            m33_mask_can3: self.m33_mask_can3(),
            m33_mask_lpuart1: self.m33_mask_lpuart1(),
            m33_mask_lpuart2: self.m33_mask_lpuart2(),
            m33_mask_lpuart3: self.m33_mask_lpuart3(),
            m33_mask_lpuart4: self.m33_mask_lpuart4(),
            m33_mask_lpuart5: self.m33_mask_lpuart5(),
            m33_mask_lpuart6: self.m33_mask_lpuart6(),
            m33_mask_lpuart7: self.m33_mask_lpuart7(),
            m33_mask_lpuart8: self.m33_mask_lpuart8(),
            m33_mask_lpuart9: self.m33_mask_lpuart9(),
            m33_mask_lpuart10: self.m33_mask_lpuart10(),
            m33_mask_lpuart11: self.m33_mask_lpuart11(),
            m33_mask_lpuart12: self.m33_mask_lpuart12(),
            m33_mask_lpi2c1: self.m33_mask_lpi2c1(),
            m33_mask_lpi2c2: self.m33_mask_lpi2c2(),
            m33_mask_lpi2c3: self.m33_mask_lpi2c3(),
            m33_mask_lpi2c4: self.m33_mask_lpi2c4(),
            m33_mask_lpi2c5: self.m33_mask_lpi2c5(),
            m33_mask_lpi2c6: self.m33_mask_lpi2c6(),
            m33_mask_lpspi1: self.m33_mask_lpspi1(),
            m33_mask_lpspi2: self.m33_mask_lpspi2(),
            m33_mask_lpspi3: self.m33_mask_lpspi3(),
            m33_mask_lpspi4: self.m33_mask_lpspi4(),
            m33_mask_lpspi5: self.m33_mask_lpspi5(),
            m33_mask_lpspi6: self.m33_mask_lpspi6(),
            m33_mask_sinc1: self.m33_mask_sinc1(),
            m33_mask_sinc2: self.m33_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3Set(pub u32);
impl GprShared3Set {
    #[doc = "m33_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can1"]
    #[inline(always)]
    pub const fn set_m33_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can2"]
    #[inline(always)]
    pub const fn set_m33_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can3"]
    #[inline(always)]
    pub const fn set_m33_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared3Set {
    #[inline(always)]
    fn default() -> GprShared3Set {
        GprShared3Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3Set")
            .field("m33_mask_tpm6", &self.m33_mask_tpm6())
            .field("m33_mask_gpt1", &self.m33_mask_gpt1())
            .field("m33_mask_gpt2", &self.m33_mask_gpt2())
            .field("m33_mask_can1", &self.m33_mask_can1())
            .field("m33_mask_can2", &self.m33_mask_can2())
            .field("m33_mask_can3", &self.m33_mask_can3())
            .field("m33_mask_lpuart1", &self.m33_mask_lpuart1())
            .field("m33_mask_lpuart2", &self.m33_mask_lpuart2())
            .field("m33_mask_lpuart3", &self.m33_mask_lpuart3())
            .field("m33_mask_lpuart4", &self.m33_mask_lpuart4())
            .field("m33_mask_lpuart5", &self.m33_mask_lpuart5())
            .field("m33_mask_lpuart6", &self.m33_mask_lpuart6())
            .field("m33_mask_lpuart7", &self.m33_mask_lpuart7())
            .field("m33_mask_lpuart8", &self.m33_mask_lpuart8())
            .field("m33_mask_lpuart9", &self.m33_mask_lpuart9())
            .field("m33_mask_lpuart10", &self.m33_mask_lpuart10())
            .field("m33_mask_lpuart11", &self.m33_mask_lpuart11())
            .field("m33_mask_lpuart12", &self.m33_mask_lpuart12())
            .field("m33_mask_lpi2c1", &self.m33_mask_lpi2c1())
            .field("m33_mask_lpi2c2", &self.m33_mask_lpi2c2())
            .field("m33_mask_lpi2c3", &self.m33_mask_lpi2c3())
            .field("m33_mask_lpi2c4", &self.m33_mask_lpi2c4())
            .field("m33_mask_lpi2c5", &self.m33_mask_lpi2c5())
            .field("m33_mask_lpi2c6", &self.m33_mask_lpi2c6())
            .field("m33_mask_lpspi1", &self.m33_mask_lpspi1())
            .field("m33_mask_lpspi2", &self.m33_mask_lpspi2())
            .field("m33_mask_lpspi3", &self.m33_mask_lpspi3())
            .field("m33_mask_lpspi4", &self.m33_mask_lpspi4())
            .field("m33_mask_lpspi5", &self.m33_mask_lpspi5())
            .field("m33_mask_lpspi6", &self.m33_mask_lpspi6())
            .field("m33_mask_sinc1", &self.m33_mask_sinc1())
            .field("m33_mask_sinc2", &self.m33_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3Set {
            m33_mask_tpm6: bool,
            m33_mask_gpt1: bool,
            m33_mask_gpt2: bool,
            m33_mask_can1: bool,
            m33_mask_can2: bool,
            m33_mask_can3: bool,
            m33_mask_lpuart1: bool,
            m33_mask_lpuart2: bool,
            m33_mask_lpuart3: bool,
            m33_mask_lpuart4: bool,
            m33_mask_lpuart5: bool,
            m33_mask_lpuart6: bool,
            m33_mask_lpuart7: bool,
            m33_mask_lpuart8: bool,
            m33_mask_lpuart9: bool,
            m33_mask_lpuart10: bool,
            m33_mask_lpuart11: bool,
            m33_mask_lpuart12: bool,
            m33_mask_lpi2c1: bool,
            m33_mask_lpi2c2: bool,
            m33_mask_lpi2c3: bool,
            m33_mask_lpi2c4: bool,
            m33_mask_lpi2c5: bool,
            m33_mask_lpi2c6: bool,
            m33_mask_lpspi1: bool,
            m33_mask_lpspi2: bool,
            m33_mask_lpspi3: bool,
            m33_mask_lpspi4: bool,
            m33_mask_lpspi5: bool,
            m33_mask_lpspi6: bool,
            m33_mask_sinc1: bool,
            m33_mask_sinc2: bool,
        }
        let proxy = GprShared3Set {
            m33_mask_tpm6: self.m33_mask_tpm6(),
            m33_mask_gpt1: self.m33_mask_gpt1(),
            m33_mask_gpt2: self.m33_mask_gpt2(),
            m33_mask_can1: self.m33_mask_can1(),
            m33_mask_can2: self.m33_mask_can2(),
            m33_mask_can3: self.m33_mask_can3(),
            m33_mask_lpuart1: self.m33_mask_lpuart1(),
            m33_mask_lpuart2: self.m33_mask_lpuart2(),
            m33_mask_lpuart3: self.m33_mask_lpuart3(),
            m33_mask_lpuart4: self.m33_mask_lpuart4(),
            m33_mask_lpuart5: self.m33_mask_lpuart5(),
            m33_mask_lpuart6: self.m33_mask_lpuart6(),
            m33_mask_lpuart7: self.m33_mask_lpuart7(),
            m33_mask_lpuart8: self.m33_mask_lpuart8(),
            m33_mask_lpuart9: self.m33_mask_lpuart9(),
            m33_mask_lpuart10: self.m33_mask_lpuart10(),
            m33_mask_lpuart11: self.m33_mask_lpuart11(),
            m33_mask_lpuart12: self.m33_mask_lpuart12(),
            m33_mask_lpi2c1: self.m33_mask_lpi2c1(),
            m33_mask_lpi2c2: self.m33_mask_lpi2c2(),
            m33_mask_lpi2c3: self.m33_mask_lpi2c3(),
            m33_mask_lpi2c4: self.m33_mask_lpi2c4(),
            m33_mask_lpi2c5: self.m33_mask_lpi2c5(),
            m33_mask_lpi2c6: self.m33_mask_lpi2c6(),
            m33_mask_lpspi1: self.m33_mask_lpspi1(),
            m33_mask_lpspi2: self.m33_mask_lpspi2(),
            m33_mask_lpspi3: self.m33_mask_lpspi3(),
            m33_mask_lpspi4: self.m33_mask_lpspi4(),
            m33_mask_lpspi5: self.m33_mask_lpspi5(),
            m33_mask_lpspi6: self.m33_mask_lpspi6(),
            m33_mask_sinc1: self.m33_mask_sinc1(),
            m33_mask_sinc2: self.m33_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared3Tog(pub u32);
impl GprShared3Tog {
    #[doc = "m33_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m33_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m33_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can1"]
    #[inline(always)]
    pub const fn set_m33_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can2"]
    #[inline(always)]
    pub const fn set_m33_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_can3"]
    #[inline(always)]
    pub const fn set_m33_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m33_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m33_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared3Tog {
    #[inline(always)]
    fn default() -> GprShared3Tog {
        GprShared3Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared3Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared3Tog")
            .field("m33_mask_tpm6", &self.m33_mask_tpm6())
            .field("m33_mask_gpt1", &self.m33_mask_gpt1())
            .field("m33_mask_gpt2", &self.m33_mask_gpt2())
            .field("m33_mask_can1", &self.m33_mask_can1())
            .field("m33_mask_can2", &self.m33_mask_can2())
            .field("m33_mask_can3", &self.m33_mask_can3())
            .field("m33_mask_lpuart1", &self.m33_mask_lpuart1())
            .field("m33_mask_lpuart2", &self.m33_mask_lpuart2())
            .field("m33_mask_lpuart3", &self.m33_mask_lpuart3())
            .field("m33_mask_lpuart4", &self.m33_mask_lpuart4())
            .field("m33_mask_lpuart5", &self.m33_mask_lpuart5())
            .field("m33_mask_lpuart6", &self.m33_mask_lpuart6())
            .field("m33_mask_lpuart7", &self.m33_mask_lpuart7())
            .field("m33_mask_lpuart8", &self.m33_mask_lpuart8())
            .field("m33_mask_lpuart9", &self.m33_mask_lpuart9())
            .field("m33_mask_lpuart10", &self.m33_mask_lpuart10())
            .field("m33_mask_lpuart11", &self.m33_mask_lpuart11())
            .field("m33_mask_lpuart12", &self.m33_mask_lpuart12())
            .field("m33_mask_lpi2c1", &self.m33_mask_lpi2c1())
            .field("m33_mask_lpi2c2", &self.m33_mask_lpi2c2())
            .field("m33_mask_lpi2c3", &self.m33_mask_lpi2c3())
            .field("m33_mask_lpi2c4", &self.m33_mask_lpi2c4())
            .field("m33_mask_lpi2c5", &self.m33_mask_lpi2c5())
            .field("m33_mask_lpi2c6", &self.m33_mask_lpi2c6())
            .field("m33_mask_lpspi1", &self.m33_mask_lpspi1())
            .field("m33_mask_lpspi2", &self.m33_mask_lpspi2())
            .field("m33_mask_lpspi3", &self.m33_mask_lpspi3())
            .field("m33_mask_lpspi4", &self.m33_mask_lpspi4())
            .field("m33_mask_lpspi5", &self.m33_mask_lpspi5())
            .field("m33_mask_lpspi6", &self.m33_mask_lpspi6())
            .field("m33_mask_sinc1", &self.m33_mask_sinc1())
            .field("m33_mask_sinc2", &self.m33_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared3Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared3Tog {
            m33_mask_tpm6: bool,
            m33_mask_gpt1: bool,
            m33_mask_gpt2: bool,
            m33_mask_can1: bool,
            m33_mask_can2: bool,
            m33_mask_can3: bool,
            m33_mask_lpuart1: bool,
            m33_mask_lpuart2: bool,
            m33_mask_lpuart3: bool,
            m33_mask_lpuart4: bool,
            m33_mask_lpuart5: bool,
            m33_mask_lpuart6: bool,
            m33_mask_lpuart7: bool,
            m33_mask_lpuart8: bool,
            m33_mask_lpuart9: bool,
            m33_mask_lpuart10: bool,
            m33_mask_lpuart11: bool,
            m33_mask_lpuart12: bool,
            m33_mask_lpi2c1: bool,
            m33_mask_lpi2c2: bool,
            m33_mask_lpi2c3: bool,
            m33_mask_lpi2c4: bool,
            m33_mask_lpi2c5: bool,
            m33_mask_lpi2c6: bool,
            m33_mask_lpspi1: bool,
            m33_mask_lpspi2: bool,
            m33_mask_lpspi3: bool,
            m33_mask_lpspi4: bool,
            m33_mask_lpspi5: bool,
            m33_mask_lpspi6: bool,
            m33_mask_sinc1: bool,
            m33_mask_sinc2: bool,
        }
        let proxy = GprShared3Tog {
            m33_mask_tpm6: self.m33_mask_tpm6(),
            m33_mask_gpt1: self.m33_mask_gpt1(),
            m33_mask_gpt2: self.m33_mask_gpt2(),
            m33_mask_can1: self.m33_mask_can1(),
            m33_mask_can2: self.m33_mask_can2(),
            m33_mask_can3: self.m33_mask_can3(),
            m33_mask_lpuart1: self.m33_mask_lpuart1(),
            m33_mask_lpuart2: self.m33_mask_lpuart2(),
            m33_mask_lpuart3: self.m33_mask_lpuart3(),
            m33_mask_lpuart4: self.m33_mask_lpuart4(),
            m33_mask_lpuart5: self.m33_mask_lpuart5(),
            m33_mask_lpuart6: self.m33_mask_lpuart6(),
            m33_mask_lpuart7: self.m33_mask_lpuart7(),
            m33_mask_lpuart8: self.m33_mask_lpuart8(),
            m33_mask_lpuart9: self.m33_mask_lpuart9(),
            m33_mask_lpuart10: self.m33_mask_lpuart10(),
            m33_mask_lpuart11: self.m33_mask_lpuart11(),
            m33_mask_lpuart12: self.m33_mask_lpuart12(),
            m33_mask_lpi2c1: self.m33_mask_lpi2c1(),
            m33_mask_lpi2c2: self.m33_mask_lpi2c2(),
            m33_mask_lpi2c3: self.m33_mask_lpi2c3(),
            m33_mask_lpi2c4: self.m33_mask_lpi2c4(),
            m33_mask_lpi2c5: self.m33_mask_lpi2c5(),
            m33_mask_lpi2c6: self.m33_mask_lpi2c6(),
            m33_mask_lpspi1: self.m33_mask_lpspi1(),
            m33_mask_lpspi2: self.m33_mask_lpspi2(),
            m33_mask_lpspi3: self.m33_mask_lpspi3(),
            m33_mask_lpspi4: self.m33_mask_lpspi4(),
            m33_mask_lpspi5: self.m33_mask_lpspi5(),
            m33_mask_lpspi6: self.m33_mask_lpspi6(),
            m33_mask_sinc1: self.m33_mask_sinc1(),
            m33_mask_sinc2: self.m33_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4(pub u32);
impl GprShared4 {
    #[doc = "m33_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai1"]
    #[inline(always)]
    pub const fn set_m33_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai2"]
    #[inline(always)]
    pub const fn set_m33_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai3"]
    #[inline(always)]
    pub const fn set_m33_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai4"]
    #[inline(always)]
    pub const fn set_m33_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_mic"]
    #[inline(always)]
    pub const fn set_m33_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared4 {
    #[inline(always)]
    fn default() -> GprShared4 {
        GprShared4(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4")
            .field("m33_mask_sinc3", &self.m33_mask_sinc3())
            .field("m33_mask_sai1", &self.m33_mask_sai1())
            .field("m33_mask_sai2", &self.m33_mask_sai2())
            .field("m33_mask_sai3", &self.m33_mask_sai3())
            .field("m33_mask_sai4", &self.m33_mask_sai4())
            .field("m33_mask_mic", &self.m33_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4 {
            m33_mask_sinc3: bool,
            m33_mask_sai1: bool,
            m33_mask_sai2: bool,
            m33_mask_sai3: bool,
            m33_mask_sai4: bool,
            m33_mask_mic: bool,
        }
        let proxy = GprShared4 {
            m33_mask_sinc3: self.m33_mask_sinc3(),
            m33_mask_sai1: self.m33_mask_sai1(),
            m33_mask_sai2: self.m33_mask_sai2(),
            m33_mask_sai3: self.m33_mask_sai3(),
            m33_mask_sai4: self.m33_mask_sai4(),
            m33_mask_mic: self.m33_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4Authen(pub u32);
impl GprShared4Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared4AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared4AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared4AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared4AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared4AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared4AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared4Authen {
    #[inline(always)]
    fn default() -> GprShared4Authen {
        GprShared4Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4Authen {
            tz_user: super::vals::GprShared4AuthenTzUser,
            tz_ns: super::vals::GprShared4AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared4Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4AuthenClr(pub u32);
impl GprShared4AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared4AuthenClr {
    #[inline(always)]
    fn default() -> GprShared4AuthenClr {
        GprShared4AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared4AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4AuthenSet(pub u32);
impl GprShared4AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared4AuthenSet {
    #[inline(always)]
    fn default() -> GprShared4AuthenSet {
        GprShared4AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared4AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4AuthenTog(pub u32);
impl GprShared4AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared4AuthenTog {
    #[inline(always)]
    fn default() -> GprShared4AuthenTog {
        GprShared4AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared4AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4Clr(pub u32);
impl GprShared4Clr {
    #[doc = "m33_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai1"]
    #[inline(always)]
    pub const fn set_m33_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai2"]
    #[inline(always)]
    pub const fn set_m33_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai3"]
    #[inline(always)]
    pub const fn set_m33_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai4"]
    #[inline(always)]
    pub const fn set_m33_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_mic"]
    #[inline(always)]
    pub const fn set_m33_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared4Clr {
    #[inline(always)]
    fn default() -> GprShared4Clr {
        GprShared4Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4Clr")
            .field("m33_mask_sinc3", &self.m33_mask_sinc3())
            .field("m33_mask_sai1", &self.m33_mask_sai1())
            .field("m33_mask_sai2", &self.m33_mask_sai2())
            .field("m33_mask_sai3", &self.m33_mask_sai3())
            .field("m33_mask_sai4", &self.m33_mask_sai4())
            .field("m33_mask_mic", &self.m33_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4Clr {
            m33_mask_sinc3: bool,
            m33_mask_sai1: bool,
            m33_mask_sai2: bool,
            m33_mask_sai3: bool,
            m33_mask_sai4: bool,
            m33_mask_mic: bool,
        }
        let proxy = GprShared4Clr {
            m33_mask_sinc3: self.m33_mask_sinc3(),
            m33_mask_sai1: self.m33_mask_sai1(),
            m33_mask_sai2: self.m33_mask_sai2(),
            m33_mask_sai3: self.m33_mask_sai3(),
            m33_mask_sai4: self.m33_mask_sai4(),
            m33_mask_mic: self.m33_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4Set(pub u32);
impl GprShared4Set {
    #[doc = "m33_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai1"]
    #[inline(always)]
    pub const fn set_m33_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai2"]
    #[inline(always)]
    pub const fn set_m33_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai3"]
    #[inline(always)]
    pub const fn set_m33_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai4"]
    #[inline(always)]
    pub const fn set_m33_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_mic"]
    #[inline(always)]
    pub const fn set_m33_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared4Set {
    #[inline(always)]
    fn default() -> GprShared4Set {
        GprShared4Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4Set")
            .field("m33_mask_sinc3", &self.m33_mask_sinc3())
            .field("m33_mask_sai1", &self.m33_mask_sai1())
            .field("m33_mask_sai2", &self.m33_mask_sai2())
            .field("m33_mask_sai3", &self.m33_mask_sai3())
            .field("m33_mask_sai4", &self.m33_mask_sai4())
            .field("m33_mask_mic", &self.m33_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4Set {
            m33_mask_sinc3: bool,
            m33_mask_sai1: bool,
            m33_mask_sai2: bool,
            m33_mask_sai3: bool,
            m33_mask_sai4: bool,
            m33_mask_mic: bool,
        }
        let proxy = GprShared4Set {
            m33_mask_sinc3: self.m33_mask_sinc3(),
            m33_mask_sai1: self.m33_mask_sai1(),
            m33_mask_sai2: self.m33_mask_sai2(),
            m33_mask_sai3: self.m33_mask_sai3(),
            m33_mask_sai4: self.m33_mask_sai4(),
            m33_mask_mic: self.m33_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared4Tog(pub u32);
impl GprShared4Tog {
    #[doc = "m33_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m33_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai1"]
    #[inline(always)]
    pub const fn set_m33_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai2"]
    #[inline(always)]
    pub const fn set_m33_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai3"]
    #[inline(always)]
    pub const fn set_m33_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_sai4"]
    #[inline(always)]
    pub const fn set_m33_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mask_mic"]
    #[inline(always)]
    pub const fn set_m33_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared4Tog {
    #[inline(always)]
    fn default() -> GprShared4Tog {
        GprShared4Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared4Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared4Tog")
            .field("m33_mask_sinc3", &self.m33_mask_sinc3())
            .field("m33_mask_sai1", &self.m33_mask_sai1())
            .field("m33_mask_sai2", &self.m33_mask_sai2())
            .field("m33_mask_sai3", &self.m33_mask_sai3())
            .field("m33_mask_sai4", &self.m33_mask_sai4())
            .field("m33_mask_mic", &self.m33_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared4Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared4Tog {
            m33_mask_sinc3: bool,
            m33_mask_sai1: bool,
            m33_mask_sai2: bool,
            m33_mask_sai3: bool,
            m33_mask_sai4: bool,
            m33_mask_mic: bool,
        }
        let proxy = GprShared4Tog {
            m33_mask_sinc3: self.m33_mask_sinc3(),
            m33_mask_sai1: self.m33_mask_sai1(),
            m33_mask_sai2: self.m33_mask_sai2(),
            m33_mask_sai3: self.m33_mask_sai3(),
            m33_mask_sai4: self.m33_mask_sai4(),
            m33_mask_mic: self.m33_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5(pub u32);
impl GprShared5 {
    #[doc = "m7_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm7"]
    #[inline(always)]
    pub const fn set_m7_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm33"]
    #[inline(always)]
    pub const fn set_m7_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma3"]
    #[inline(always)]
    pub const fn set_m7_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma4"]
    #[inline(always)]
    pub const fn set_m7_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_netc"]
    #[inline(always)]
    pub const fn set_m7_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m7_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc1"]
    #[inline(always)]
    pub const fn set_m7_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc2"]
    #[inline(always)]
    pub const fn set_m7_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_trdc"]
    #[inline(always)]
    pub const fn set_m7_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_semc"]
    #[inline(always)]
    pub const fn set_m7_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_iee"]
    #[inline(always)]
    pub const fn set_m7_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared5 {
    #[inline(always)]
    fn default() -> GprShared5 {
        GprShared5(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5")
            .field("m7_mask_cm7", &self.m7_mask_cm7())
            .field("m7_mask_cm33", &self.m7_mask_cm33())
            .field("m7_mask_edma3", &self.m7_mask_edma3())
            .field("m7_mask_edma4", &self.m7_mask_edma4())
            .field("m7_mask_netc", &self.m7_mask_netc())
            .field("m7_mask_sim_aon", &self.m7_mask_sim_aon())
            .field("m7_mask_adc1", &self.m7_mask_adc1())
            .field("m7_mask_adc2", &self.m7_mask_adc2())
            .field("m7_mask_flexspi1", &self.m7_mask_flexspi1())
            .field("m7_mask_flexspi2", &self.m7_mask_flexspi2())
            .field("m7_mask_trdc", &self.m7_mask_trdc())
            .field("m7_mask_semc", &self.m7_mask_semc())
            .field("m7_mask_iee", &self.m7_mask_iee())
            .field("m7_mask_gpio1", &self.m7_mask_gpio1())
            .field("m7_mask_gpio2", &self.m7_mask_gpio2())
            .field("m7_mask_gpio3", &self.m7_mask_gpio3())
            .field("m7_mask_gpio4", &self.m7_mask_gpio4())
            .field("m7_mask_gpio5", &self.m7_mask_gpio5())
            .field("m7_mask_gpio6", &self.m7_mask_gpio6())
            .field("m7_mask_flexio1", &self.m7_mask_flexio1())
            .field("m7_mask_flexio2", &self.m7_mask_flexio2())
            .field("m7_mask_lpit1", &self.m7_mask_lpit1())
            .field("m7_mask_lpit2", &self.m7_mask_lpit2())
            .field("m7_mask_lpit3", &self.m7_mask_lpit3())
            .field("m7_mask_tpm1", &self.m7_mask_tpm1())
            .field("m7_mask_tpm2", &self.m7_mask_tpm2())
            .field("m7_mask_tpm3", &self.m7_mask_tpm3())
            .field("m7_mask_tpm4", &self.m7_mask_tpm4())
            .field("m7_mask_tpm5", &self.m7_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5 {
            m7_mask_cm7: bool,
            m7_mask_cm33: bool,
            m7_mask_edma3: bool,
            m7_mask_edma4: bool,
            m7_mask_netc: bool,
            m7_mask_sim_aon: bool,
            m7_mask_adc1: bool,
            m7_mask_adc2: bool,
            m7_mask_flexspi1: bool,
            m7_mask_flexspi2: bool,
            m7_mask_trdc: bool,
            m7_mask_semc: bool,
            m7_mask_iee: bool,
            m7_mask_gpio1: bool,
            m7_mask_gpio2: bool,
            m7_mask_gpio3: bool,
            m7_mask_gpio4: bool,
            m7_mask_gpio5: bool,
            m7_mask_gpio6: bool,
            m7_mask_flexio1: bool,
            m7_mask_flexio2: bool,
            m7_mask_lpit1: bool,
            m7_mask_lpit2: bool,
            m7_mask_lpit3: bool,
            m7_mask_tpm1: bool,
            m7_mask_tpm2: bool,
            m7_mask_tpm3: bool,
            m7_mask_tpm4: bool,
            m7_mask_tpm5: bool,
        }
        let proxy = GprShared5 {
            m7_mask_cm7: self.m7_mask_cm7(),
            m7_mask_cm33: self.m7_mask_cm33(),
            m7_mask_edma3: self.m7_mask_edma3(),
            m7_mask_edma4: self.m7_mask_edma4(),
            m7_mask_netc: self.m7_mask_netc(),
            m7_mask_sim_aon: self.m7_mask_sim_aon(),
            m7_mask_adc1: self.m7_mask_adc1(),
            m7_mask_adc2: self.m7_mask_adc2(),
            m7_mask_flexspi1: self.m7_mask_flexspi1(),
            m7_mask_flexspi2: self.m7_mask_flexspi2(),
            m7_mask_trdc: self.m7_mask_trdc(),
            m7_mask_semc: self.m7_mask_semc(),
            m7_mask_iee: self.m7_mask_iee(),
            m7_mask_gpio1: self.m7_mask_gpio1(),
            m7_mask_gpio2: self.m7_mask_gpio2(),
            m7_mask_gpio3: self.m7_mask_gpio3(),
            m7_mask_gpio4: self.m7_mask_gpio4(),
            m7_mask_gpio5: self.m7_mask_gpio5(),
            m7_mask_gpio6: self.m7_mask_gpio6(),
            m7_mask_flexio1: self.m7_mask_flexio1(),
            m7_mask_flexio2: self.m7_mask_flexio2(),
            m7_mask_lpit1: self.m7_mask_lpit1(),
            m7_mask_lpit2: self.m7_mask_lpit2(),
            m7_mask_lpit3: self.m7_mask_lpit3(),
            m7_mask_tpm1: self.m7_mask_tpm1(),
            m7_mask_tpm2: self.m7_mask_tpm2(),
            m7_mask_tpm3: self.m7_mask_tpm3(),
            m7_mask_tpm4: self.m7_mask_tpm4(),
            m7_mask_tpm5: self.m7_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5Authen(pub u32);
impl GprShared5Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared5AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared5AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared5AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared5AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared5AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared5AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared5Authen {
    #[inline(always)]
    fn default() -> GprShared5Authen {
        GprShared5Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5Authen {
            tz_user: super::vals::GprShared5AuthenTzUser,
            tz_ns: super::vals::GprShared5AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared5Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5AuthenClr(pub u32);
impl GprShared5AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared5AuthenClr {
    #[inline(always)]
    fn default() -> GprShared5AuthenClr {
        GprShared5AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared5AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5AuthenSet(pub u32);
impl GprShared5AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared5AuthenSet {
    #[inline(always)]
    fn default() -> GprShared5AuthenSet {
        GprShared5AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared5AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5AuthenTog(pub u32);
impl GprShared5AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared5AuthenTog {
    #[inline(always)]
    fn default() -> GprShared5AuthenTog {
        GprShared5AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared5AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5Clr(pub u32);
impl GprShared5Clr {
    #[doc = "m7_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm7"]
    #[inline(always)]
    pub const fn set_m7_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm33"]
    #[inline(always)]
    pub const fn set_m7_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma3"]
    #[inline(always)]
    pub const fn set_m7_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma4"]
    #[inline(always)]
    pub const fn set_m7_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_netc"]
    #[inline(always)]
    pub const fn set_m7_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m7_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc1"]
    #[inline(always)]
    pub const fn set_m7_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc2"]
    #[inline(always)]
    pub const fn set_m7_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_trdc"]
    #[inline(always)]
    pub const fn set_m7_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_semc"]
    #[inline(always)]
    pub const fn set_m7_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_iee"]
    #[inline(always)]
    pub const fn set_m7_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared5Clr {
    #[inline(always)]
    fn default() -> GprShared5Clr {
        GprShared5Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5Clr")
            .field("m7_mask_cm7", &self.m7_mask_cm7())
            .field("m7_mask_cm33", &self.m7_mask_cm33())
            .field("m7_mask_edma3", &self.m7_mask_edma3())
            .field("m7_mask_edma4", &self.m7_mask_edma4())
            .field("m7_mask_netc", &self.m7_mask_netc())
            .field("m7_mask_sim_aon", &self.m7_mask_sim_aon())
            .field("m7_mask_adc1", &self.m7_mask_adc1())
            .field("m7_mask_adc2", &self.m7_mask_adc2())
            .field("m7_mask_flexspi1", &self.m7_mask_flexspi1())
            .field("m7_mask_flexspi2", &self.m7_mask_flexspi2())
            .field("m7_mask_trdc", &self.m7_mask_trdc())
            .field("m7_mask_semc", &self.m7_mask_semc())
            .field("m7_mask_iee", &self.m7_mask_iee())
            .field("m7_mask_gpio1", &self.m7_mask_gpio1())
            .field("m7_mask_gpio2", &self.m7_mask_gpio2())
            .field("m7_mask_gpio3", &self.m7_mask_gpio3())
            .field("m7_mask_gpio4", &self.m7_mask_gpio4())
            .field("m7_mask_gpio5", &self.m7_mask_gpio5())
            .field("m7_mask_gpio6", &self.m7_mask_gpio6())
            .field("m7_mask_flexio1", &self.m7_mask_flexio1())
            .field("m7_mask_flexio2", &self.m7_mask_flexio2())
            .field("m7_mask_lpit1", &self.m7_mask_lpit1())
            .field("m7_mask_lpit2", &self.m7_mask_lpit2())
            .field("m7_mask_lpit3", &self.m7_mask_lpit3())
            .field("m7_mask_tpm1", &self.m7_mask_tpm1())
            .field("m7_mask_tpm2", &self.m7_mask_tpm2())
            .field("m7_mask_tpm3", &self.m7_mask_tpm3())
            .field("m7_mask_tpm4", &self.m7_mask_tpm4())
            .field("m7_mask_tpm5", &self.m7_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5Clr {
            m7_mask_cm7: bool,
            m7_mask_cm33: bool,
            m7_mask_edma3: bool,
            m7_mask_edma4: bool,
            m7_mask_netc: bool,
            m7_mask_sim_aon: bool,
            m7_mask_adc1: bool,
            m7_mask_adc2: bool,
            m7_mask_flexspi1: bool,
            m7_mask_flexspi2: bool,
            m7_mask_trdc: bool,
            m7_mask_semc: bool,
            m7_mask_iee: bool,
            m7_mask_gpio1: bool,
            m7_mask_gpio2: bool,
            m7_mask_gpio3: bool,
            m7_mask_gpio4: bool,
            m7_mask_gpio5: bool,
            m7_mask_gpio6: bool,
            m7_mask_flexio1: bool,
            m7_mask_flexio2: bool,
            m7_mask_lpit1: bool,
            m7_mask_lpit2: bool,
            m7_mask_lpit3: bool,
            m7_mask_tpm1: bool,
            m7_mask_tpm2: bool,
            m7_mask_tpm3: bool,
            m7_mask_tpm4: bool,
            m7_mask_tpm5: bool,
        }
        let proxy = GprShared5Clr {
            m7_mask_cm7: self.m7_mask_cm7(),
            m7_mask_cm33: self.m7_mask_cm33(),
            m7_mask_edma3: self.m7_mask_edma3(),
            m7_mask_edma4: self.m7_mask_edma4(),
            m7_mask_netc: self.m7_mask_netc(),
            m7_mask_sim_aon: self.m7_mask_sim_aon(),
            m7_mask_adc1: self.m7_mask_adc1(),
            m7_mask_adc2: self.m7_mask_adc2(),
            m7_mask_flexspi1: self.m7_mask_flexspi1(),
            m7_mask_flexspi2: self.m7_mask_flexspi2(),
            m7_mask_trdc: self.m7_mask_trdc(),
            m7_mask_semc: self.m7_mask_semc(),
            m7_mask_iee: self.m7_mask_iee(),
            m7_mask_gpio1: self.m7_mask_gpio1(),
            m7_mask_gpio2: self.m7_mask_gpio2(),
            m7_mask_gpio3: self.m7_mask_gpio3(),
            m7_mask_gpio4: self.m7_mask_gpio4(),
            m7_mask_gpio5: self.m7_mask_gpio5(),
            m7_mask_gpio6: self.m7_mask_gpio6(),
            m7_mask_flexio1: self.m7_mask_flexio1(),
            m7_mask_flexio2: self.m7_mask_flexio2(),
            m7_mask_lpit1: self.m7_mask_lpit1(),
            m7_mask_lpit2: self.m7_mask_lpit2(),
            m7_mask_lpit3: self.m7_mask_lpit3(),
            m7_mask_tpm1: self.m7_mask_tpm1(),
            m7_mask_tpm2: self.m7_mask_tpm2(),
            m7_mask_tpm3: self.m7_mask_tpm3(),
            m7_mask_tpm4: self.m7_mask_tpm4(),
            m7_mask_tpm5: self.m7_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5Set(pub u32);
impl GprShared5Set {
    #[doc = "m7_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm7"]
    #[inline(always)]
    pub const fn set_m7_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm33"]
    #[inline(always)]
    pub const fn set_m7_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma3"]
    #[inline(always)]
    pub const fn set_m7_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma4"]
    #[inline(always)]
    pub const fn set_m7_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_netc"]
    #[inline(always)]
    pub const fn set_m7_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m7_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc1"]
    #[inline(always)]
    pub const fn set_m7_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc2"]
    #[inline(always)]
    pub const fn set_m7_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_trdc"]
    #[inline(always)]
    pub const fn set_m7_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_semc"]
    #[inline(always)]
    pub const fn set_m7_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_iee"]
    #[inline(always)]
    pub const fn set_m7_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared5Set {
    #[inline(always)]
    fn default() -> GprShared5Set {
        GprShared5Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5Set")
            .field("m7_mask_cm7", &self.m7_mask_cm7())
            .field("m7_mask_cm33", &self.m7_mask_cm33())
            .field("m7_mask_edma3", &self.m7_mask_edma3())
            .field("m7_mask_edma4", &self.m7_mask_edma4())
            .field("m7_mask_netc", &self.m7_mask_netc())
            .field("m7_mask_sim_aon", &self.m7_mask_sim_aon())
            .field("m7_mask_adc1", &self.m7_mask_adc1())
            .field("m7_mask_adc2", &self.m7_mask_adc2())
            .field("m7_mask_flexspi1", &self.m7_mask_flexspi1())
            .field("m7_mask_flexspi2", &self.m7_mask_flexspi2())
            .field("m7_mask_trdc", &self.m7_mask_trdc())
            .field("m7_mask_semc", &self.m7_mask_semc())
            .field("m7_mask_iee", &self.m7_mask_iee())
            .field("m7_mask_gpio1", &self.m7_mask_gpio1())
            .field("m7_mask_gpio2", &self.m7_mask_gpio2())
            .field("m7_mask_gpio3", &self.m7_mask_gpio3())
            .field("m7_mask_gpio4", &self.m7_mask_gpio4())
            .field("m7_mask_gpio5", &self.m7_mask_gpio5())
            .field("m7_mask_gpio6", &self.m7_mask_gpio6())
            .field("m7_mask_flexio1", &self.m7_mask_flexio1())
            .field("m7_mask_flexio2", &self.m7_mask_flexio2())
            .field("m7_mask_lpit1", &self.m7_mask_lpit1())
            .field("m7_mask_lpit2", &self.m7_mask_lpit2())
            .field("m7_mask_lpit3", &self.m7_mask_lpit3())
            .field("m7_mask_tpm1", &self.m7_mask_tpm1())
            .field("m7_mask_tpm2", &self.m7_mask_tpm2())
            .field("m7_mask_tpm3", &self.m7_mask_tpm3())
            .field("m7_mask_tpm4", &self.m7_mask_tpm4())
            .field("m7_mask_tpm5", &self.m7_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5Set {
            m7_mask_cm7: bool,
            m7_mask_cm33: bool,
            m7_mask_edma3: bool,
            m7_mask_edma4: bool,
            m7_mask_netc: bool,
            m7_mask_sim_aon: bool,
            m7_mask_adc1: bool,
            m7_mask_adc2: bool,
            m7_mask_flexspi1: bool,
            m7_mask_flexspi2: bool,
            m7_mask_trdc: bool,
            m7_mask_semc: bool,
            m7_mask_iee: bool,
            m7_mask_gpio1: bool,
            m7_mask_gpio2: bool,
            m7_mask_gpio3: bool,
            m7_mask_gpio4: bool,
            m7_mask_gpio5: bool,
            m7_mask_gpio6: bool,
            m7_mask_flexio1: bool,
            m7_mask_flexio2: bool,
            m7_mask_lpit1: bool,
            m7_mask_lpit2: bool,
            m7_mask_lpit3: bool,
            m7_mask_tpm1: bool,
            m7_mask_tpm2: bool,
            m7_mask_tpm3: bool,
            m7_mask_tpm4: bool,
            m7_mask_tpm5: bool,
        }
        let proxy = GprShared5Set {
            m7_mask_cm7: self.m7_mask_cm7(),
            m7_mask_cm33: self.m7_mask_cm33(),
            m7_mask_edma3: self.m7_mask_edma3(),
            m7_mask_edma4: self.m7_mask_edma4(),
            m7_mask_netc: self.m7_mask_netc(),
            m7_mask_sim_aon: self.m7_mask_sim_aon(),
            m7_mask_adc1: self.m7_mask_adc1(),
            m7_mask_adc2: self.m7_mask_adc2(),
            m7_mask_flexspi1: self.m7_mask_flexspi1(),
            m7_mask_flexspi2: self.m7_mask_flexspi2(),
            m7_mask_trdc: self.m7_mask_trdc(),
            m7_mask_semc: self.m7_mask_semc(),
            m7_mask_iee: self.m7_mask_iee(),
            m7_mask_gpio1: self.m7_mask_gpio1(),
            m7_mask_gpio2: self.m7_mask_gpio2(),
            m7_mask_gpio3: self.m7_mask_gpio3(),
            m7_mask_gpio4: self.m7_mask_gpio4(),
            m7_mask_gpio5: self.m7_mask_gpio5(),
            m7_mask_gpio6: self.m7_mask_gpio6(),
            m7_mask_flexio1: self.m7_mask_flexio1(),
            m7_mask_flexio2: self.m7_mask_flexio2(),
            m7_mask_lpit1: self.m7_mask_lpit1(),
            m7_mask_lpit2: self.m7_mask_lpit2(),
            m7_mask_lpit3: self.m7_mask_lpit3(),
            m7_mask_tpm1: self.m7_mask_tpm1(),
            m7_mask_tpm2: self.m7_mask_tpm2(),
            m7_mask_tpm3: self.m7_mask_tpm3(),
            m7_mask_tpm4: self.m7_mask_tpm4(),
            m7_mask_tpm5: self.m7_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared5Tog(pub u32);
impl GprShared5Tog {
    #[doc = "m7_mask_cm7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm7(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm7"]
    #[inline(always)]
    pub const fn set_m7_mask_cm7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_cm33"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_cm33(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_cm33"]
    #[inline(always)]
    pub const fn set_m7_mask_cm33(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_edma3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma3(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma3"]
    #[inline(always)]
    pub const fn set_m7_mask_edma3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_edma4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_edma4(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_edma4"]
    #[inline(always)]
    pub const fn set_m7_mask_edma4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_netc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_netc(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_netc"]
    #[inline(always)]
    pub const fn set_m7_mask_netc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_sim_aon"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sim_aon(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sim_aon"]
    #[inline(always)]
    pub const fn set_m7_mask_sim_aon(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_adc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc1(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc1"]
    #[inline(always)]
    pub const fn set_m7_mask_adc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_adc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_adc2(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_adc2"]
    #[inline(always)]
    pub const fn set_m7_mask_adc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_flexspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi1(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_flexspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexspi2(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_trdc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_trdc(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_trdc"]
    #[inline(always)]
    pub const fn set_m7_mask_trdc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_semc"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_semc(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_semc"]
    #[inline(always)]
    pub const fn set_m7_mask_semc(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_iee"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_iee(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_iee"]
    #[inline(always)]
    pub const fn set_m7_mask_iee(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_gpio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio1(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_gpio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio2(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_gpio3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio3(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio3"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_gpio4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio4(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio4"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_gpio5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio5(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio5"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_gpio6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpio6(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpio6"]
    #[inline(always)]
    pub const fn set_m7_mask_gpio6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_flexio1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio1(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio1"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_flexio2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_flexio2(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_flexio2"]
    #[inline(always)]
    pub const fn set_m7_mask_flexio2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpit1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpit2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpit3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpit3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpit3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpit3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_tpm1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm1(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm1"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_tpm2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm2(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm2"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_tpm3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm3(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm3"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_tpm4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm4(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm4"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_tpm5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm5(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm5"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared5Tog {
    #[inline(always)]
    fn default() -> GprShared5Tog {
        GprShared5Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared5Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared5Tog")
            .field("m7_mask_cm7", &self.m7_mask_cm7())
            .field("m7_mask_cm33", &self.m7_mask_cm33())
            .field("m7_mask_edma3", &self.m7_mask_edma3())
            .field("m7_mask_edma4", &self.m7_mask_edma4())
            .field("m7_mask_netc", &self.m7_mask_netc())
            .field("m7_mask_sim_aon", &self.m7_mask_sim_aon())
            .field("m7_mask_adc1", &self.m7_mask_adc1())
            .field("m7_mask_adc2", &self.m7_mask_adc2())
            .field("m7_mask_flexspi1", &self.m7_mask_flexspi1())
            .field("m7_mask_flexspi2", &self.m7_mask_flexspi2())
            .field("m7_mask_trdc", &self.m7_mask_trdc())
            .field("m7_mask_semc", &self.m7_mask_semc())
            .field("m7_mask_iee", &self.m7_mask_iee())
            .field("m7_mask_gpio1", &self.m7_mask_gpio1())
            .field("m7_mask_gpio2", &self.m7_mask_gpio2())
            .field("m7_mask_gpio3", &self.m7_mask_gpio3())
            .field("m7_mask_gpio4", &self.m7_mask_gpio4())
            .field("m7_mask_gpio5", &self.m7_mask_gpio5())
            .field("m7_mask_gpio6", &self.m7_mask_gpio6())
            .field("m7_mask_flexio1", &self.m7_mask_flexio1())
            .field("m7_mask_flexio2", &self.m7_mask_flexio2())
            .field("m7_mask_lpit1", &self.m7_mask_lpit1())
            .field("m7_mask_lpit2", &self.m7_mask_lpit2())
            .field("m7_mask_lpit3", &self.m7_mask_lpit3())
            .field("m7_mask_tpm1", &self.m7_mask_tpm1())
            .field("m7_mask_tpm2", &self.m7_mask_tpm2())
            .field("m7_mask_tpm3", &self.m7_mask_tpm3())
            .field("m7_mask_tpm4", &self.m7_mask_tpm4())
            .field("m7_mask_tpm5", &self.m7_mask_tpm5())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared5Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared5Tog {
            m7_mask_cm7: bool,
            m7_mask_cm33: bool,
            m7_mask_edma3: bool,
            m7_mask_edma4: bool,
            m7_mask_netc: bool,
            m7_mask_sim_aon: bool,
            m7_mask_adc1: bool,
            m7_mask_adc2: bool,
            m7_mask_flexspi1: bool,
            m7_mask_flexspi2: bool,
            m7_mask_trdc: bool,
            m7_mask_semc: bool,
            m7_mask_iee: bool,
            m7_mask_gpio1: bool,
            m7_mask_gpio2: bool,
            m7_mask_gpio3: bool,
            m7_mask_gpio4: bool,
            m7_mask_gpio5: bool,
            m7_mask_gpio6: bool,
            m7_mask_flexio1: bool,
            m7_mask_flexio2: bool,
            m7_mask_lpit1: bool,
            m7_mask_lpit2: bool,
            m7_mask_lpit3: bool,
            m7_mask_tpm1: bool,
            m7_mask_tpm2: bool,
            m7_mask_tpm3: bool,
            m7_mask_tpm4: bool,
            m7_mask_tpm5: bool,
        }
        let proxy = GprShared5Tog {
            m7_mask_cm7: self.m7_mask_cm7(),
            m7_mask_cm33: self.m7_mask_cm33(),
            m7_mask_edma3: self.m7_mask_edma3(),
            m7_mask_edma4: self.m7_mask_edma4(),
            m7_mask_netc: self.m7_mask_netc(),
            m7_mask_sim_aon: self.m7_mask_sim_aon(),
            m7_mask_adc1: self.m7_mask_adc1(),
            m7_mask_adc2: self.m7_mask_adc2(),
            m7_mask_flexspi1: self.m7_mask_flexspi1(),
            m7_mask_flexspi2: self.m7_mask_flexspi2(),
            m7_mask_trdc: self.m7_mask_trdc(),
            m7_mask_semc: self.m7_mask_semc(),
            m7_mask_iee: self.m7_mask_iee(),
            m7_mask_gpio1: self.m7_mask_gpio1(),
            m7_mask_gpio2: self.m7_mask_gpio2(),
            m7_mask_gpio3: self.m7_mask_gpio3(),
            m7_mask_gpio4: self.m7_mask_gpio4(),
            m7_mask_gpio5: self.m7_mask_gpio5(),
            m7_mask_gpio6: self.m7_mask_gpio6(),
            m7_mask_flexio1: self.m7_mask_flexio1(),
            m7_mask_flexio2: self.m7_mask_flexio2(),
            m7_mask_lpit1: self.m7_mask_lpit1(),
            m7_mask_lpit2: self.m7_mask_lpit2(),
            m7_mask_lpit3: self.m7_mask_lpit3(),
            m7_mask_tpm1: self.m7_mask_tpm1(),
            m7_mask_tpm2: self.m7_mask_tpm2(),
            m7_mask_tpm3: self.m7_mask_tpm3(),
            m7_mask_tpm4: self.m7_mask_tpm4(),
            m7_mask_tpm5: self.m7_mask_tpm5(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6(pub u32);
impl GprShared6 {
    #[doc = "m7_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can1"]
    #[inline(always)]
    pub const fn set_m7_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can2"]
    #[inline(always)]
    pub const fn set_m7_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can3"]
    #[inline(always)]
    pub const fn set_m7_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared6 {
    #[inline(always)]
    fn default() -> GprShared6 {
        GprShared6(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6")
            .field("m7_mask_tpm6", &self.m7_mask_tpm6())
            .field("m7_mask_gpt1", &self.m7_mask_gpt1())
            .field("m7_mask_gpt2", &self.m7_mask_gpt2())
            .field("m7_mask_can1", &self.m7_mask_can1())
            .field("m7_mask_can2", &self.m7_mask_can2())
            .field("m7_mask_can3", &self.m7_mask_can3())
            .field("m7_mask_lpuart1", &self.m7_mask_lpuart1())
            .field("m7_mask_lpuart2", &self.m7_mask_lpuart2())
            .field("m7_mask_lpuart3", &self.m7_mask_lpuart3())
            .field("m7_mask_lpuart4", &self.m7_mask_lpuart4())
            .field("m7_mask_lpuart5", &self.m7_mask_lpuart5())
            .field("m7_mask_lpuart6", &self.m7_mask_lpuart6())
            .field("m7_mask_lpuart7", &self.m7_mask_lpuart7())
            .field("m7_mask_lpuart8", &self.m7_mask_lpuart8())
            .field("m7_mask_lpuart9", &self.m7_mask_lpuart9())
            .field("m7_mask_lpuart10", &self.m7_mask_lpuart10())
            .field("m7_mask_lpuart11", &self.m7_mask_lpuart11())
            .field("m7_mask_lpuart12", &self.m7_mask_lpuart12())
            .field("m7_mask_lpi2c1", &self.m7_mask_lpi2c1())
            .field("m7_mask_lpi2c2", &self.m7_mask_lpi2c2())
            .field("m7_mask_lpi2c3", &self.m7_mask_lpi2c3())
            .field("m7_mask_lpi2c4", &self.m7_mask_lpi2c4())
            .field("m7_mask_lpi2c5", &self.m7_mask_lpi2c5())
            .field("m7_mask_lpi2c6", &self.m7_mask_lpi2c6())
            .field("m7_mask_lpspi1", &self.m7_mask_lpspi1())
            .field("m7_mask_lpspi2", &self.m7_mask_lpspi2())
            .field("m7_mask_lpspi3", &self.m7_mask_lpspi3())
            .field("m7_mask_lpspi4", &self.m7_mask_lpspi4())
            .field("m7_mask_lpspi5", &self.m7_mask_lpspi5())
            .field("m7_mask_lpspi6", &self.m7_mask_lpspi6())
            .field("m7_mask_sinc1", &self.m7_mask_sinc1())
            .field("m7_mask_sinc2", &self.m7_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6 {
            m7_mask_tpm6: bool,
            m7_mask_gpt1: bool,
            m7_mask_gpt2: bool,
            m7_mask_can1: bool,
            m7_mask_can2: bool,
            m7_mask_can3: bool,
            m7_mask_lpuart1: bool,
            m7_mask_lpuart2: bool,
            m7_mask_lpuart3: bool,
            m7_mask_lpuart4: bool,
            m7_mask_lpuart5: bool,
            m7_mask_lpuart6: bool,
            m7_mask_lpuart7: bool,
            m7_mask_lpuart8: bool,
            m7_mask_lpuart9: bool,
            m7_mask_lpuart10: bool,
            m7_mask_lpuart11: bool,
            m7_mask_lpuart12: bool,
            m7_mask_lpi2c1: bool,
            m7_mask_lpi2c2: bool,
            m7_mask_lpi2c3: bool,
            m7_mask_lpi2c4: bool,
            m7_mask_lpi2c5: bool,
            m7_mask_lpi2c6: bool,
            m7_mask_lpspi1: bool,
            m7_mask_lpspi2: bool,
            m7_mask_lpspi3: bool,
            m7_mask_lpspi4: bool,
            m7_mask_lpspi5: bool,
            m7_mask_lpspi6: bool,
            m7_mask_sinc1: bool,
            m7_mask_sinc2: bool,
        }
        let proxy = GprShared6 {
            m7_mask_tpm6: self.m7_mask_tpm6(),
            m7_mask_gpt1: self.m7_mask_gpt1(),
            m7_mask_gpt2: self.m7_mask_gpt2(),
            m7_mask_can1: self.m7_mask_can1(),
            m7_mask_can2: self.m7_mask_can2(),
            m7_mask_can3: self.m7_mask_can3(),
            m7_mask_lpuart1: self.m7_mask_lpuart1(),
            m7_mask_lpuart2: self.m7_mask_lpuart2(),
            m7_mask_lpuart3: self.m7_mask_lpuart3(),
            m7_mask_lpuart4: self.m7_mask_lpuart4(),
            m7_mask_lpuart5: self.m7_mask_lpuart5(),
            m7_mask_lpuart6: self.m7_mask_lpuart6(),
            m7_mask_lpuart7: self.m7_mask_lpuart7(),
            m7_mask_lpuart8: self.m7_mask_lpuart8(),
            m7_mask_lpuart9: self.m7_mask_lpuart9(),
            m7_mask_lpuart10: self.m7_mask_lpuart10(),
            m7_mask_lpuart11: self.m7_mask_lpuart11(),
            m7_mask_lpuart12: self.m7_mask_lpuart12(),
            m7_mask_lpi2c1: self.m7_mask_lpi2c1(),
            m7_mask_lpi2c2: self.m7_mask_lpi2c2(),
            m7_mask_lpi2c3: self.m7_mask_lpi2c3(),
            m7_mask_lpi2c4: self.m7_mask_lpi2c4(),
            m7_mask_lpi2c5: self.m7_mask_lpi2c5(),
            m7_mask_lpi2c6: self.m7_mask_lpi2c6(),
            m7_mask_lpspi1: self.m7_mask_lpspi1(),
            m7_mask_lpspi2: self.m7_mask_lpspi2(),
            m7_mask_lpspi3: self.m7_mask_lpspi3(),
            m7_mask_lpspi4: self.m7_mask_lpspi4(),
            m7_mask_lpspi5: self.m7_mask_lpspi5(),
            m7_mask_lpspi6: self.m7_mask_lpspi6(),
            m7_mask_sinc1: self.m7_mask_sinc1(),
            m7_mask_sinc2: self.m7_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6Authen(pub u32);
impl GprShared6Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared6AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared6AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared6AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared6AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared6AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared6AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared6Authen {
    #[inline(always)]
    fn default() -> GprShared6Authen {
        GprShared6Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6Authen {
            tz_user: super::vals::GprShared6AuthenTzUser,
            tz_ns: super::vals::GprShared6AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared6Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6AuthenClr(pub u32);
impl GprShared6AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared6AuthenClr {
    #[inline(always)]
    fn default() -> GprShared6AuthenClr {
        GprShared6AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared6AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6AuthenSet(pub u32);
impl GprShared6AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared6AuthenSet {
    #[inline(always)]
    fn default() -> GprShared6AuthenSet {
        GprShared6AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared6AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6AuthenTog(pub u32);
impl GprShared6AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared6AuthenTog {
    #[inline(always)]
    fn default() -> GprShared6AuthenTog {
        GprShared6AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared6AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6Clr(pub u32);
impl GprShared6Clr {
    #[doc = "m7_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can1"]
    #[inline(always)]
    pub const fn set_m7_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can2"]
    #[inline(always)]
    pub const fn set_m7_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can3"]
    #[inline(always)]
    pub const fn set_m7_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared6Clr {
    #[inline(always)]
    fn default() -> GprShared6Clr {
        GprShared6Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6Clr")
            .field("m7_mask_tpm6", &self.m7_mask_tpm6())
            .field("m7_mask_gpt1", &self.m7_mask_gpt1())
            .field("m7_mask_gpt2", &self.m7_mask_gpt2())
            .field("m7_mask_can1", &self.m7_mask_can1())
            .field("m7_mask_can2", &self.m7_mask_can2())
            .field("m7_mask_can3", &self.m7_mask_can3())
            .field("m7_mask_lpuart1", &self.m7_mask_lpuart1())
            .field("m7_mask_lpuart2", &self.m7_mask_lpuart2())
            .field("m7_mask_lpuart3", &self.m7_mask_lpuart3())
            .field("m7_mask_lpuart4", &self.m7_mask_lpuart4())
            .field("m7_mask_lpuart5", &self.m7_mask_lpuart5())
            .field("m7_mask_lpuart6", &self.m7_mask_lpuart6())
            .field("m7_mask_lpuart7", &self.m7_mask_lpuart7())
            .field("m7_mask_lpuart8", &self.m7_mask_lpuart8())
            .field("m7_mask_lpuart9", &self.m7_mask_lpuart9())
            .field("m7_mask_lpuart10", &self.m7_mask_lpuart10())
            .field("m7_mask_lpuart11", &self.m7_mask_lpuart11())
            .field("m7_mask_lpuart12", &self.m7_mask_lpuart12())
            .field("m7_mask_lpi2c1", &self.m7_mask_lpi2c1())
            .field("m7_mask_lpi2c2", &self.m7_mask_lpi2c2())
            .field("m7_mask_lpi2c3", &self.m7_mask_lpi2c3())
            .field("m7_mask_lpi2c4", &self.m7_mask_lpi2c4())
            .field("m7_mask_lpi2c5", &self.m7_mask_lpi2c5())
            .field("m7_mask_lpi2c6", &self.m7_mask_lpi2c6())
            .field("m7_mask_lpspi1", &self.m7_mask_lpspi1())
            .field("m7_mask_lpspi2", &self.m7_mask_lpspi2())
            .field("m7_mask_lpspi3", &self.m7_mask_lpspi3())
            .field("m7_mask_lpspi4", &self.m7_mask_lpspi4())
            .field("m7_mask_lpspi5", &self.m7_mask_lpspi5())
            .field("m7_mask_lpspi6", &self.m7_mask_lpspi6())
            .field("m7_mask_sinc1", &self.m7_mask_sinc1())
            .field("m7_mask_sinc2", &self.m7_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6Clr {
            m7_mask_tpm6: bool,
            m7_mask_gpt1: bool,
            m7_mask_gpt2: bool,
            m7_mask_can1: bool,
            m7_mask_can2: bool,
            m7_mask_can3: bool,
            m7_mask_lpuart1: bool,
            m7_mask_lpuart2: bool,
            m7_mask_lpuart3: bool,
            m7_mask_lpuart4: bool,
            m7_mask_lpuart5: bool,
            m7_mask_lpuart6: bool,
            m7_mask_lpuart7: bool,
            m7_mask_lpuart8: bool,
            m7_mask_lpuart9: bool,
            m7_mask_lpuart10: bool,
            m7_mask_lpuart11: bool,
            m7_mask_lpuart12: bool,
            m7_mask_lpi2c1: bool,
            m7_mask_lpi2c2: bool,
            m7_mask_lpi2c3: bool,
            m7_mask_lpi2c4: bool,
            m7_mask_lpi2c5: bool,
            m7_mask_lpi2c6: bool,
            m7_mask_lpspi1: bool,
            m7_mask_lpspi2: bool,
            m7_mask_lpspi3: bool,
            m7_mask_lpspi4: bool,
            m7_mask_lpspi5: bool,
            m7_mask_lpspi6: bool,
            m7_mask_sinc1: bool,
            m7_mask_sinc2: bool,
        }
        let proxy = GprShared6Clr {
            m7_mask_tpm6: self.m7_mask_tpm6(),
            m7_mask_gpt1: self.m7_mask_gpt1(),
            m7_mask_gpt2: self.m7_mask_gpt2(),
            m7_mask_can1: self.m7_mask_can1(),
            m7_mask_can2: self.m7_mask_can2(),
            m7_mask_can3: self.m7_mask_can3(),
            m7_mask_lpuart1: self.m7_mask_lpuart1(),
            m7_mask_lpuart2: self.m7_mask_lpuart2(),
            m7_mask_lpuart3: self.m7_mask_lpuart3(),
            m7_mask_lpuart4: self.m7_mask_lpuart4(),
            m7_mask_lpuart5: self.m7_mask_lpuart5(),
            m7_mask_lpuart6: self.m7_mask_lpuart6(),
            m7_mask_lpuart7: self.m7_mask_lpuart7(),
            m7_mask_lpuart8: self.m7_mask_lpuart8(),
            m7_mask_lpuart9: self.m7_mask_lpuart9(),
            m7_mask_lpuart10: self.m7_mask_lpuart10(),
            m7_mask_lpuart11: self.m7_mask_lpuart11(),
            m7_mask_lpuart12: self.m7_mask_lpuart12(),
            m7_mask_lpi2c1: self.m7_mask_lpi2c1(),
            m7_mask_lpi2c2: self.m7_mask_lpi2c2(),
            m7_mask_lpi2c3: self.m7_mask_lpi2c3(),
            m7_mask_lpi2c4: self.m7_mask_lpi2c4(),
            m7_mask_lpi2c5: self.m7_mask_lpi2c5(),
            m7_mask_lpi2c6: self.m7_mask_lpi2c6(),
            m7_mask_lpspi1: self.m7_mask_lpspi1(),
            m7_mask_lpspi2: self.m7_mask_lpspi2(),
            m7_mask_lpspi3: self.m7_mask_lpspi3(),
            m7_mask_lpspi4: self.m7_mask_lpspi4(),
            m7_mask_lpspi5: self.m7_mask_lpspi5(),
            m7_mask_lpspi6: self.m7_mask_lpspi6(),
            m7_mask_sinc1: self.m7_mask_sinc1(),
            m7_mask_sinc2: self.m7_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6Set(pub u32);
impl GprShared6Set {
    #[doc = "m7_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can1"]
    #[inline(always)]
    pub const fn set_m7_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can2"]
    #[inline(always)]
    pub const fn set_m7_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can3"]
    #[inline(always)]
    pub const fn set_m7_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared6Set {
    #[inline(always)]
    fn default() -> GprShared6Set {
        GprShared6Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6Set")
            .field("m7_mask_tpm6", &self.m7_mask_tpm6())
            .field("m7_mask_gpt1", &self.m7_mask_gpt1())
            .field("m7_mask_gpt2", &self.m7_mask_gpt2())
            .field("m7_mask_can1", &self.m7_mask_can1())
            .field("m7_mask_can2", &self.m7_mask_can2())
            .field("m7_mask_can3", &self.m7_mask_can3())
            .field("m7_mask_lpuart1", &self.m7_mask_lpuart1())
            .field("m7_mask_lpuart2", &self.m7_mask_lpuart2())
            .field("m7_mask_lpuart3", &self.m7_mask_lpuart3())
            .field("m7_mask_lpuart4", &self.m7_mask_lpuart4())
            .field("m7_mask_lpuart5", &self.m7_mask_lpuart5())
            .field("m7_mask_lpuart6", &self.m7_mask_lpuart6())
            .field("m7_mask_lpuart7", &self.m7_mask_lpuart7())
            .field("m7_mask_lpuart8", &self.m7_mask_lpuart8())
            .field("m7_mask_lpuart9", &self.m7_mask_lpuart9())
            .field("m7_mask_lpuart10", &self.m7_mask_lpuart10())
            .field("m7_mask_lpuart11", &self.m7_mask_lpuart11())
            .field("m7_mask_lpuart12", &self.m7_mask_lpuart12())
            .field("m7_mask_lpi2c1", &self.m7_mask_lpi2c1())
            .field("m7_mask_lpi2c2", &self.m7_mask_lpi2c2())
            .field("m7_mask_lpi2c3", &self.m7_mask_lpi2c3())
            .field("m7_mask_lpi2c4", &self.m7_mask_lpi2c4())
            .field("m7_mask_lpi2c5", &self.m7_mask_lpi2c5())
            .field("m7_mask_lpi2c6", &self.m7_mask_lpi2c6())
            .field("m7_mask_lpspi1", &self.m7_mask_lpspi1())
            .field("m7_mask_lpspi2", &self.m7_mask_lpspi2())
            .field("m7_mask_lpspi3", &self.m7_mask_lpspi3())
            .field("m7_mask_lpspi4", &self.m7_mask_lpspi4())
            .field("m7_mask_lpspi5", &self.m7_mask_lpspi5())
            .field("m7_mask_lpspi6", &self.m7_mask_lpspi6())
            .field("m7_mask_sinc1", &self.m7_mask_sinc1())
            .field("m7_mask_sinc2", &self.m7_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6Set {
            m7_mask_tpm6: bool,
            m7_mask_gpt1: bool,
            m7_mask_gpt2: bool,
            m7_mask_can1: bool,
            m7_mask_can2: bool,
            m7_mask_can3: bool,
            m7_mask_lpuart1: bool,
            m7_mask_lpuart2: bool,
            m7_mask_lpuart3: bool,
            m7_mask_lpuart4: bool,
            m7_mask_lpuart5: bool,
            m7_mask_lpuart6: bool,
            m7_mask_lpuart7: bool,
            m7_mask_lpuart8: bool,
            m7_mask_lpuart9: bool,
            m7_mask_lpuart10: bool,
            m7_mask_lpuart11: bool,
            m7_mask_lpuart12: bool,
            m7_mask_lpi2c1: bool,
            m7_mask_lpi2c2: bool,
            m7_mask_lpi2c3: bool,
            m7_mask_lpi2c4: bool,
            m7_mask_lpi2c5: bool,
            m7_mask_lpi2c6: bool,
            m7_mask_lpspi1: bool,
            m7_mask_lpspi2: bool,
            m7_mask_lpspi3: bool,
            m7_mask_lpspi4: bool,
            m7_mask_lpspi5: bool,
            m7_mask_lpspi6: bool,
            m7_mask_sinc1: bool,
            m7_mask_sinc2: bool,
        }
        let proxy = GprShared6Set {
            m7_mask_tpm6: self.m7_mask_tpm6(),
            m7_mask_gpt1: self.m7_mask_gpt1(),
            m7_mask_gpt2: self.m7_mask_gpt2(),
            m7_mask_can1: self.m7_mask_can1(),
            m7_mask_can2: self.m7_mask_can2(),
            m7_mask_can3: self.m7_mask_can3(),
            m7_mask_lpuart1: self.m7_mask_lpuart1(),
            m7_mask_lpuart2: self.m7_mask_lpuart2(),
            m7_mask_lpuart3: self.m7_mask_lpuart3(),
            m7_mask_lpuart4: self.m7_mask_lpuart4(),
            m7_mask_lpuart5: self.m7_mask_lpuart5(),
            m7_mask_lpuart6: self.m7_mask_lpuart6(),
            m7_mask_lpuart7: self.m7_mask_lpuart7(),
            m7_mask_lpuart8: self.m7_mask_lpuart8(),
            m7_mask_lpuart9: self.m7_mask_lpuart9(),
            m7_mask_lpuart10: self.m7_mask_lpuart10(),
            m7_mask_lpuart11: self.m7_mask_lpuart11(),
            m7_mask_lpuart12: self.m7_mask_lpuart12(),
            m7_mask_lpi2c1: self.m7_mask_lpi2c1(),
            m7_mask_lpi2c2: self.m7_mask_lpi2c2(),
            m7_mask_lpi2c3: self.m7_mask_lpi2c3(),
            m7_mask_lpi2c4: self.m7_mask_lpi2c4(),
            m7_mask_lpi2c5: self.m7_mask_lpi2c5(),
            m7_mask_lpi2c6: self.m7_mask_lpi2c6(),
            m7_mask_lpspi1: self.m7_mask_lpspi1(),
            m7_mask_lpspi2: self.m7_mask_lpspi2(),
            m7_mask_lpspi3: self.m7_mask_lpspi3(),
            m7_mask_lpspi4: self.m7_mask_lpspi4(),
            m7_mask_lpspi5: self.m7_mask_lpspi5(),
            m7_mask_lpspi6: self.m7_mask_lpspi6(),
            m7_mask_sinc1: self.m7_mask_sinc1(),
            m7_mask_sinc2: self.m7_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared6Tog(pub u32);
impl GprShared6Tog {
    #[doc = "m7_mask_tpm6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_tpm6(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_tpm6"]
    #[inline(always)]
    pub const fn set_m7_mask_tpm6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_gpt1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt1"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_gpt2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_gpt2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_gpt2"]
    #[inline(always)]
    pub const fn set_m7_mask_gpt2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_can1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can1(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can1"]
    #[inline(always)]
    pub const fn set_m7_mask_can1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_can2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can2(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can2"]
    #[inline(always)]
    pub const fn set_m7_mask_can2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_can3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_can3(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_can3"]
    #[inline(always)]
    pub const fn set_m7_mask_can3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m7_mask_lpuart1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart1(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m7_mask_lpuart2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart2(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m7_mask_lpuart3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart3(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m7_mask_lpuart4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart4(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m7_mask_lpuart5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart5(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m7_mask_lpuart6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart6(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m7_mask_lpuart7"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart7(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart7"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart7(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m7_mask_lpuart8"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart8(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart8"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart8(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m7_mask_lpuart9"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart9(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart9"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart9(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m7_mask_lpuart10"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart10(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart10"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart10(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m7_mask_lpuart11"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart11(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart11"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart11(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m7_mask_lpuart12"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpuart12(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpuart12"]
    #[inline(always)]
    pub const fn set_m7_mask_lpuart12(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m7_mask_lpi2c1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c1(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m7_mask_lpi2c2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c2(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m7_mask_lpi2c3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c3(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m7_mask_lpi2c4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c4(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m7_mask_lpi2c5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c5(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m7_mask_lpi2c6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpi2c6(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpi2c6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpi2c6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m7_mask_lpspi1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi1(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi1"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m7_mask_lpspi2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi2(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi2"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m7_mask_lpspi3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi3(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi3"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m7_mask_lpspi4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi4(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi4"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m7_mask_lpspi5"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi5(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi5"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi5(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m7_mask_lpspi6"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_lpspi6(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_lpspi6"]
    #[inline(always)]
    pub const fn set_m7_mask_lpspi6(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m7_mask_sinc1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc1(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc1"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m7_mask_sinc2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc2(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc2"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared6Tog {
    #[inline(always)]
    fn default() -> GprShared6Tog {
        GprShared6Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared6Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared6Tog")
            .field("m7_mask_tpm6", &self.m7_mask_tpm6())
            .field("m7_mask_gpt1", &self.m7_mask_gpt1())
            .field("m7_mask_gpt2", &self.m7_mask_gpt2())
            .field("m7_mask_can1", &self.m7_mask_can1())
            .field("m7_mask_can2", &self.m7_mask_can2())
            .field("m7_mask_can3", &self.m7_mask_can3())
            .field("m7_mask_lpuart1", &self.m7_mask_lpuart1())
            .field("m7_mask_lpuart2", &self.m7_mask_lpuart2())
            .field("m7_mask_lpuart3", &self.m7_mask_lpuart3())
            .field("m7_mask_lpuart4", &self.m7_mask_lpuart4())
            .field("m7_mask_lpuart5", &self.m7_mask_lpuart5())
            .field("m7_mask_lpuart6", &self.m7_mask_lpuart6())
            .field("m7_mask_lpuart7", &self.m7_mask_lpuart7())
            .field("m7_mask_lpuart8", &self.m7_mask_lpuart8())
            .field("m7_mask_lpuart9", &self.m7_mask_lpuart9())
            .field("m7_mask_lpuart10", &self.m7_mask_lpuart10())
            .field("m7_mask_lpuart11", &self.m7_mask_lpuart11())
            .field("m7_mask_lpuart12", &self.m7_mask_lpuart12())
            .field("m7_mask_lpi2c1", &self.m7_mask_lpi2c1())
            .field("m7_mask_lpi2c2", &self.m7_mask_lpi2c2())
            .field("m7_mask_lpi2c3", &self.m7_mask_lpi2c3())
            .field("m7_mask_lpi2c4", &self.m7_mask_lpi2c4())
            .field("m7_mask_lpi2c5", &self.m7_mask_lpi2c5())
            .field("m7_mask_lpi2c6", &self.m7_mask_lpi2c6())
            .field("m7_mask_lpspi1", &self.m7_mask_lpspi1())
            .field("m7_mask_lpspi2", &self.m7_mask_lpspi2())
            .field("m7_mask_lpspi3", &self.m7_mask_lpspi3())
            .field("m7_mask_lpspi4", &self.m7_mask_lpspi4())
            .field("m7_mask_lpspi5", &self.m7_mask_lpspi5())
            .field("m7_mask_lpspi6", &self.m7_mask_lpspi6())
            .field("m7_mask_sinc1", &self.m7_mask_sinc1())
            .field("m7_mask_sinc2", &self.m7_mask_sinc2())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared6Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared6Tog {
            m7_mask_tpm6: bool,
            m7_mask_gpt1: bool,
            m7_mask_gpt2: bool,
            m7_mask_can1: bool,
            m7_mask_can2: bool,
            m7_mask_can3: bool,
            m7_mask_lpuart1: bool,
            m7_mask_lpuart2: bool,
            m7_mask_lpuart3: bool,
            m7_mask_lpuart4: bool,
            m7_mask_lpuart5: bool,
            m7_mask_lpuart6: bool,
            m7_mask_lpuart7: bool,
            m7_mask_lpuart8: bool,
            m7_mask_lpuart9: bool,
            m7_mask_lpuart10: bool,
            m7_mask_lpuart11: bool,
            m7_mask_lpuart12: bool,
            m7_mask_lpi2c1: bool,
            m7_mask_lpi2c2: bool,
            m7_mask_lpi2c3: bool,
            m7_mask_lpi2c4: bool,
            m7_mask_lpi2c5: bool,
            m7_mask_lpi2c6: bool,
            m7_mask_lpspi1: bool,
            m7_mask_lpspi2: bool,
            m7_mask_lpspi3: bool,
            m7_mask_lpspi4: bool,
            m7_mask_lpspi5: bool,
            m7_mask_lpspi6: bool,
            m7_mask_sinc1: bool,
            m7_mask_sinc2: bool,
        }
        let proxy = GprShared6Tog {
            m7_mask_tpm6: self.m7_mask_tpm6(),
            m7_mask_gpt1: self.m7_mask_gpt1(),
            m7_mask_gpt2: self.m7_mask_gpt2(),
            m7_mask_can1: self.m7_mask_can1(),
            m7_mask_can2: self.m7_mask_can2(),
            m7_mask_can3: self.m7_mask_can3(),
            m7_mask_lpuart1: self.m7_mask_lpuart1(),
            m7_mask_lpuart2: self.m7_mask_lpuart2(),
            m7_mask_lpuart3: self.m7_mask_lpuart3(),
            m7_mask_lpuart4: self.m7_mask_lpuart4(),
            m7_mask_lpuart5: self.m7_mask_lpuart5(),
            m7_mask_lpuart6: self.m7_mask_lpuart6(),
            m7_mask_lpuart7: self.m7_mask_lpuart7(),
            m7_mask_lpuart8: self.m7_mask_lpuart8(),
            m7_mask_lpuart9: self.m7_mask_lpuart9(),
            m7_mask_lpuart10: self.m7_mask_lpuart10(),
            m7_mask_lpuart11: self.m7_mask_lpuart11(),
            m7_mask_lpuart12: self.m7_mask_lpuart12(),
            m7_mask_lpi2c1: self.m7_mask_lpi2c1(),
            m7_mask_lpi2c2: self.m7_mask_lpi2c2(),
            m7_mask_lpi2c3: self.m7_mask_lpi2c3(),
            m7_mask_lpi2c4: self.m7_mask_lpi2c4(),
            m7_mask_lpi2c5: self.m7_mask_lpi2c5(),
            m7_mask_lpi2c6: self.m7_mask_lpi2c6(),
            m7_mask_lpspi1: self.m7_mask_lpspi1(),
            m7_mask_lpspi2: self.m7_mask_lpspi2(),
            m7_mask_lpspi3: self.m7_mask_lpspi3(),
            m7_mask_lpspi4: self.m7_mask_lpspi4(),
            m7_mask_lpspi5: self.m7_mask_lpspi5(),
            m7_mask_lpspi6: self.m7_mask_lpspi6(),
            m7_mask_sinc1: self.m7_mask_sinc1(),
            m7_mask_sinc2: self.m7_mask_sinc2(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7(pub u32);
impl GprShared7 {
    #[doc = "m7_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai1"]
    #[inline(always)]
    pub const fn set_m7_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai2"]
    #[inline(always)]
    pub const fn set_m7_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai3"]
    #[inline(always)]
    pub const fn set_m7_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai4"]
    #[inline(always)]
    pub const fn set_m7_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_mic"]
    #[inline(always)]
    pub const fn set_m7_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared7 {
    #[inline(always)]
    fn default() -> GprShared7 {
        GprShared7(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7")
            .field("m7_mask_sinc3", &self.m7_mask_sinc3())
            .field("m7_mask_sai1", &self.m7_mask_sai1())
            .field("m7_mask_sai2", &self.m7_mask_sai2())
            .field("m7_mask_sai3", &self.m7_mask_sai3())
            .field("m7_mask_sai4", &self.m7_mask_sai4())
            .field("m7_mask_mic", &self.m7_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7 {
            m7_mask_sinc3: bool,
            m7_mask_sai1: bool,
            m7_mask_sai2: bool,
            m7_mask_sai3: bool,
            m7_mask_sai4: bool,
            m7_mask_mic: bool,
        }
        let proxy = GprShared7 {
            m7_mask_sinc3: self.m7_mask_sinc3(),
            m7_mask_sai1: self.m7_mask_sai1(),
            m7_mask_sai2: self.m7_mask_sai2(),
            m7_mask_sai3: self.m7_mask_sai3(),
            m7_mask_sai4: self.m7_mask_sai4(),
            m7_mask_mic: self.m7_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7Authen(pub u32);
impl GprShared7Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared7AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared7AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared7AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared7AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared7AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared7AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared7Authen {
    #[inline(always)]
    fn default() -> GprShared7Authen {
        GprShared7Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7Authen {
            tz_user: super::vals::GprShared7AuthenTzUser,
            tz_ns: super::vals::GprShared7AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared7Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7AuthenClr(pub u32);
impl GprShared7AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared7AuthenClr {
    #[inline(always)]
    fn default() -> GprShared7AuthenClr {
        GprShared7AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared7AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7AuthenSet(pub u32);
impl GprShared7AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared7AuthenSet {
    #[inline(always)]
    fn default() -> GprShared7AuthenSet {
        GprShared7AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared7AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7AuthenTog(pub u32);
impl GprShared7AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared7AuthenTog {
    #[inline(always)]
    fn default() -> GprShared7AuthenTog {
        GprShared7AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared7AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7Clr(pub u32);
impl GprShared7Clr {
    #[doc = "m7_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai1"]
    #[inline(always)]
    pub const fn set_m7_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai2"]
    #[inline(always)]
    pub const fn set_m7_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai3"]
    #[inline(always)]
    pub const fn set_m7_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai4"]
    #[inline(always)]
    pub const fn set_m7_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_mic"]
    #[inline(always)]
    pub const fn set_m7_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared7Clr {
    #[inline(always)]
    fn default() -> GprShared7Clr {
        GprShared7Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7Clr")
            .field("m7_mask_sinc3", &self.m7_mask_sinc3())
            .field("m7_mask_sai1", &self.m7_mask_sai1())
            .field("m7_mask_sai2", &self.m7_mask_sai2())
            .field("m7_mask_sai3", &self.m7_mask_sai3())
            .field("m7_mask_sai4", &self.m7_mask_sai4())
            .field("m7_mask_mic", &self.m7_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7Clr {
            m7_mask_sinc3: bool,
            m7_mask_sai1: bool,
            m7_mask_sai2: bool,
            m7_mask_sai3: bool,
            m7_mask_sai4: bool,
            m7_mask_mic: bool,
        }
        let proxy = GprShared7Clr {
            m7_mask_sinc3: self.m7_mask_sinc3(),
            m7_mask_sai1: self.m7_mask_sai1(),
            m7_mask_sai2: self.m7_mask_sai2(),
            m7_mask_sai3: self.m7_mask_sai3(),
            m7_mask_sai4: self.m7_mask_sai4(),
            m7_mask_mic: self.m7_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7Set(pub u32);
impl GprShared7Set {
    #[doc = "m7_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai1"]
    #[inline(always)]
    pub const fn set_m7_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai2"]
    #[inline(always)]
    pub const fn set_m7_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai3"]
    #[inline(always)]
    pub const fn set_m7_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai4"]
    #[inline(always)]
    pub const fn set_m7_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_mic"]
    #[inline(always)]
    pub const fn set_m7_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared7Set {
    #[inline(always)]
    fn default() -> GprShared7Set {
        GprShared7Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7Set")
            .field("m7_mask_sinc3", &self.m7_mask_sinc3())
            .field("m7_mask_sai1", &self.m7_mask_sai1())
            .field("m7_mask_sai2", &self.m7_mask_sai2())
            .field("m7_mask_sai3", &self.m7_mask_sai3())
            .field("m7_mask_sai4", &self.m7_mask_sai4())
            .field("m7_mask_mic", &self.m7_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7Set {
            m7_mask_sinc3: bool,
            m7_mask_sai1: bool,
            m7_mask_sai2: bool,
            m7_mask_sai3: bool,
            m7_mask_sai4: bool,
            m7_mask_mic: bool,
        }
        let proxy = GprShared7Set {
            m7_mask_sinc3: self.m7_mask_sinc3(),
            m7_mask_sai1: self.m7_mask_sai1(),
            m7_mask_sai2: self.m7_mask_sai2(),
            m7_mask_sai3: self.m7_mask_sai3(),
            m7_mask_sai4: self.m7_mask_sai4(),
            m7_mask_mic: self.m7_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared7Tog(pub u32);
impl GprShared7Tog {
    #[doc = "m7_mask_sinc3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sinc3(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sinc3"]
    #[inline(always)]
    pub const fn set_m7_mask_sinc3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m7_mask_sai1"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai1(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai1"]
    #[inline(always)]
    pub const fn set_m7_mask_sai1(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m7_mask_sai2"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai2(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai2"]
    #[inline(always)]
    pub const fn set_m7_mask_sai2(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m7_mask_sai3"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai3(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai3"]
    #[inline(always)]
    pub const fn set_m7_mask_sai3(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m7_mask_sai4"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_sai4(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_sai4"]
    #[inline(always)]
    pub const fn set_m7_mask_sai4(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m7_mask_mic"]
    #[must_use]
    #[inline(always)]
    pub const fn m7_mask_mic(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m7_mask_mic"]
    #[inline(always)]
    pub const fn set_m7_mask_mic(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
}
impl Default for GprShared7Tog {
    #[inline(always)]
    fn default() -> GprShared7Tog {
        GprShared7Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared7Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared7Tog")
            .field("m7_mask_sinc3", &self.m7_mask_sinc3())
            .field("m7_mask_sai1", &self.m7_mask_sai1())
            .field("m7_mask_sai2", &self.m7_mask_sai2())
            .field("m7_mask_sai3", &self.m7_mask_sai3())
            .field("m7_mask_sai4", &self.m7_mask_sai4())
            .field("m7_mask_mic", &self.m7_mask_mic())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared7Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared7Tog {
            m7_mask_sinc3: bool,
            m7_mask_sai1: bool,
            m7_mask_sai2: bool,
            m7_mask_sai3: bool,
            m7_mask_sai4: bool,
            m7_mask_mic: bool,
        }
        let proxy = GprShared7Tog {
            m7_mask_sinc3: self.m7_mask_sinc3(),
            m7_mask_sai1: self.m7_mask_sai1(),
            m7_mask_sai2: self.m7_mask_sai2(),
            m7_mask_sai3: self.m7_mask_sai3(),
            m7_mask_sai4: self.m7_mask_sai4(),
            m7_mask_mic: self.m7_mask_mic(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8(pub u32);
impl GprShared8 {
    #[doc = "m33_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared8 {
    #[inline(always)]
    fn default() -> GprShared8 {
        GprShared8(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8")
            .field("m33_cm7_ipg_stop", &self.m33_cm7_ipg_stop())
            .field("m33_cm33_ipg_stop", &self.m33_cm33_ipg_stop())
            .field("m33_edma3_ipg_stop", &self.m33_edma3_ipg_stop())
            .field("m33_edma4_ipg_stop", &self.m33_edma4_ipg_stop())
            .field("m33_netc_ipg_stop", &self.m33_netc_ipg_stop())
            .field("m33_sim_aon_ipg_stop", &self.m33_sim_aon_ipg_stop())
            .field("m33_adc1_ipg_stop", &self.m33_adc1_ipg_stop())
            .field("m33_adc2_ipg_stop", &self.m33_adc2_ipg_stop())
            .field("m33_flexspi1_ipg_stop", &self.m33_flexspi1_ipg_stop())
            .field("m33_flexspi2_ipg_stop", &self.m33_flexspi2_ipg_stop())
            .field("m33_trdc_ipg_stop", &self.m33_trdc_ipg_stop())
            .field("m33_semc_ipg_stop", &self.m33_semc_ipg_stop())
            .field("m33_iee_ipg_stop", &self.m33_iee_ipg_stop())
            .field("m33_gpio1_ipg_stop", &self.m33_gpio1_ipg_stop())
            .field("m33_gpio2_ipg_stop", &self.m33_gpio2_ipg_stop())
            .field("m33_gpio3_ipg_stop", &self.m33_gpio3_ipg_stop())
            .field("m33_gpio4_ipg_stop", &self.m33_gpio4_ipg_stop())
            .field("m33_gpio5_ipg_stop", &self.m33_gpio5_ipg_stop())
            .field("m33_gpio6_ipg_stop", &self.m33_gpio6_ipg_stop())
            .field("m33_flexio1_ipg_stop", &self.m33_flexio1_ipg_stop())
            .field("m33_flexio2_ipg_stop", &self.m33_flexio2_ipg_stop())
            .field("m33_can1_ipg_stop", &self.m33_can1_ipg_stop())
            .field("m33_can2_ipg_stop", &self.m33_can2_ipg_stop())
            .field("m33_can3_ipg_stop", &self.m33_can3_ipg_stop())
            .field("m33_lpuart1_ipg_stop", &self.m33_lpuart1_ipg_stop())
            .field("m33_lpuart2_ipg_stop", &self.m33_lpuart2_ipg_stop())
            .field("m33_lpuart3_ipg_stop", &self.m33_lpuart3_ipg_stop())
            .field("m33_lpuart4_ipg_stop", &self.m33_lpuart4_ipg_stop())
            .field("m33_lpuart5_ipg_stop", &self.m33_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8 {
            m33_cm7_ipg_stop: bool,
            m33_cm33_ipg_stop: bool,
            m33_edma3_ipg_stop: bool,
            m33_edma4_ipg_stop: bool,
            m33_netc_ipg_stop: bool,
            m33_sim_aon_ipg_stop: bool,
            m33_adc1_ipg_stop: bool,
            m33_adc2_ipg_stop: bool,
            m33_flexspi1_ipg_stop: bool,
            m33_flexspi2_ipg_stop: bool,
            m33_trdc_ipg_stop: bool,
            m33_semc_ipg_stop: bool,
            m33_iee_ipg_stop: bool,
            m33_gpio1_ipg_stop: bool,
            m33_gpio2_ipg_stop: bool,
            m33_gpio3_ipg_stop: bool,
            m33_gpio4_ipg_stop: bool,
            m33_gpio5_ipg_stop: bool,
            m33_gpio6_ipg_stop: bool,
            m33_flexio1_ipg_stop: bool,
            m33_flexio2_ipg_stop: bool,
            m33_can1_ipg_stop: bool,
            m33_can2_ipg_stop: bool,
            m33_can3_ipg_stop: bool,
            m33_lpuart1_ipg_stop: bool,
            m33_lpuart2_ipg_stop: bool,
            m33_lpuart3_ipg_stop: bool,
            m33_lpuart4_ipg_stop: bool,
            m33_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared8 {
            m33_cm7_ipg_stop: self.m33_cm7_ipg_stop(),
            m33_cm33_ipg_stop: self.m33_cm33_ipg_stop(),
            m33_edma3_ipg_stop: self.m33_edma3_ipg_stop(),
            m33_edma4_ipg_stop: self.m33_edma4_ipg_stop(),
            m33_netc_ipg_stop: self.m33_netc_ipg_stop(),
            m33_sim_aon_ipg_stop: self.m33_sim_aon_ipg_stop(),
            m33_adc1_ipg_stop: self.m33_adc1_ipg_stop(),
            m33_adc2_ipg_stop: self.m33_adc2_ipg_stop(),
            m33_flexspi1_ipg_stop: self.m33_flexspi1_ipg_stop(),
            m33_flexspi2_ipg_stop: self.m33_flexspi2_ipg_stop(),
            m33_trdc_ipg_stop: self.m33_trdc_ipg_stop(),
            m33_semc_ipg_stop: self.m33_semc_ipg_stop(),
            m33_iee_ipg_stop: self.m33_iee_ipg_stop(),
            m33_gpio1_ipg_stop: self.m33_gpio1_ipg_stop(),
            m33_gpio2_ipg_stop: self.m33_gpio2_ipg_stop(),
            m33_gpio3_ipg_stop: self.m33_gpio3_ipg_stop(),
            m33_gpio4_ipg_stop: self.m33_gpio4_ipg_stop(),
            m33_gpio5_ipg_stop: self.m33_gpio5_ipg_stop(),
            m33_gpio6_ipg_stop: self.m33_gpio6_ipg_stop(),
            m33_flexio1_ipg_stop: self.m33_flexio1_ipg_stop(),
            m33_flexio2_ipg_stop: self.m33_flexio2_ipg_stop(),
            m33_can1_ipg_stop: self.m33_can1_ipg_stop(),
            m33_can2_ipg_stop: self.m33_can2_ipg_stop(),
            m33_can3_ipg_stop: self.m33_can3_ipg_stop(),
            m33_lpuart1_ipg_stop: self.m33_lpuart1_ipg_stop(),
            m33_lpuart2_ipg_stop: self.m33_lpuart2_ipg_stop(),
            m33_lpuart3_ipg_stop: self.m33_lpuart3_ipg_stop(),
            m33_lpuart4_ipg_stop: self.m33_lpuart4_ipg_stop(),
            m33_lpuart5_ipg_stop: self.m33_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8Authen(pub u32);
impl GprShared8Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared8AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared8AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared8AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared8AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared8AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared8AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared8Authen {
    #[inline(always)]
    fn default() -> GprShared8Authen {
        GprShared8Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8Authen {
            tz_user: super::vals::GprShared8AuthenTzUser,
            tz_ns: super::vals::GprShared8AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared8Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8AuthenClr(pub u32);
impl GprShared8AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared8AuthenClr {
    #[inline(always)]
    fn default() -> GprShared8AuthenClr {
        GprShared8AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared8AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8AuthenSet(pub u32);
impl GprShared8AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared8AuthenSet {
    #[inline(always)]
    fn default() -> GprShared8AuthenSet {
        GprShared8AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared8AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8AuthenTog(pub u32);
impl GprShared8AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared8AuthenTog {
    #[inline(always)]
    fn default() -> GprShared8AuthenTog {
        GprShared8AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared8AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8Clr(pub u32);
impl GprShared8Clr {
    #[doc = "m33_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared8Clr {
    #[inline(always)]
    fn default() -> GprShared8Clr {
        GprShared8Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8Clr")
            .field("m33_cm7_ipg_stop", &self.m33_cm7_ipg_stop())
            .field("m33_cm33_ipg_stop", &self.m33_cm33_ipg_stop())
            .field("m33_edma3_ipg_stop", &self.m33_edma3_ipg_stop())
            .field("m33_edma4_ipg_stop", &self.m33_edma4_ipg_stop())
            .field("m33_netc_ipg_stop", &self.m33_netc_ipg_stop())
            .field("m33_sim_aon_ipg_stop", &self.m33_sim_aon_ipg_stop())
            .field("m33_adc1_ipg_stop", &self.m33_adc1_ipg_stop())
            .field("m33_adc2_ipg_stop", &self.m33_adc2_ipg_stop())
            .field("m33_flexspi1_ipg_stop", &self.m33_flexspi1_ipg_stop())
            .field("m33_flexspi2_ipg_stop", &self.m33_flexspi2_ipg_stop())
            .field("m33_trdc_ipg_stop", &self.m33_trdc_ipg_stop())
            .field("m33_semc_ipg_stop", &self.m33_semc_ipg_stop())
            .field("m33_iee_ipg_stop", &self.m33_iee_ipg_stop())
            .field("m33_gpio1_ipg_stop", &self.m33_gpio1_ipg_stop())
            .field("m33_gpio2_ipg_stop", &self.m33_gpio2_ipg_stop())
            .field("m33_gpio3_ipg_stop", &self.m33_gpio3_ipg_stop())
            .field("m33_gpio4_ipg_stop", &self.m33_gpio4_ipg_stop())
            .field("m33_gpio5_ipg_stop", &self.m33_gpio5_ipg_stop())
            .field("m33_gpio6_ipg_stop", &self.m33_gpio6_ipg_stop())
            .field("m33_flexio1_ipg_stop", &self.m33_flexio1_ipg_stop())
            .field("m33_flexio2_ipg_stop", &self.m33_flexio2_ipg_stop())
            .field("m33_can1_ipg_stop", &self.m33_can1_ipg_stop())
            .field("m33_can2_ipg_stop", &self.m33_can2_ipg_stop())
            .field("m33_can3_ipg_stop", &self.m33_can3_ipg_stop())
            .field("m33_lpuart1_ipg_stop", &self.m33_lpuart1_ipg_stop())
            .field("m33_lpuart2_ipg_stop", &self.m33_lpuart2_ipg_stop())
            .field("m33_lpuart3_ipg_stop", &self.m33_lpuart3_ipg_stop())
            .field("m33_lpuart4_ipg_stop", &self.m33_lpuart4_ipg_stop())
            .field("m33_lpuart5_ipg_stop", &self.m33_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8Clr {
            m33_cm7_ipg_stop: bool,
            m33_cm33_ipg_stop: bool,
            m33_edma3_ipg_stop: bool,
            m33_edma4_ipg_stop: bool,
            m33_netc_ipg_stop: bool,
            m33_sim_aon_ipg_stop: bool,
            m33_adc1_ipg_stop: bool,
            m33_adc2_ipg_stop: bool,
            m33_flexspi1_ipg_stop: bool,
            m33_flexspi2_ipg_stop: bool,
            m33_trdc_ipg_stop: bool,
            m33_semc_ipg_stop: bool,
            m33_iee_ipg_stop: bool,
            m33_gpio1_ipg_stop: bool,
            m33_gpio2_ipg_stop: bool,
            m33_gpio3_ipg_stop: bool,
            m33_gpio4_ipg_stop: bool,
            m33_gpio5_ipg_stop: bool,
            m33_gpio6_ipg_stop: bool,
            m33_flexio1_ipg_stop: bool,
            m33_flexio2_ipg_stop: bool,
            m33_can1_ipg_stop: bool,
            m33_can2_ipg_stop: bool,
            m33_can3_ipg_stop: bool,
            m33_lpuart1_ipg_stop: bool,
            m33_lpuart2_ipg_stop: bool,
            m33_lpuart3_ipg_stop: bool,
            m33_lpuart4_ipg_stop: bool,
            m33_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared8Clr {
            m33_cm7_ipg_stop: self.m33_cm7_ipg_stop(),
            m33_cm33_ipg_stop: self.m33_cm33_ipg_stop(),
            m33_edma3_ipg_stop: self.m33_edma3_ipg_stop(),
            m33_edma4_ipg_stop: self.m33_edma4_ipg_stop(),
            m33_netc_ipg_stop: self.m33_netc_ipg_stop(),
            m33_sim_aon_ipg_stop: self.m33_sim_aon_ipg_stop(),
            m33_adc1_ipg_stop: self.m33_adc1_ipg_stop(),
            m33_adc2_ipg_stop: self.m33_adc2_ipg_stop(),
            m33_flexspi1_ipg_stop: self.m33_flexspi1_ipg_stop(),
            m33_flexspi2_ipg_stop: self.m33_flexspi2_ipg_stop(),
            m33_trdc_ipg_stop: self.m33_trdc_ipg_stop(),
            m33_semc_ipg_stop: self.m33_semc_ipg_stop(),
            m33_iee_ipg_stop: self.m33_iee_ipg_stop(),
            m33_gpio1_ipg_stop: self.m33_gpio1_ipg_stop(),
            m33_gpio2_ipg_stop: self.m33_gpio2_ipg_stop(),
            m33_gpio3_ipg_stop: self.m33_gpio3_ipg_stop(),
            m33_gpio4_ipg_stop: self.m33_gpio4_ipg_stop(),
            m33_gpio5_ipg_stop: self.m33_gpio5_ipg_stop(),
            m33_gpio6_ipg_stop: self.m33_gpio6_ipg_stop(),
            m33_flexio1_ipg_stop: self.m33_flexio1_ipg_stop(),
            m33_flexio2_ipg_stop: self.m33_flexio2_ipg_stop(),
            m33_can1_ipg_stop: self.m33_can1_ipg_stop(),
            m33_can2_ipg_stop: self.m33_can2_ipg_stop(),
            m33_can3_ipg_stop: self.m33_can3_ipg_stop(),
            m33_lpuart1_ipg_stop: self.m33_lpuart1_ipg_stop(),
            m33_lpuart2_ipg_stop: self.m33_lpuart2_ipg_stop(),
            m33_lpuart3_ipg_stop: self.m33_lpuart3_ipg_stop(),
            m33_lpuart4_ipg_stop: self.m33_lpuart4_ipg_stop(),
            m33_lpuart5_ipg_stop: self.m33_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8Set(pub u32);
impl GprShared8Set {
    #[doc = "m33_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared8Set {
    #[inline(always)]
    fn default() -> GprShared8Set {
        GprShared8Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8Set")
            .field("m33_cm7_ipg_stop", &self.m33_cm7_ipg_stop())
            .field("m33_cm33_ipg_stop", &self.m33_cm33_ipg_stop())
            .field("m33_edma3_ipg_stop", &self.m33_edma3_ipg_stop())
            .field("m33_edma4_ipg_stop", &self.m33_edma4_ipg_stop())
            .field("m33_netc_ipg_stop", &self.m33_netc_ipg_stop())
            .field("m33_sim_aon_ipg_stop", &self.m33_sim_aon_ipg_stop())
            .field("m33_adc1_ipg_stop", &self.m33_adc1_ipg_stop())
            .field("m33_adc2_ipg_stop", &self.m33_adc2_ipg_stop())
            .field("m33_flexspi1_ipg_stop", &self.m33_flexspi1_ipg_stop())
            .field("m33_flexspi2_ipg_stop", &self.m33_flexspi2_ipg_stop())
            .field("m33_trdc_ipg_stop", &self.m33_trdc_ipg_stop())
            .field("m33_semc_ipg_stop", &self.m33_semc_ipg_stop())
            .field("m33_iee_ipg_stop", &self.m33_iee_ipg_stop())
            .field("m33_gpio1_ipg_stop", &self.m33_gpio1_ipg_stop())
            .field("m33_gpio2_ipg_stop", &self.m33_gpio2_ipg_stop())
            .field("m33_gpio3_ipg_stop", &self.m33_gpio3_ipg_stop())
            .field("m33_gpio4_ipg_stop", &self.m33_gpio4_ipg_stop())
            .field("m33_gpio5_ipg_stop", &self.m33_gpio5_ipg_stop())
            .field("m33_gpio6_ipg_stop", &self.m33_gpio6_ipg_stop())
            .field("m33_flexio1_ipg_stop", &self.m33_flexio1_ipg_stop())
            .field("m33_flexio2_ipg_stop", &self.m33_flexio2_ipg_stop())
            .field("m33_can1_ipg_stop", &self.m33_can1_ipg_stop())
            .field("m33_can2_ipg_stop", &self.m33_can2_ipg_stop())
            .field("m33_can3_ipg_stop", &self.m33_can3_ipg_stop())
            .field("m33_lpuart1_ipg_stop", &self.m33_lpuart1_ipg_stop())
            .field("m33_lpuart2_ipg_stop", &self.m33_lpuart2_ipg_stop())
            .field("m33_lpuart3_ipg_stop", &self.m33_lpuart3_ipg_stop())
            .field("m33_lpuart4_ipg_stop", &self.m33_lpuart4_ipg_stop())
            .field("m33_lpuart5_ipg_stop", &self.m33_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8Set {
            m33_cm7_ipg_stop: bool,
            m33_cm33_ipg_stop: bool,
            m33_edma3_ipg_stop: bool,
            m33_edma4_ipg_stop: bool,
            m33_netc_ipg_stop: bool,
            m33_sim_aon_ipg_stop: bool,
            m33_adc1_ipg_stop: bool,
            m33_adc2_ipg_stop: bool,
            m33_flexspi1_ipg_stop: bool,
            m33_flexspi2_ipg_stop: bool,
            m33_trdc_ipg_stop: bool,
            m33_semc_ipg_stop: bool,
            m33_iee_ipg_stop: bool,
            m33_gpio1_ipg_stop: bool,
            m33_gpio2_ipg_stop: bool,
            m33_gpio3_ipg_stop: bool,
            m33_gpio4_ipg_stop: bool,
            m33_gpio5_ipg_stop: bool,
            m33_gpio6_ipg_stop: bool,
            m33_flexio1_ipg_stop: bool,
            m33_flexio2_ipg_stop: bool,
            m33_can1_ipg_stop: bool,
            m33_can2_ipg_stop: bool,
            m33_can3_ipg_stop: bool,
            m33_lpuart1_ipg_stop: bool,
            m33_lpuart2_ipg_stop: bool,
            m33_lpuart3_ipg_stop: bool,
            m33_lpuart4_ipg_stop: bool,
            m33_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared8Set {
            m33_cm7_ipg_stop: self.m33_cm7_ipg_stop(),
            m33_cm33_ipg_stop: self.m33_cm33_ipg_stop(),
            m33_edma3_ipg_stop: self.m33_edma3_ipg_stop(),
            m33_edma4_ipg_stop: self.m33_edma4_ipg_stop(),
            m33_netc_ipg_stop: self.m33_netc_ipg_stop(),
            m33_sim_aon_ipg_stop: self.m33_sim_aon_ipg_stop(),
            m33_adc1_ipg_stop: self.m33_adc1_ipg_stop(),
            m33_adc2_ipg_stop: self.m33_adc2_ipg_stop(),
            m33_flexspi1_ipg_stop: self.m33_flexspi1_ipg_stop(),
            m33_flexspi2_ipg_stop: self.m33_flexspi2_ipg_stop(),
            m33_trdc_ipg_stop: self.m33_trdc_ipg_stop(),
            m33_semc_ipg_stop: self.m33_semc_ipg_stop(),
            m33_iee_ipg_stop: self.m33_iee_ipg_stop(),
            m33_gpio1_ipg_stop: self.m33_gpio1_ipg_stop(),
            m33_gpio2_ipg_stop: self.m33_gpio2_ipg_stop(),
            m33_gpio3_ipg_stop: self.m33_gpio3_ipg_stop(),
            m33_gpio4_ipg_stop: self.m33_gpio4_ipg_stop(),
            m33_gpio5_ipg_stop: self.m33_gpio5_ipg_stop(),
            m33_gpio6_ipg_stop: self.m33_gpio6_ipg_stop(),
            m33_flexio1_ipg_stop: self.m33_flexio1_ipg_stop(),
            m33_flexio2_ipg_stop: self.m33_flexio2_ipg_stop(),
            m33_can1_ipg_stop: self.m33_can1_ipg_stop(),
            m33_can2_ipg_stop: self.m33_can2_ipg_stop(),
            m33_can3_ipg_stop: self.m33_can3_ipg_stop(),
            m33_lpuart1_ipg_stop: self.m33_lpuart1_ipg_stop(),
            m33_lpuart2_ipg_stop: self.m33_lpuart2_ipg_stop(),
            m33_lpuart3_ipg_stop: self.m33_lpuart3_ipg_stop(),
            m33_lpuart4_ipg_stop: self.m33_lpuart4_ipg_stop(),
            m33_lpuart5_ipg_stop: self.m33_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared8Tog(pub u32);
impl GprShared8Tog {
    #[doc = "m33_cm7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_cm33_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_cm33_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_cm33_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_edma4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_edma4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_edma4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_netc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_netc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_netc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_netc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sim_aon_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sim_aon_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sim_aon_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_adc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_adc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_adc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_trdc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_trdc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_trdc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_semc_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_semc_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_semc_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_semc_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_iee_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_iee_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_iee_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_iee_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_gpio6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_gpio6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_gpio6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_flexio2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_flexio2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_flexio2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_can1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_can2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_can3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_can3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_can3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_can3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 27usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 28usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 30usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for GprShared8Tog {
    #[inline(always)]
    fn default() -> GprShared8Tog {
        GprShared8Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared8Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared8Tog")
            .field("m33_cm7_ipg_stop", &self.m33_cm7_ipg_stop())
            .field("m33_cm33_ipg_stop", &self.m33_cm33_ipg_stop())
            .field("m33_edma3_ipg_stop", &self.m33_edma3_ipg_stop())
            .field("m33_edma4_ipg_stop", &self.m33_edma4_ipg_stop())
            .field("m33_netc_ipg_stop", &self.m33_netc_ipg_stop())
            .field("m33_sim_aon_ipg_stop", &self.m33_sim_aon_ipg_stop())
            .field("m33_adc1_ipg_stop", &self.m33_adc1_ipg_stop())
            .field("m33_adc2_ipg_stop", &self.m33_adc2_ipg_stop())
            .field("m33_flexspi1_ipg_stop", &self.m33_flexspi1_ipg_stop())
            .field("m33_flexspi2_ipg_stop", &self.m33_flexspi2_ipg_stop())
            .field("m33_trdc_ipg_stop", &self.m33_trdc_ipg_stop())
            .field("m33_semc_ipg_stop", &self.m33_semc_ipg_stop())
            .field("m33_iee_ipg_stop", &self.m33_iee_ipg_stop())
            .field("m33_gpio1_ipg_stop", &self.m33_gpio1_ipg_stop())
            .field("m33_gpio2_ipg_stop", &self.m33_gpio2_ipg_stop())
            .field("m33_gpio3_ipg_stop", &self.m33_gpio3_ipg_stop())
            .field("m33_gpio4_ipg_stop", &self.m33_gpio4_ipg_stop())
            .field("m33_gpio5_ipg_stop", &self.m33_gpio5_ipg_stop())
            .field("m33_gpio6_ipg_stop", &self.m33_gpio6_ipg_stop())
            .field("m33_flexio1_ipg_stop", &self.m33_flexio1_ipg_stop())
            .field("m33_flexio2_ipg_stop", &self.m33_flexio2_ipg_stop())
            .field("m33_can1_ipg_stop", &self.m33_can1_ipg_stop())
            .field("m33_can2_ipg_stop", &self.m33_can2_ipg_stop())
            .field("m33_can3_ipg_stop", &self.m33_can3_ipg_stop())
            .field("m33_lpuart1_ipg_stop", &self.m33_lpuart1_ipg_stop())
            .field("m33_lpuart2_ipg_stop", &self.m33_lpuart2_ipg_stop())
            .field("m33_lpuart3_ipg_stop", &self.m33_lpuart3_ipg_stop())
            .field("m33_lpuart4_ipg_stop", &self.m33_lpuart4_ipg_stop())
            .field("m33_lpuart5_ipg_stop", &self.m33_lpuart5_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared8Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared8Tog {
            m33_cm7_ipg_stop: bool,
            m33_cm33_ipg_stop: bool,
            m33_edma3_ipg_stop: bool,
            m33_edma4_ipg_stop: bool,
            m33_netc_ipg_stop: bool,
            m33_sim_aon_ipg_stop: bool,
            m33_adc1_ipg_stop: bool,
            m33_adc2_ipg_stop: bool,
            m33_flexspi1_ipg_stop: bool,
            m33_flexspi2_ipg_stop: bool,
            m33_trdc_ipg_stop: bool,
            m33_semc_ipg_stop: bool,
            m33_iee_ipg_stop: bool,
            m33_gpio1_ipg_stop: bool,
            m33_gpio2_ipg_stop: bool,
            m33_gpio3_ipg_stop: bool,
            m33_gpio4_ipg_stop: bool,
            m33_gpio5_ipg_stop: bool,
            m33_gpio6_ipg_stop: bool,
            m33_flexio1_ipg_stop: bool,
            m33_flexio2_ipg_stop: bool,
            m33_can1_ipg_stop: bool,
            m33_can2_ipg_stop: bool,
            m33_can3_ipg_stop: bool,
            m33_lpuart1_ipg_stop: bool,
            m33_lpuart2_ipg_stop: bool,
            m33_lpuart3_ipg_stop: bool,
            m33_lpuart4_ipg_stop: bool,
            m33_lpuart5_ipg_stop: bool,
        }
        let proxy = GprShared8Tog {
            m33_cm7_ipg_stop: self.m33_cm7_ipg_stop(),
            m33_cm33_ipg_stop: self.m33_cm33_ipg_stop(),
            m33_edma3_ipg_stop: self.m33_edma3_ipg_stop(),
            m33_edma4_ipg_stop: self.m33_edma4_ipg_stop(),
            m33_netc_ipg_stop: self.m33_netc_ipg_stop(),
            m33_sim_aon_ipg_stop: self.m33_sim_aon_ipg_stop(),
            m33_adc1_ipg_stop: self.m33_adc1_ipg_stop(),
            m33_adc2_ipg_stop: self.m33_adc2_ipg_stop(),
            m33_flexspi1_ipg_stop: self.m33_flexspi1_ipg_stop(),
            m33_flexspi2_ipg_stop: self.m33_flexspi2_ipg_stop(),
            m33_trdc_ipg_stop: self.m33_trdc_ipg_stop(),
            m33_semc_ipg_stop: self.m33_semc_ipg_stop(),
            m33_iee_ipg_stop: self.m33_iee_ipg_stop(),
            m33_gpio1_ipg_stop: self.m33_gpio1_ipg_stop(),
            m33_gpio2_ipg_stop: self.m33_gpio2_ipg_stop(),
            m33_gpio3_ipg_stop: self.m33_gpio3_ipg_stop(),
            m33_gpio4_ipg_stop: self.m33_gpio4_ipg_stop(),
            m33_gpio5_ipg_stop: self.m33_gpio5_ipg_stop(),
            m33_gpio6_ipg_stop: self.m33_gpio6_ipg_stop(),
            m33_flexio1_ipg_stop: self.m33_flexio1_ipg_stop(),
            m33_flexio2_ipg_stop: self.m33_flexio2_ipg_stop(),
            m33_can1_ipg_stop: self.m33_can1_ipg_stop(),
            m33_can2_ipg_stop: self.m33_can2_ipg_stop(),
            m33_can3_ipg_stop: self.m33_can3_ipg_stop(),
            m33_lpuart1_ipg_stop: self.m33_lpuart1_ipg_stop(),
            m33_lpuart2_ipg_stop: self.m33_lpuart2_ipg_stop(),
            m33_lpuart3_ipg_stop: self.m33_lpuart3_ipg_stop(),
            m33_lpuart4_ipg_stop: self.m33_lpuart4_ipg_stop(),
            m33_lpuart5_ipg_stop: self.m33_lpuart5_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9(pub u32);
impl GprShared9 {
    #[doc = "m33_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared9 {
    #[inline(always)]
    fn default() -> GprShared9 {
        GprShared9(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9")
            .field("m33_lpuart6_ipg_stop", &self.m33_lpuart6_ipg_stop())
            .field("m33_lpuart7_ipg_stop", &self.m33_lpuart7_ipg_stop())
            .field("m33_lpuart8_ipg_stop", &self.m33_lpuart8_ipg_stop())
            .field("m33_lpuart9_ipg_stop", &self.m33_lpuart9_ipg_stop())
            .field("m33_lpuart10_ipg_stop", &self.m33_lpuart10_ipg_stop())
            .field("m33_lpuart11_ipg_stop", &self.m33_lpuart11_ipg_stop())
            .field("m33_lpuart12_ipg_stop", &self.m33_lpuart12_ipg_stop())
            .field("m33_lpi2c1_ipg_stop", &self.m33_lpi2c1_ipg_stop())
            .field("m33_lpi2c2_ipg_stop", &self.m33_lpi2c2_ipg_stop())
            .field("m33_lpi2c3_ipg_stop", &self.m33_lpi2c3_ipg_stop())
            .field("m33_lpi2c4_ipg_stop", &self.m33_lpi2c4_ipg_stop())
            .field("m33_lpi2c5_ipg_stop", &self.m33_lpi2c5_ipg_stop())
            .field("m33_lpi2c6_ipg_stop", &self.m33_lpi2c6_ipg_stop())
            .field("m33_lpspi1_ipg_stop", &self.m33_lpspi1_ipg_stop())
            .field("m33_lpspi2_ipg_stop", &self.m33_lpspi2_ipg_stop())
            .field("m33_lpspi3_ipg_stop", &self.m33_lpspi3_ipg_stop())
            .field("m33_lpspi4_ipg_stop", &self.m33_lpspi4_ipg_stop())
            .field("m33_lpspi5_ipg_stop", &self.m33_lpspi5_ipg_stop())
            .field("m33_lpspi6_ipg_stop", &self.m33_lpspi6_ipg_stop())
            .field("m33_sinc1_ipg_stop", &self.m33_sinc1_ipg_stop())
            .field("m33_sinc2_ipg_stop", &self.m33_sinc2_ipg_stop())
            .field("m33_sinc3_ipg_stop", &self.m33_sinc3_ipg_stop())
            .field("m33_sai1_ipg_stop", &self.m33_sai1_ipg_stop())
            .field("m33_sai2_ipg_stop", &self.m33_sai2_ipg_stop())
            .field("m33_sai3_ipg_stop", &self.m33_sai3_ipg_stop())
            .field("m33_sai4_ipg_stop", &self.m33_sai4_ipg_stop())
            .field("m33_mic_ipg_stop", &self.m33_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9 {
            m33_lpuart6_ipg_stop: bool,
            m33_lpuart7_ipg_stop: bool,
            m33_lpuart8_ipg_stop: bool,
            m33_lpuart9_ipg_stop: bool,
            m33_lpuart10_ipg_stop: bool,
            m33_lpuart11_ipg_stop: bool,
            m33_lpuart12_ipg_stop: bool,
            m33_lpi2c1_ipg_stop: bool,
            m33_lpi2c2_ipg_stop: bool,
            m33_lpi2c3_ipg_stop: bool,
            m33_lpi2c4_ipg_stop: bool,
            m33_lpi2c5_ipg_stop: bool,
            m33_lpi2c6_ipg_stop: bool,
            m33_lpspi1_ipg_stop: bool,
            m33_lpspi2_ipg_stop: bool,
            m33_lpspi3_ipg_stop: bool,
            m33_lpspi4_ipg_stop: bool,
            m33_lpspi5_ipg_stop: bool,
            m33_lpspi6_ipg_stop: bool,
            m33_sinc1_ipg_stop: bool,
            m33_sinc2_ipg_stop: bool,
            m33_sinc3_ipg_stop: bool,
            m33_sai1_ipg_stop: bool,
            m33_sai2_ipg_stop: bool,
            m33_sai3_ipg_stop: bool,
            m33_sai4_ipg_stop: bool,
            m33_mic_ipg_stop: bool,
        }
        let proxy = GprShared9 {
            m33_lpuart6_ipg_stop: self.m33_lpuart6_ipg_stop(),
            m33_lpuart7_ipg_stop: self.m33_lpuart7_ipg_stop(),
            m33_lpuart8_ipg_stop: self.m33_lpuart8_ipg_stop(),
            m33_lpuart9_ipg_stop: self.m33_lpuart9_ipg_stop(),
            m33_lpuart10_ipg_stop: self.m33_lpuart10_ipg_stop(),
            m33_lpuart11_ipg_stop: self.m33_lpuart11_ipg_stop(),
            m33_lpuart12_ipg_stop: self.m33_lpuart12_ipg_stop(),
            m33_lpi2c1_ipg_stop: self.m33_lpi2c1_ipg_stop(),
            m33_lpi2c2_ipg_stop: self.m33_lpi2c2_ipg_stop(),
            m33_lpi2c3_ipg_stop: self.m33_lpi2c3_ipg_stop(),
            m33_lpi2c4_ipg_stop: self.m33_lpi2c4_ipg_stop(),
            m33_lpi2c5_ipg_stop: self.m33_lpi2c5_ipg_stop(),
            m33_lpi2c6_ipg_stop: self.m33_lpi2c6_ipg_stop(),
            m33_lpspi1_ipg_stop: self.m33_lpspi1_ipg_stop(),
            m33_lpspi2_ipg_stop: self.m33_lpspi2_ipg_stop(),
            m33_lpspi3_ipg_stop: self.m33_lpspi3_ipg_stop(),
            m33_lpspi4_ipg_stop: self.m33_lpspi4_ipg_stop(),
            m33_lpspi5_ipg_stop: self.m33_lpspi5_ipg_stop(),
            m33_lpspi6_ipg_stop: self.m33_lpspi6_ipg_stop(),
            m33_sinc1_ipg_stop: self.m33_sinc1_ipg_stop(),
            m33_sinc2_ipg_stop: self.m33_sinc2_ipg_stop(),
            m33_sinc3_ipg_stop: self.m33_sinc3_ipg_stop(),
            m33_sai1_ipg_stop: self.m33_sai1_ipg_stop(),
            m33_sai2_ipg_stop: self.m33_sai2_ipg_stop(),
            m33_sai3_ipg_stop: self.m33_sai3_ipg_stop(),
            m33_sai4_ipg_stop: self.m33_sai4_ipg_stop(),
            m33_mic_ipg_stop: self.m33_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9Authen(pub u32);
impl GprShared9Authen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::GprShared9AuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::GprShared9AuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::GprShared9AuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::GprShared9AuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::GprShared9AuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::GprShared9AuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared9Authen {
    #[inline(always)]
    fn default() -> GprShared9Authen {
        GprShared9Authen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9Authen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9Authen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9Authen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9Authen {
            tz_user: super::vals::GprShared9AuthenTzUser,
            tz_ns: super::vals::GprShared9AuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared9Authen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9AuthenClr(pub u32);
impl GprShared9AuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared9AuthenClr {
    #[inline(always)]
    fn default() -> GprShared9AuthenClr {
        GprShared9AuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9AuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9AuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9AuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9AuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared9AuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9AuthenSet(pub u32);
impl GprShared9AuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared9AuthenSet {
    #[inline(always)]
    fn default() -> GprShared9AuthenSet {
        GprShared9AuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9AuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9AuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9AuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9AuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared9AuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "GPR access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9AuthenTog(pub u32);
impl GprShared9AuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for GprShared9AuthenTog {
    #[inline(always)]
    fn default() -> GprShared9AuthenTog {
        GprShared9AuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9AuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9AuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9AuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9AuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = GprShared9AuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9Clr(pub u32);
impl GprShared9Clr {
    #[doc = "m33_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared9Clr {
    #[inline(always)]
    fn default() -> GprShared9Clr {
        GprShared9Clr(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9Clr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9Clr")
            .field("m33_lpuart6_ipg_stop", &self.m33_lpuart6_ipg_stop())
            .field("m33_lpuart7_ipg_stop", &self.m33_lpuart7_ipg_stop())
            .field("m33_lpuart8_ipg_stop", &self.m33_lpuart8_ipg_stop())
            .field("m33_lpuart9_ipg_stop", &self.m33_lpuart9_ipg_stop())
            .field("m33_lpuart10_ipg_stop", &self.m33_lpuart10_ipg_stop())
            .field("m33_lpuart11_ipg_stop", &self.m33_lpuart11_ipg_stop())
            .field("m33_lpuart12_ipg_stop", &self.m33_lpuart12_ipg_stop())
            .field("m33_lpi2c1_ipg_stop", &self.m33_lpi2c1_ipg_stop())
            .field("m33_lpi2c2_ipg_stop", &self.m33_lpi2c2_ipg_stop())
            .field("m33_lpi2c3_ipg_stop", &self.m33_lpi2c3_ipg_stop())
            .field("m33_lpi2c4_ipg_stop", &self.m33_lpi2c4_ipg_stop())
            .field("m33_lpi2c5_ipg_stop", &self.m33_lpi2c5_ipg_stop())
            .field("m33_lpi2c6_ipg_stop", &self.m33_lpi2c6_ipg_stop())
            .field("m33_lpspi1_ipg_stop", &self.m33_lpspi1_ipg_stop())
            .field("m33_lpspi2_ipg_stop", &self.m33_lpspi2_ipg_stop())
            .field("m33_lpspi3_ipg_stop", &self.m33_lpspi3_ipg_stop())
            .field("m33_lpspi4_ipg_stop", &self.m33_lpspi4_ipg_stop())
            .field("m33_lpspi5_ipg_stop", &self.m33_lpspi5_ipg_stop())
            .field("m33_lpspi6_ipg_stop", &self.m33_lpspi6_ipg_stop())
            .field("m33_sinc1_ipg_stop", &self.m33_sinc1_ipg_stop())
            .field("m33_sinc2_ipg_stop", &self.m33_sinc2_ipg_stop())
            .field("m33_sinc3_ipg_stop", &self.m33_sinc3_ipg_stop())
            .field("m33_sai1_ipg_stop", &self.m33_sai1_ipg_stop())
            .field("m33_sai2_ipg_stop", &self.m33_sai2_ipg_stop())
            .field("m33_sai3_ipg_stop", &self.m33_sai3_ipg_stop())
            .field("m33_sai4_ipg_stop", &self.m33_sai4_ipg_stop())
            .field("m33_mic_ipg_stop", &self.m33_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9Clr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9Clr {
            m33_lpuart6_ipg_stop: bool,
            m33_lpuart7_ipg_stop: bool,
            m33_lpuart8_ipg_stop: bool,
            m33_lpuart9_ipg_stop: bool,
            m33_lpuart10_ipg_stop: bool,
            m33_lpuart11_ipg_stop: bool,
            m33_lpuart12_ipg_stop: bool,
            m33_lpi2c1_ipg_stop: bool,
            m33_lpi2c2_ipg_stop: bool,
            m33_lpi2c3_ipg_stop: bool,
            m33_lpi2c4_ipg_stop: bool,
            m33_lpi2c5_ipg_stop: bool,
            m33_lpi2c6_ipg_stop: bool,
            m33_lpspi1_ipg_stop: bool,
            m33_lpspi2_ipg_stop: bool,
            m33_lpspi3_ipg_stop: bool,
            m33_lpspi4_ipg_stop: bool,
            m33_lpspi5_ipg_stop: bool,
            m33_lpspi6_ipg_stop: bool,
            m33_sinc1_ipg_stop: bool,
            m33_sinc2_ipg_stop: bool,
            m33_sinc3_ipg_stop: bool,
            m33_sai1_ipg_stop: bool,
            m33_sai2_ipg_stop: bool,
            m33_sai3_ipg_stop: bool,
            m33_sai4_ipg_stop: bool,
            m33_mic_ipg_stop: bool,
        }
        let proxy = GprShared9Clr {
            m33_lpuart6_ipg_stop: self.m33_lpuart6_ipg_stop(),
            m33_lpuart7_ipg_stop: self.m33_lpuart7_ipg_stop(),
            m33_lpuart8_ipg_stop: self.m33_lpuart8_ipg_stop(),
            m33_lpuart9_ipg_stop: self.m33_lpuart9_ipg_stop(),
            m33_lpuart10_ipg_stop: self.m33_lpuart10_ipg_stop(),
            m33_lpuart11_ipg_stop: self.m33_lpuart11_ipg_stop(),
            m33_lpuart12_ipg_stop: self.m33_lpuart12_ipg_stop(),
            m33_lpi2c1_ipg_stop: self.m33_lpi2c1_ipg_stop(),
            m33_lpi2c2_ipg_stop: self.m33_lpi2c2_ipg_stop(),
            m33_lpi2c3_ipg_stop: self.m33_lpi2c3_ipg_stop(),
            m33_lpi2c4_ipg_stop: self.m33_lpi2c4_ipg_stop(),
            m33_lpi2c5_ipg_stop: self.m33_lpi2c5_ipg_stop(),
            m33_lpi2c6_ipg_stop: self.m33_lpi2c6_ipg_stop(),
            m33_lpspi1_ipg_stop: self.m33_lpspi1_ipg_stop(),
            m33_lpspi2_ipg_stop: self.m33_lpspi2_ipg_stop(),
            m33_lpspi3_ipg_stop: self.m33_lpspi3_ipg_stop(),
            m33_lpspi4_ipg_stop: self.m33_lpspi4_ipg_stop(),
            m33_lpspi5_ipg_stop: self.m33_lpspi5_ipg_stop(),
            m33_lpspi6_ipg_stop: self.m33_lpspi6_ipg_stop(),
            m33_sinc1_ipg_stop: self.m33_sinc1_ipg_stop(),
            m33_sinc2_ipg_stop: self.m33_sinc2_ipg_stop(),
            m33_sinc3_ipg_stop: self.m33_sinc3_ipg_stop(),
            m33_sai1_ipg_stop: self.m33_sai1_ipg_stop(),
            m33_sai2_ipg_stop: self.m33_sai2_ipg_stop(),
            m33_sai3_ipg_stop: self.m33_sai3_ipg_stop(),
            m33_sai4_ipg_stop: self.m33_sai4_ipg_stop(),
            m33_mic_ipg_stop: self.m33_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9Set(pub u32);
impl GprShared9Set {
    #[doc = "m33_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared9Set {
    #[inline(always)]
    fn default() -> GprShared9Set {
        GprShared9Set(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9Set {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9Set")
            .field("m33_lpuart6_ipg_stop", &self.m33_lpuart6_ipg_stop())
            .field("m33_lpuart7_ipg_stop", &self.m33_lpuart7_ipg_stop())
            .field("m33_lpuart8_ipg_stop", &self.m33_lpuart8_ipg_stop())
            .field("m33_lpuart9_ipg_stop", &self.m33_lpuart9_ipg_stop())
            .field("m33_lpuart10_ipg_stop", &self.m33_lpuart10_ipg_stop())
            .field("m33_lpuart11_ipg_stop", &self.m33_lpuart11_ipg_stop())
            .field("m33_lpuart12_ipg_stop", &self.m33_lpuart12_ipg_stop())
            .field("m33_lpi2c1_ipg_stop", &self.m33_lpi2c1_ipg_stop())
            .field("m33_lpi2c2_ipg_stop", &self.m33_lpi2c2_ipg_stop())
            .field("m33_lpi2c3_ipg_stop", &self.m33_lpi2c3_ipg_stop())
            .field("m33_lpi2c4_ipg_stop", &self.m33_lpi2c4_ipg_stop())
            .field("m33_lpi2c5_ipg_stop", &self.m33_lpi2c5_ipg_stop())
            .field("m33_lpi2c6_ipg_stop", &self.m33_lpi2c6_ipg_stop())
            .field("m33_lpspi1_ipg_stop", &self.m33_lpspi1_ipg_stop())
            .field("m33_lpspi2_ipg_stop", &self.m33_lpspi2_ipg_stop())
            .field("m33_lpspi3_ipg_stop", &self.m33_lpspi3_ipg_stop())
            .field("m33_lpspi4_ipg_stop", &self.m33_lpspi4_ipg_stop())
            .field("m33_lpspi5_ipg_stop", &self.m33_lpspi5_ipg_stop())
            .field("m33_lpspi6_ipg_stop", &self.m33_lpspi6_ipg_stop())
            .field("m33_sinc1_ipg_stop", &self.m33_sinc1_ipg_stop())
            .field("m33_sinc2_ipg_stop", &self.m33_sinc2_ipg_stop())
            .field("m33_sinc3_ipg_stop", &self.m33_sinc3_ipg_stop())
            .field("m33_sai1_ipg_stop", &self.m33_sai1_ipg_stop())
            .field("m33_sai2_ipg_stop", &self.m33_sai2_ipg_stop())
            .field("m33_sai3_ipg_stop", &self.m33_sai3_ipg_stop())
            .field("m33_sai4_ipg_stop", &self.m33_sai4_ipg_stop())
            .field("m33_mic_ipg_stop", &self.m33_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9Set {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9Set {
            m33_lpuart6_ipg_stop: bool,
            m33_lpuart7_ipg_stop: bool,
            m33_lpuart8_ipg_stop: bool,
            m33_lpuart9_ipg_stop: bool,
            m33_lpuart10_ipg_stop: bool,
            m33_lpuart11_ipg_stop: bool,
            m33_lpuart12_ipg_stop: bool,
            m33_lpi2c1_ipg_stop: bool,
            m33_lpi2c2_ipg_stop: bool,
            m33_lpi2c3_ipg_stop: bool,
            m33_lpi2c4_ipg_stop: bool,
            m33_lpi2c5_ipg_stop: bool,
            m33_lpi2c6_ipg_stop: bool,
            m33_lpspi1_ipg_stop: bool,
            m33_lpspi2_ipg_stop: bool,
            m33_lpspi3_ipg_stop: bool,
            m33_lpspi4_ipg_stop: bool,
            m33_lpspi5_ipg_stop: bool,
            m33_lpspi6_ipg_stop: bool,
            m33_sinc1_ipg_stop: bool,
            m33_sinc2_ipg_stop: bool,
            m33_sinc3_ipg_stop: bool,
            m33_sai1_ipg_stop: bool,
            m33_sai2_ipg_stop: bool,
            m33_sai3_ipg_stop: bool,
            m33_sai4_ipg_stop: bool,
            m33_mic_ipg_stop: bool,
        }
        let proxy = GprShared9Set {
            m33_lpuart6_ipg_stop: self.m33_lpuart6_ipg_stop(),
            m33_lpuart7_ipg_stop: self.m33_lpuart7_ipg_stop(),
            m33_lpuart8_ipg_stop: self.m33_lpuart8_ipg_stop(),
            m33_lpuart9_ipg_stop: self.m33_lpuart9_ipg_stop(),
            m33_lpuart10_ipg_stop: self.m33_lpuart10_ipg_stop(),
            m33_lpuart11_ipg_stop: self.m33_lpuart11_ipg_stop(),
            m33_lpuart12_ipg_stop: self.m33_lpuart12_ipg_stop(),
            m33_lpi2c1_ipg_stop: self.m33_lpi2c1_ipg_stop(),
            m33_lpi2c2_ipg_stop: self.m33_lpi2c2_ipg_stop(),
            m33_lpi2c3_ipg_stop: self.m33_lpi2c3_ipg_stop(),
            m33_lpi2c4_ipg_stop: self.m33_lpi2c4_ipg_stop(),
            m33_lpi2c5_ipg_stop: self.m33_lpi2c5_ipg_stop(),
            m33_lpi2c6_ipg_stop: self.m33_lpi2c6_ipg_stop(),
            m33_lpspi1_ipg_stop: self.m33_lpspi1_ipg_stop(),
            m33_lpspi2_ipg_stop: self.m33_lpspi2_ipg_stop(),
            m33_lpspi3_ipg_stop: self.m33_lpspi3_ipg_stop(),
            m33_lpspi4_ipg_stop: self.m33_lpspi4_ipg_stop(),
            m33_lpspi5_ipg_stop: self.m33_lpspi5_ipg_stop(),
            m33_lpspi6_ipg_stop: self.m33_lpspi6_ipg_stop(),
            m33_sinc1_ipg_stop: self.m33_sinc1_ipg_stop(),
            m33_sinc2_ipg_stop: self.m33_sinc2_ipg_stop(),
            m33_sinc3_ipg_stop: self.m33_sinc3_ipg_stop(),
            m33_sai1_ipg_stop: self.m33_sai1_ipg_stop(),
            m33_sai2_ipg_stop: self.m33_sai2_ipg_stop(),
            m33_sai3_ipg_stop: self.m33_sai3_ipg_stop(),
            m33_sai4_ipg_stop: self.m33_sai4_ipg_stop(),
            m33_mic_ipg_stop: self.m33_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "General Purpose Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GprShared9Tog(pub u32);
impl GprShared9Tog {
    #[doc = "m33_lpuart6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart7_ipg_stop(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart7_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart7_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart8_ipg_stop(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart8_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart8_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart9_ipg_stop(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart9_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart9_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart10_ipg_stop(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart10_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart10_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart11_ipg_stop(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart11_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart11_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpuart12_ipg_stop(&self) -> bool {
        let val = (self.0 >> 6usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpuart12_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpuart12_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 7usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 10usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpi2c6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpi2c6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpi2c6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 14usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 16usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi5_ipg_stop(&self) -> bool {
        let val = (self.0 >> 17usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi5_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi5_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_lpspi6_ipg_stop(&self) -> bool {
        let val = (self.0 >> 18usize) & 0x01;
        val != 0
    }
    #[doc = "m33_lpspi6_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_lpspi6_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 19usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 20usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sinc3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 21usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sinc3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sinc3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai1_ipg_stop(&self) -> bool {
        let val = (self.0 >> 22usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai1_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai1_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai2_ipg_stop(&self) -> bool {
        let val = (self.0 >> 23usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai2_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai2_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai3_ipg_stop(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai3_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai3_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_sai4_ipg_stop(&self) -> bool {
        let val = (self.0 >> 25usize) & 0x01;
        val != 0
    }
    #[doc = "m33_sai4_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_sai4_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
    }
    #[doc = "m33_mic_ipg_stop"]
    #[must_use]
    #[inline(always)]
    pub const fn m33_mic_ipg_stop(&self) -> bool {
        let val = (self.0 >> 26usize) & 0x01;
        val != 0
    }
    #[doc = "m33_mic_ipg_stop"]
    #[inline(always)]
    pub const fn set_m33_mic_ipg_stop(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
    }
}
impl Default for GprShared9Tog {
    #[inline(always)]
    fn default() -> GprShared9Tog {
        GprShared9Tog(0u64 as u32)
    }
}
impl core::fmt::Debug for GprShared9Tog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GprShared9Tog")
            .field("m33_lpuart6_ipg_stop", &self.m33_lpuart6_ipg_stop())
            .field("m33_lpuart7_ipg_stop", &self.m33_lpuart7_ipg_stop())
            .field("m33_lpuart8_ipg_stop", &self.m33_lpuart8_ipg_stop())
            .field("m33_lpuart9_ipg_stop", &self.m33_lpuart9_ipg_stop())
            .field("m33_lpuart10_ipg_stop", &self.m33_lpuart10_ipg_stop())
            .field("m33_lpuart11_ipg_stop", &self.m33_lpuart11_ipg_stop())
            .field("m33_lpuart12_ipg_stop", &self.m33_lpuart12_ipg_stop())
            .field("m33_lpi2c1_ipg_stop", &self.m33_lpi2c1_ipg_stop())
            .field("m33_lpi2c2_ipg_stop", &self.m33_lpi2c2_ipg_stop())
            .field("m33_lpi2c3_ipg_stop", &self.m33_lpi2c3_ipg_stop())
            .field("m33_lpi2c4_ipg_stop", &self.m33_lpi2c4_ipg_stop())
            .field("m33_lpi2c5_ipg_stop", &self.m33_lpi2c5_ipg_stop())
            .field("m33_lpi2c6_ipg_stop", &self.m33_lpi2c6_ipg_stop())
            .field("m33_lpspi1_ipg_stop", &self.m33_lpspi1_ipg_stop())
            .field("m33_lpspi2_ipg_stop", &self.m33_lpspi2_ipg_stop())
            .field("m33_lpspi3_ipg_stop", &self.m33_lpspi3_ipg_stop())
            .field("m33_lpspi4_ipg_stop", &self.m33_lpspi4_ipg_stop())
            .field("m33_lpspi5_ipg_stop", &self.m33_lpspi5_ipg_stop())
            .field("m33_lpspi6_ipg_stop", &self.m33_lpspi6_ipg_stop())
            .field("m33_sinc1_ipg_stop", &self.m33_sinc1_ipg_stop())
            .field("m33_sinc2_ipg_stop", &self.m33_sinc2_ipg_stop())
            .field("m33_sinc3_ipg_stop", &self.m33_sinc3_ipg_stop())
            .field("m33_sai1_ipg_stop", &self.m33_sai1_ipg_stop())
            .field("m33_sai2_ipg_stop", &self.m33_sai2_ipg_stop())
            .field("m33_sai3_ipg_stop", &self.m33_sai3_ipg_stop())
            .field("m33_sai4_ipg_stop", &self.m33_sai4_ipg_stop())
            .field("m33_mic_ipg_stop", &self.m33_mic_ipg_stop())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for GprShared9Tog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct GprShared9Tog {
            m33_lpuart6_ipg_stop: bool,
            m33_lpuart7_ipg_stop: bool,
            m33_lpuart8_ipg_stop: bool,
            m33_lpuart9_ipg_stop: bool,
            m33_lpuart10_ipg_stop: bool,
            m33_lpuart11_ipg_stop: bool,
            m33_lpuart12_ipg_stop: bool,
            m33_lpi2c1_ipg_stop: bool,
            m33_lpi2c2_ipg_stop: bool,
            m33_lpi2c3_ipg_stop: bool,
            m33_lpi2c4_ipg_stop: bool,
            m33_lpi2c5_ipg_stop: bool,
            m33_lpi2c6_ipg_stop: bool,
            m33_lpspi1_ipg_stop: bool,
            m33_lpspi2_ipg_stop: bool,
            m33_lpspi3_ipg_stop: bool,
            m33_lpspi4_ipg_stop: bool,
            m33_lpspi5_ipg_stop: bool,
            m33_lpspi6_ipg_stop: bool,
            m33_sinc1_ipg_stop: bool,
            m33_sinc2_ipg_stop: bool,
            m33_sinc3_ipg_stop: bool,
            m33_sai1_ipg_stop: bool,
            m33_sai2_ipg_stop: bool,
            m33_sai3_ipg_stop: bool,
            m33_sai4_ipg_stop: bool,
            m33_mic_ipg_stop: bool,
        }
        let proxy = GprShared9Tog {
            m33_lpuart6_ipg_stop: self.m33_lpuart6_ipg_stop(),
            m33_lpuart7_ipg_stop: self.m33_lpuart7_ipg_stop(),
            m33_lpuart8_ipg_stop: self.m33_lpuart8_ipg_stop(),
            m33_lpuart9_ipg_stop: self.m33_lpuart9_ipg_stop(),
            m33_lpuart10_ipg_stop: self.m33_lpuart10_ipg_stop(),
            m33_lpuart11_ipg_stop: self.m33_lpuart11_ipg_stop(),
            m33_lpuart12_ipg_stop: self.m33_lpuart12_ipg_stop(),
            m33_lpi2c1_ipg_stop: self.m33_lpi2c1_ipg_stop(),
            m33_lpi2c2_ipg_stop: self.m33_lpi2c2_ipg_stop(),
            m33_lpi2c3_ipg_stop: self.m33_lpi2c3_ipg_stop(),
            m33_lpi2c4_ipg_stop: self.m33_lpi2c4_ipg_stop(),
            m33_lpi2c5_ipg_stop: self.m33_lpi2c5_ipg_stop(),
            m33_lpi2c6_ipg_stop: self.m33_lpi2c6_ipg_stop(),
            m33_lpspi1_ipg_stop: self.m33_lpspi1_ipg_stop(),
            m33_lpspi2_ipg_stop: self.m33_lpspi2_ipg_stop(),
            m33_lpspi3_ipg_stop: self.m33_lpspi3_ipg_stop(),
            m33_lpspi4_ipg_stop: self.m33_lpspi4_ipg_stop(),
            m33_lpspi5_ipg_stop: self.m33_lpspi5_ipg_stop(),
            m33_lpspi6_ipg_stop: self.m33_lpspi6_ipg_stop(),
            m33_sinc1_ipg_stop: self.m33_sinc1_ipg_stop(),
            m33_sinc2_ipg_stop: self.m33_sinc2_ipg_stop(),
            m33_sinc3_ipg_stop: self.m33_sinc3_ipg_stop(),
            m33_sai1_ipg_stop: self.m33_sai1_ipg_stop(),
            m33_sai2_ipg_stop: self.m33_sai2_ipg_stop(),
            m33_sai3_ipg_stop: self.m33_sai3_ipg_stop(),
            m33_sai4_ipg_stop: self.m33_sai4_ipg_stop(),
            m33_mic_ipg_stop: self.m33_mic_ipg_stop(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "LPCG access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgAuthen(pub u32);
impl LpcgAuthen {
    #[doc = "CPULPM mode enable"]
    #[must_use]
    #[inline(always)]
    pub const fn cpulpm_mode(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "CPULPM mode enable"]
    #[inline(always)]
    pub const fn set_cpulpm_mode(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "CPULPM mode enable"]
    #[must_use]
    #[inline(always)]
    pub const fn ack_mode(&self) -> super::vals::AckMode {
        let val = (self.0 >> 4usize) & 0x01;
        super::vals::AckMode::from_bits(val as u8)
    }
    #[doc = "CPULPM mode enable"]
    #[inline(always)]
    pub const fn set_ack_mode(&mut self, val: super::vals::AckMode) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
    }
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::LpcgAuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::LpcgAuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::LpcgAuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::LpcgAuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::LpcgAuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::LpcgAuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for LpcgAuthen {
    #[inline(always)]
    fn default() -> LpcgAuthen {
        LpcgAuthen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for LpcgAuthen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgAuthen")
            .field("cpulpm_mode", &self.cpulpm_mode())
            .field("ack_mode", &self.ack_mode())
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgAuthen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgAuthen {
            cpulpm_mode: bool,
            ack_mode: super::vals::AckMode,
            tz_user: super::vals::LpcgAuthenTzUser,
            tz_ns: super::vals::LpcgAuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = LpcgAuthen {
            cpulpm_mode: self.cpulpm_mode(),
            ack_mode: self.ack_mode(),
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "LPCG direct control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgDirect(pub u32);
impl LpcgDirect {
    #[doc = "Turn on LPCG"]
    #[must_use]
    #[inline(always)]
    pub const fn on(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "Turn on LPCG"]
    #[inline(always)]
    pub const fn set_on(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "Clock off handshake timeout enable"]
    #[must_use]
    #[inline(always)]
    pub const fn clkoff_ack_timeout_en(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "Clock off handshake timeout enable"]
    #[inline(always)]
    pub const fn set_clkoff_ack_timeout_en(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
}
impl Default for LpcgDirect {
    #[inline(always)]
    fn default() -> LpcgDirect {
        LpcgDirect(1u64 as u32)
    }
}
impl core::fmt::Debug for LpcgDirect {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgDirect")
            .field("on", &self.on())
            .field("clkoff_ack_timeout_en", &self.clkoff_ack_timeout_en())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgDirect {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgDirect {
            on: bool,
            clkoff_ack_timeout_en: bool,
        }
        let proxy = LpcgDirect {
            on: self.on(),
            clkoff_ack_timeout_en: self.clkoff_ack_timeout_en(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock source low power mode setting"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgLpm0(pub u32);
impl LpcgLpm0 {
    #[doc = "Clock Source LPM in DOMAIN0"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d0(&self) -> super::vals::LpcgLpm0LpmSettingD0 {
        let val = (self.0 >> 0usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD0::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN0"]
    #[inline(always)]
    pub const fn set_lpm_setting_d0(&mut self, val: super::vals::LpcgLpm0LpmSettingD0) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
    }
    #[doc = "Clock Source LPM in DOMAIN1"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d1(&self) -> super::vals::LpcgLpm0LpmSettingD1 {
        let val = (self.0 >> 4usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD1::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN1"]
    #[inline(always)]
    pub const fn set_lpm_setting_d1(&mut self, val: super::vals::LpcgLpm0LpmSettingD1) {
        self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
    }
    #[doc = "Clock Source LPM in DOMAIN2"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d2(&self) -> super::vals::LpcgLpm0LpmSettingD2 {
        let val = (self.0 >> 8usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD2::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN2"]
    #[inline(always)]
    pub const fn set_lpm_setting_d2(&mut self, val: super::vals::LpcgLpm0LpmSettingD2) {
        self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
    }
    #[doc = "Clock Source LPM in DOMAIN3"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d3(&self) -> super::vals::LpcgLpm0LpmSettingD3 {
        let val = (self.0 >> 12usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD3::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN3"]
    #[inline(always)]
    pub const fn set_lpm_setting_d3(&mut self, val: super::vals::LpcgLpm0LpmSettingD3) {
        self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
    }
    #[doc = "Clock Source LPM in DOMAIN4"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d4(&self) -> super::vals::LpcgLpm0LpmSettingD4 {
        let val = (self.0 >> 16usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD4::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN4"]
    #[inline(always)]
    pub const fn set_lpm_setting_d4(&mut self, val: super::vals::LpcgLpm0LpmSettingD4) {
        self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
    }
    #[doc = "Clock Source LPM in DOMAIN5"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d5(&self) -> super::vals::LpcgLpm0LpmSettingD5 {
        let val = (self.0 >> 20usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD5::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN5"]
    #[inline(always)]
    pub const fn set_lpm_setting_d5(&mut self, val: super::vals::LpcgLpm0LpmSettingD5) {
        self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
    }
    #[doc = "Clock Source LPM in DOMAIN6"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d6(&self) -> super::vals::LpcgLpm0LpmSettingD6 {
        let val = (self.0 >> 24usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD6::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN6"]
    #[inline(always)]
    pub const fn set_lpm_setting_d6(&mut self, val: super::vals::LpcgLpm0LpmSettingD6) {
        self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
    }
    #[doc = "Clock Source LPM in DOMAIN7"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d7(&self) -> super::vals::LpcgLpm0LpmSettingD7 {
        let val = (self.0 >> 28usize) & 0x07;
        super::vals::LpcgLpm0LpmSettingD7::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN7"]
    #[inline(always)]
    pub const fn set_lpm_setting_d7(&mut self, val: super::vals::LpcgLpm0LpmSettingD7) {
        self.0 = (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
    }
}
impl Default for LpcgLpm0 {
    #[inline(always)]
    fn default() -> LpcgLpm0 {
        LpcgLpm0(0u64 as u32)
    }
}
impl core::fmt::Debug for LpcgLpm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgLpm0")
            .field("lpm_setting_d0", &self.lpm_setting_d0())
            .field("lpm_setting_d1", &self.lpm_setting_d1())
            .field("lpm_setting_d2", &self.lpm_setting_d2())
            .field("lpm_setting_d3", &self.lpm_setting_d3())
            .field("lpm_setting_d4", &self.lpm_setting_d4())
            .field("lpm_setting_d5", &self.lpm_setting_d5())
            .field("lpm_setting_d6", &self.lpm_setting_d6())
            .field("lpm_setting_d7", &self.lpm_setting_d7())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgLpm0 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgLpm0 {
            lpm_setting_d0: super::vals::LpcgLpm0LpmSettingD0,
            lpm_setting_d1: super::vals::LpcgLpm0LpmSettingD1,
            lpm_setting_d2: super::vals::LpcgLpm0LpmSettingD2,
            lpm_setting_d3: super::vals::LpcgLpm0LpmSettingD3,
            lpm_setting_d4: super::vals::LpcgLpm0LpmSettingD4,
            lpm_setting_d5: super::vals::LpcgLpm0LpmSettingD5,
            lpm_setting_d6: super::vals::LpcgLpm0LpmSettingD6,
            lpm_setting_d7: super::vals::LpcgLpm0LpmSettingD7,
        }
        let proxy = LpcgLpm0 {
            lpm_setting_d0: self.lpm_setting_d0(),
            lpm_setting_d1: self.lpm_setting_d1(),
            lpm_setting_d2: self.lpm_setting_d2(),
            lpm_setting_d3: self.lpm_setting_d3(),
            lpm_setting_d4: self.lpm_setting_d4(),
            lpm_setting_d5: self.lpm_setting_d5(),
            lpm_setting_d6: self.lpm_setting_d6(),
            lpm_setting_d7: self.lpm_setting_d7(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "clock source low power mode setting"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgLpm1(pub u32);
impl LpcgLpm1 {
    #[doc = "Clock Source LPM in DOMAIN8"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d8(&self) -> super::vals::LpcgLpm1LpmSettingD8 {
        let val = (self.0 >> 0usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD8::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN8"]
    #[inline(always)]
    pub const fn set_lpm_setting_d8(&mut self, val: super::vals::LpcgLpm1LpmSettingD8) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
    }
    #[doc = "Clock Source LPM in DOMAIN9"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d9(&self) -> super::vals::LpcgLpm1LpmSettingD9 {
        let val = (self.0 >> 4usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD9::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN9"]
    #[inline(always)]
    pub const fn set_lpm_setting_d9(&mut self, val: super::vals::LpcgLpm1LpmSettingD9) {
        self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
    }
    #[doc = "Clock Source LPM in DOMAIN10"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d10(&self) -> super::vals::LpcgLpm1LpmSettingD10 {
        let val = (self.0 >> 8usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD10::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN10"]
    #[inline(always)]
    pub const fn set_lpm_setting_d10(&mut self, val: super::vals::LpcgLpm1LpmSettingD10) {
        self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
    }
    #[doc = "Clock Source LPM in DOMAIN11"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d11(&self) -> super::vals::LpcgLpm1LpmSettingD11 {
        let val = (self.0 >> 12usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD11::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN11"]
    #[inline(always)]
    pub const fn set_lpm_setting_d11(&mut self, val: super::vals::LpcgLpm1LpmSettingD11) {
        self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
    }
    #[doc = "Clock Source LPM in DOMAIN12"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d12(&self) -> super::vals::LpcgLpm1LpmSettingD12 {
        let val = (self.0 >> 16usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD12::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN12"]
    #[inline(always)]
    pub const fn set_lpm_setting_d12(&mut self, val: super::vals::LpcgLpm1LpmSettingD12) {
        self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
    }
    #[doc = "Clock Source LPM in DOMAIN13"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d13(&self) -> super::vals::LpcgLpm1LpmSettingD13 {
        let val = (self.0 >> 20usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD13::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN13"]
    #[inline(always)]
    pub const fn set_lpm_setting_d13(&mut self, val: super::vals::LpcgLpm1LpmSettingD13) {
        self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
    }
    #[doc = "Clock Source LPM in DOMAIN14"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d14(&self) -> super::vals::LpcgLpm1LpmSettingD14 {
        let val = (self.0 >> 24usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD14::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN14"]
    #[inline(always)]
    pub const fn set_lpm_setting_d14(&mut self, val: super::vals::LpcgLpm1LpmSettingD14) {
        self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
    }
    #[doc = "Clock Source LPM in DOMAIN15"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d15(&self) -> super::vals::LpcgLpm1LpmSettingD15 {
        let val = (self.0 >> 28usize) & 0x07;
        super::vals::LpcgLpm1LpmSettingD15::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN15"]
    #[inline(always)]
    pub const fn set_lpm_setting_d15(&mut self, val: super::vals::LpcgLpm1LpmSettingD15) {
        self.0 = (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
    }
}
impl Default for LpcgLpm1 {
    #[inline(always)]
    fn default() -> LpcgLpm1 {
        LpcgLpm1(0u64 as u32)
    }
}
impl core::fmt::Debug for LpcgLpm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgLpm1")
            .field("lpm_setting_d8", &self.lpm_setting_d8())
            .field("lpm_setting_d9", &self.lpm_setting_d9())
            .field("lpm_setting_d10", &self.lpm_setting_d10())
            .field("lpm_setting_d11", &self.lpm_setting_d11())
            .field("lpm_setting_d12", &self.lpm_setting_d12())
            .field("lpm_setting_d13", &self.lpm_setting_d13())
            .field("lpm_setting_d14", &self.lpm_setting_d14())
            .field("lpm_setting_d15", &self.lpm_setting_d15())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgLpm1 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgLpm1 {
            lpm_setting_d8: super::vals::LpcgLpm1LpmSettingD8,
            lpm_setting_d9: super::vals::LpcgLpm1LpmSettingD9,
            lpm_setting_d10: super::vals::LpcgLpm1LpmSettingD10,
            lpm_setting_d11: super::vals::LpcgLpm1LpmSettingD11,
            lpm_setting_d12: super::vals::LpcgLpm1LpmSettingD12,
            lpm_setting_d13: super::vals::LpcgLpm1LpmSettingD13,
            lpm_setting_d14: super::vals::LpcgLpm1LpmSettingD14,
            lpm_setting_d15: super::vals::LpcgLpm1LpmSettingD15,
        }
        let proxy = LpcgLpm1 {
            lpm_setting_d8: self.lpm_setting_d8(),
            lpm_setting_d9: self.lpm_setting_d9(),
            lpm_setting_d10: self.lpm_setting_d10(),
            lpm_setting_d11: self.lpm_setting_d11(),
            lpm_setting_d12: self.lpm_setting_d12(),
            lpm_setting_d13: self.lpm_setting_d13(),
            lpm_setting_d14: self.lpm_setting_d14(),
            lpm_setting_d15: self.lpm_setting_d15(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "LPM setting of current CPU domain"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgLpmCur(pub u32);
impl LpcgLpmCur {
    #[doc = "LPM settings value for current CPU domain that is reading this register."]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_cur(&self) -> super::vals::LpcgLpmCurLpmSettingCur {
        let val = (self.0 >> 0usize) & 0x07;
        super::vals::LpcgLpmCurLpmSettingCur::from_bits(val as u8)
    }
    #[doc = "LPM settings value for current CPU domain that is reading this register."]
    #[inline(always)]
    pub const fn set_lpm_setting_cur(&mut self, val: super::vals::LpcgLpmCurLpmSettingCur) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
    }
}
impl Default for LpcgLpmCur {
    #[inline(always)]
    fn default() -> LpcgLpmCur {
        LpcgLpmCur(0u64 as u32)
    }
}
impl core::fmt::Debug for LpcgLpmCur {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgLpmCur")
            .field("lpm_setting_cur", &self.lpm_setting_cur())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgLpmCur {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgLpmCur {
            lpm_setting_cur: super::vals::LpcgLpmCurLpmSettingCur,
        }
        let proxy = LpcgLpmCur {
            lpm_setting_cur: self.lpm_setting_cur(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "LPCG working status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgStatus0(pub u32);
impl LpcgStatus0 {
    #[doc = "LPCG work status"]
    #[must_use]
    #[inline(always)]
    pub const fn on(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "LPCG work status"]
    #[inline(always)]
    pub const fn set_on(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
}
impl Default for LpcgStatus0 {
    #[inline(always)]
    fn default() -> LpcgStatus0 {
        LpcgStatus0(1u64 as u32)
    }
}
impl core::fmt::Debug for LpcgStatus0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgStatus0")
            .field("on", &self.on())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgStatus0 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgStatus0 {
            on: bool,
        }
        let proxy = LpcgStatus0 { on: self.on() };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "LPCG domain status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct LpcgStatus1(pub u32);
impl LpcgStatus1 {
    #[doc = "Domain active"]
    #[must_use]
    #[inline(always)]
    pub const fn domain_active(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Domain active"]
    #[inline(always)]
    pub const fn set_domain_active(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Domain enable"]
    #[must_use]
    #[inline(always)]
    pub const fn domain_enable(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Domain enable"]
    #[inline(always)]
    pub const fn set_domain_enable(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for LpcgStatus1 {
    #[inline(always)]
    fn default() -> LpcgStatus1 {
        LpcgStatus1(65535u64 as u32)
    }
}
impl core::fmt::Debug for LpcgStatus1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpcgStatus1")
            .field("domain_active", &self.domain_active())
            .field("domain_enable", &self.domain_enable())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for LpcgStatus1 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct LpcgStatus1 {
            domain_active: u16,
            domain_enable: u16,
        }
        let proxy = LpcgStatus1 {
            domain_active: self.domain_active(),
            domain_enable: self.domain_enable(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveAuthen(pub u32);
impl ObserveAuthen {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::ObserveAuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::ObserveAuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::ObserveAuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::ObserveAuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::ObserveAuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::ObserveAuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone setting"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone setting"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> super::vals::WhiteList {
        let val = (self.0 >> 16usize) & 0xffff;
        super::vals::WhiteList::from_bits(val as u16)
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: super::vals::WhiteList) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val.to_bits() as u32) & 0xffff) << 16usize);
    }
}
impl Default for ObserveAuthen {
    #[inline(always)]
    fn default() -> ObserveAuthen {
        ObserveAuthen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for ObserveAuthen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveAuthen")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveAuthen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveAuthen {
            tz_user: super::vals::ObserveAuthenTzUser,
            tz_ns: super::vals::ObserveAuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: super::vals::WhiteList,
        }
        let proxy = ObserveAuthen {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveAuthenClr(pub u32);
impl ObserveAuthenClr {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone setting"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone setting"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for ObserveAuthenClr {
    #[inline(always)]
    fn default() -> ObserveAuthenClr {
        ObserveAuthenClr(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for ObserveAuthenClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveAuthenClr")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveAuthenClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveAuthenClr {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = ObserveAuthenClr {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveAuthenSet(pub u32);
impl ObserveAuthenSet {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone setting"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone setting"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for ObserveAuthenSet {
    #[inline(always)]
    fn default() -> ObserveAuthenSet {
        ObserveAuthenSet(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for ObserveAuthenSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveAuthenSet")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveAuthenSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveAuthenSet {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = ObserveAuthenSet {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveAuthenTog(pub u32);
impl ObserveAuthenTog {
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> bool {
        let val = (self.0 >> 8usize) & 0x01;
        val != 0
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> bool {
        let val = (self.0 >> 9usize) & 0x01;
        val != 0
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone setting"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone setting"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist settings"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist settings"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for ObserveAuthenTog {
    #[inline(always)]
    fn default() -> ObserveAuthenTog {
        ObserveAuthenTog(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for ObserveAuthenTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveAuthenTog")
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveAuthenTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveAuthenTog {
            tz_user: bool,
            tz_ns: bool,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = ObserveAuthenTog {
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveControl(pub u32);
impl ObserveControl {
    #[doc = "Observe signal selector"]
    #[must_use]
    #[inline(always)]
    pub const fn select(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x01ff;
        val as u16
    }
    #[doc = "Observe signal selector"]
    #[inline(always)]
    pub const fn set_select(&mut self, val: u16) {
        self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
    }
    #[doc = "Observe raw signal"]
    #[must_use]
    #[inline(always)]
    pub const fn raw(&self) -> super::vals::ObserveControlRaw {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::ObserveControlRaw::from_bits(val as u8)
    }
    #[doc = "Observe raw signal"]
    #[inline(always)]
    pub const fn set_raw(&mut self, val: super::vals::ObserveControlRaw) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
    #[doc = "Invert input signal phase."]
    #[must_use]
    #[inline(always)]
    pub const fn inv(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "Invert input signal phase."]
    #[inline(always)]
    pub const fn set_inv(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "Reset observe divider"]
    #[must_use]
    #[inline(always)]
    pub const fn reset(&self) -> super::vals::ObserveControlReset {
        let val = (self.0 >> 15usize) & 0x01;
        super::vals::ObserveControlReset::from_bits(val as u8)
    }
    #[doc = "Reset observe divider"]
    #[inline(always)]
    pub const fn set_reset(&mut self, val: super::vals::ObserveControlReset) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[must_use]
    #[inline(always)]
    pub const fn divide(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[inline(always)]
    pub const fn set_divide(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Turn off"]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> super::vals::ObserveControlOff {
        let val = (self.0 >> 24usize) & 0x01;
        super::vals::ObserveControlOff::from_bits(val as u8)
    }
    #[doc = "Turn off"]
    #[inline(always)]
    pub const fn set_off(&mut self, val: super::vals::ObserveControlOff) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
    }
}
impl Default for ObserveControl {
    #[inline(always)]
    fn default() -> ObserveControl {
        ObserveControl(0u64 as u32)
    }
}
impl core::fmt::Debug for ObserveControl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveControl")
            .field("select", &self.select())
            .field("raw", &self.raw())
            .field("inv", &self.inv())
            .field("reset", &self.reset())
            .field("divide", &self.divide())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveControl {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveControl {
            select: u16,
            raw: super::vals::ObserveControlRaw,
            inv: bool,
            reset: super::vals::ObserveControlReset,
            divide: u8,
            off: super::vals::ObserveControlOff,
        }
        let proxy = ObserveControl {
            select: self.select(),
            raw: self.raw(),
            inv: self.inv(),
            reset: self.reset(),
            divide: self.divide(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveControlClr(pub u32);
impl ObserveControlClr {
    #[doc = "Observe signal selector"]
    #[must_use]
    #[inline(always)]
    pub const fn select(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x01ff;
        val as u16
    }
    #[doc = "Observe signal selector"]
    #[inline(always)]
    pub const fn set_select(&mut self, val: u16) {
        self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
    }
    #[doc = "Observe raw signal"]
    #[must_use]
    #[inline(always)]
    pub const fn raw(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "Observe raw signal"]
    #[inline(always)]
    pub const fn set_raw(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "Invert input signal phase."]
    #[must_use]
    #[inline(always)]
    pub const fn inv(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "Invert input signal phase."]
    #[inline(always)]
    pub const fn set_inv(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "Reset observe divider"]
    #[must_use]
    #[inline(always)]
    pub const fn reset(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Reset observe divider"]
    #[inline(always)]
    pub const fn set_reset(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[must_use]
    #[inline(always)]
    pub const fn divide(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[inline(always)]
    pub const fn set_divide(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Turn off"]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "Turn off"]
    #[inline(always)]
    pub const fn set_off(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
}
impl Default for ObserveControlClr {
    #[inline(always)]
    fn default() -> ObserveControlClr {
        ObserveControlClr(0u64 as u32)
    }
}
impl core::fmt::Debug for ObserveControlClr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveControlClr")
            .field("select", &self.select())
            .field("raw", &self.raw())
            .field("inv", &self.inv())
            .field("reset", &self.reset())
            .field("divide", &self.divide())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveControlClr {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveControlClr {
            select: u16,
            raw: bool,
            inv: bool,
            reset: bool,
            divide: u8,
            off: bool,
        }
        let proxy = ObserveControlClr {
            select: self.select(),
            raw: self.raw(),
            inv: self.inv(),
            reset: self.reset(),
            divide: self.divide(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveControlSet(pub u32);
impl ObserveControlSet {
    #[doc = "Observe signal selector"]
    #[must_use]
    #[inline(always)]
    pub const fn select(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x01ff;
        val as u16
    }
    #[doc = "Observe signal selector"]
    #[inline(always)]
    pub const fn set_select(&mut self, val: u16) {
        self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
    }
    #[doc = "Observe raw signal"]
    #[must_use]
    #[inline(always)]
    pub const fn raw(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "Observe raw signal"]
    #[inline(always)]
    pub const fn set_raw(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "Invert input signal phase."]
    #[must_use]
    #[inline(always)]
    pub const fn inv(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "Invert input signal phase."]
    #[inline(always)]
    pub const fn set_inv(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "Reset observe divider"]
    #[must_use]
    #[inline(always)]
    pub const fn reset(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Reset observe divider"]
    #[inline(always)]
    pub const fn set_reset(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[must_use]
    #[inline(always)]
    pub const fn divide(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[inline(always)]
    pub const fn set_divide(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Turn off"]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "Turn off"]
    #[inline(always)]
    pub const fn set_off(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
}
impl Default for ObserveControlSet {
    #[inline(always)]
    fn default() -> ObserveControlSet {
        ObserveControlSet(0u64 as u32)
    }
}
impl core::fmt::Debug for ObserveControlSet {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveControlSet")
            .field("select", &self.select())
            .field("raw", &self.raw())
            .field("inv", &self.inv())
            .field("reset", &self.reset())
            .field("divide", &self.divide())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveControlSet {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveControlSet {
            select: u16,
            raw: bool,
            inv: bool,
            reset: bool,
            divide: u8,
            off: bool,
        }
        let proxy = ObserveControlSet {
            select: self.select(),
            raw: self.raw(),
            inv: self.inv(),
            reset: self.reset(),
            divide: self.divide(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveControlTog(pub u32);
impl ObserveControlTog {
    #[doc = "Observe signal selector"]
    #[must_use]
    #[inline(always)]
    pub const fn select(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x01ff;
        val as u16
    }
    #[doc = "Observe signal selector"]
    #[inline(always)]
    pub const fn set_select(&mut self, val: u16) {
        self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
    }
    #[doc = "Observe raw signal"]
    #[must_use]
    #[inline(always)]
    pub const fn raw(&self) -> bool {
        let val = (self.0 >> 12usize) & 0x01;
        val != 0
    }
    #[doc = "Observe raw signal"]
    #[inline(always)]
    pub const fn set_raw(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
    }
    #[doc = "Invert input signal phase."]
    #[must_use]
    #[inline(always)]
    pub const fn inv(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "Invert input signal phase."]
    #[inline(always)]
    pub const fn set_inv(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "Reset observe divider"]
    #[must_use]
    #[inline(always)]
    pub const fn reset(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Reset observe divider"]
    #[inline(always)]
    pub const fn set_reset(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[must_use]
    #[inline(always)]
    pub const fn divide(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Division factor of the divider for observed signal"]
    #[inline(always)]
    pub const fn set_divide(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Turn off"]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> bool {
        let val = (self.0 >> 24usize) & 0x01;
        val != 0
    }
    #[doc = "Turn off"]
    #[inline(always)]
    pub const fn set_off(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
    }
}
impl Default for ObserveControlTog {
    #[inline(always)]
    fn default() -> ObserveControlTog {
        ObserveControlTog(0u64 as u32)
    }
}
impl core::fmt::Debug for ObserveControlTog {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveControlTog")
            .field("select", &self.select())
            .field("raw", &self.raw())
            .field("inv", &self.inv())
            .field("reset", &self.reset())
            .field("divide", &self.divide())
            .field("off", &self.off())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveControlTog {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveControlTog {
            select: u16,
            raw: bool,
            inv: bool,
            reset: bool,
            divide: u8,
            off: bool,
        }
        let proxy = ObserveControlTog {
            select: self.select(),
            raw: self.raw(),
            inv: self.inv(),
            reset: self.reset(),
            divide: self.divide(),
            off: self.off(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Observe status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct ObserveStatus(pub u32);
impl ObserveStatus {
    #[doc = "Observe signal selector"]
    #[must_use]
    #[inline(always)]
    pub const fn select(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0x01ff;
        val as u16
    }
    #[doc = "Observe signal selector"]
    #[inline(always)]
    pub const fn set_select(&mut self, val: u16) {
        self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
    }
    #[doc = "Observe raw signal"]
    #[must_use]
    #[inline(always)]
    pub const fn raw(&self) -> super::vals::ObserveStatusRaw {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::ObserveStatusRaw::from_bits(val as u8)
    }
    #[doc = "Observe raw signal"]
    #[inline(always)]
    pub const fn set_raw(&mut self, val: super::vals::ObserveStatusRaw) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
    #[doc = "Invert"]
    #[must_use]
    #[inline(always)]
    pub const fn inv(&self) -> bool {
        let val = (self.0 >> 13usize) & 0x01;
        val != 0
    }
    #[doc = "Invert"]
    #[inline(always)]
    pub const fn set_inv(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
    }
    #[doc = "Reset state"]
    #[must_use]
    #[inline(always)]
    pub const fn reset(&self) -> super::vals::ObserveStatusReset {
        let val = (self.0 >> 15usize) & 0x01;
        super::vals::ObserveStatusReset::from_bits(val as u8)
    }
    #[doc = "Reset state"]
    #[inline(always)]
    pub const fn set_reset(&mut self, val: super::vals::ObserveStatusReset) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
    }
    #[doc = "Divider for observe signal"]
    #[must_use]
    #[inline(always)]
    pub const fn divide(&self) -> u8 {
        let val = (self.0 >> 16usize) & 0xff;
        val as u8
    }
    #[doc = "Divider for observe signal"]
    #[inline(always)]
    pub const fn set_divide(&mut self, val: u8) {
        self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
    }
    #[doc = "Turn off slice"]
    #[must_use]
    #[inline(always)]
    pub const fn off(&self) -> super::vals::ObserveStatusOff {
        let val = (self.0 >> 24usize) & 0x01;
        super::vals::ObserveStatusOff::from_bits(val as u8)
    }
    #[doc = "Turn off slice"]
    #[inline(always)]
    pub const fn set_off(&mut self, val: super::vals::ObserveStatusOff) {
        self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
    }
    #[doc = "frequency measurement done flag"]
    #[must_use]
    #[inline(always)]
    pub const fn freq_measure_done(&self) -> super::vals::FreqMeasureDone {
        let val = (self.0 >> 25usize) & 0x01;
        super::vals::FreqMeasureDone::from_bits(val as u8)
    }
    #[doc = "frequency measurement done flag"]
    #[inline(always)]
    pub const fn set_freq_measure_done(&mut self, val: super::vals::FreqMeasureDone) {
        self.0 = (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
    }
    #[doc = "Busy"]
    #[must_use]
    #[inline(always)]
    pub const fn busy(&self) -> super::vals::Busy {
        let val = (self.0 >> 28usize) & 0x01;
        super::vals::Busy::from_bits(val as u8)
    }
    #[doc = "Busy"]
    #[inline(always)]
    pub const fn set_busy(&mut self, val: super::vals::Busy) {
        self.0 = (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
    }
    #[doc = "Update Forward"]
    #[must_use]
    #[inline(always)]
    pub const fn updated_forward(&self) -> bool {
        let val = (self.0 >> 29usize) & 0x01;
        val != 0
    }
    #[doc = "Update Forward"]
    #[inline(always)]
    pub const fn set_updated_forward(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
    }
    #[doc = "Busy"]
    #[must_use]
    #[inline(always)]
    pub const fn changing(&self) -> bool {
        let val = (self.0 >> 31usize) & 0x01;
        val != 0
    }
    #[doc = "Busy"]
    #[inline(always)]
    pub const fn set_changing(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
    }
}
impl Default for ObserveStatus {
    #[inline(always)]
    fn default() -> ObserveStatus {
        ObserveStatus(0u64 as u32)
    }
}
impl core::fmt::Debug for ObserveStatus {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ObserveStatus")
            .field("select", &self.select())
            .field("raw", &self.raw())
            .field("inv", &self.inv())
            .field("reset", &self.reset())
            .field("divide", &self.divide())
            .field("off", &self.off())
            .field("freq_measure_done", &self.freq_measure_done())
            .field("busy", &self.busy())
            .field("updated_forward", &self.updated_forward())
            .field("changing", &self.changing())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for ObserveStatus {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct ObserveStatus {
            select: u16,
            raw: super::vals::ObserveStatusRaw,
            inv: bool,
            reset: super::vals::ObserveStatusReset,
            divide: u8,
            off: super::vals::ObserveStatusOff,
            freq_measure_done: super::vals::FreqMeasureDone,
            busy: super::vals::Busy,
            updated_forward: bool,
            changing: bool,
        }
        let proxy = ObserveStatus {
            select: self.select(),
            raw: self.raw(),
            inv: self.inv(),
            reset: self.reset(),
            divide: self.divide(),
            off: self.off(),
            freq_measure_done: self.freq_measure_done(),
            busy: self.busy(),
            updated_forward: self.updated_forward(),
            changing: self.changing(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock Source access control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllAuthen(pub u32);
impl OscpllAuthen {
    #[doc = "CPULPM mode enable"]
    #[must_use]
    #[inline(always)]
    pub const fn cpulpm_mode(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "CPULPM mode enable"]
    #[inline(always)]
    pub const fn set_cpulpm_mode(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
    #[doc = "Auto mode enable"]
    #[must_use]
    #[inline(always)]
    pub const fn auto_ctrl(&self) -> bool {
        let val = (self.0 >> 3usize) & 0x01;
        val != 0
    }
    #[doc = "Auto mode enable"]
    #[inline(always)]
    pub const fn set_auto_ctrl(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
    }
    #[doc = "User access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_user(&self) -> super::vals::OscpllAuthenTzUser {
        let val = (self.0 >> 8usize) & 0x01;
        super::vals::OscpllAuthenTzUser::from_bits(val as u8)
    }
    #[doc = "User access permission"]
    #[inline(always)]
    pub const fn set_tz_user(&mut self, val: super::vals::OscpllAuthenTzUser) {
        self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
    }
    #[doc = "Non-secure access permission"]
    #[must_use]
    #[inline(always)]
    pub const fn tz_ns(&self) -> super::vals::OscpllAuthenTzNs {
        let val = (self.0 >> 9usize) & 0x01;
        super::vals::OscpllAuthenTzNs::from_bits(val as u8)
    }
    #[doc = "Non-secure access permission"]
    #[inline(always)]
    pub const fn set_tz_ns(&mut self, val: super::vals::OscpllAuthenTzNs) {
        self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
    }
    #[doc = "Lock TrustZone settings"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_tz(&self) -> bool {
        let val = (self.0 >> 11usize) & 0x01;
        val != 0
    }
    #[doc = "Lock TrustZone settings"]
    #[inline(always)]
    pub const fn set_lock_tz(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
    }
    #[doc = "Lock white list"]
    #[must_use]
    #[inline(always)]
    pub const fn lock_list(&self) -> bool {
        let val = (self.0 >> 15usize) & 0x01;
        val != 0
    }
    #[doc = "Lock white list"]
    #[inline(always)]
    pub const fn set_lock_list(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
    }
    #[doc = "Whitelist"]
    #[must_use]
    #[inline(always)]
    pub const fn white_list(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Whitelist"]
    #[inline(always)]
    pub const fn set_white_list(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for OscpllAuthen {
    #[inline(always)]
    fn default() -> OscpllAuthen {
        OscpllAuthen(4294901760u64 as u32)
    }
}
impl core::fmt::Debug for OscpllAuthen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllAuthen")
            .field("cpulpm_mode", &self.cpulpm_mode())
            .field("auto_ctrl", &self.auto_ctrl())
            .field("tz_user", &self.tz_user())
            .field("tz_ns", &self.tz_ns())
            .field("lock_tz", &self.lock_tz())
            .field("lock_list", &self.lock_list())
            .field("white_list", &self.white_list())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllAuthen {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllAuthen {
            cpulpm_mode: bool,
            auto_ctrl: bool,
            tz_user: super::vals::OscpllAuthenTzUser,
            tz_ns: super::vals::OscpllAuthenTzNs,
            lock_tz: bool,
            lock_list: bool,
            white_list: u16,
        }
        let proxy = OscpllAuthen {
            cpulpm_mode: self.cpulpm_mode(),
            auto_ctrl: self.auto_ctrl(),
            tz_user: self.tz_user(),
            tz_ns: self.tz_ns(),
            lock_tz: self.lock_tz(),
            lock_list: self.lock_list(),
            white_list: self.white_list(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock source direct control"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllDirect(pub u32);
impl OscpllDirect {
    #[doc = "Turn on clock source"]
    #[must_use]
    #[inline(always)]
    pub const fn on(&self) -> super::vals::OscpllDirectOn {
        let val = (self.0 >> 0usize) & 0x01;
        super::vals::OscpllDirectOn::from_bits(val as u8)
    }
    #[doc = "Turn on clock source"]
    #[inline(always)]
    pub const fn set_on(&mut self, val: super::vals::OscpllDirectOn) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
    }
}
impl Default for OscpllDirect {
    #[inline(always)]
    fn default() -> OscpllDirect {
        OscpllDirect(1u64 as u32)
    }
}
impl core::fmt::Debug for OscpllDirect {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllDirect")
            .field("on", &self.on())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllDirect {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllDirect {
            on: super::vals::OscpllDirectOn,
        }
        let proxy = OscpllDirect { on: self.on() };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock source low power mode setting"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllLpm0(pub u32);
impl OscpllLpm0 {
    #[doc = "Clock Source LPM in DOMAIN0"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d0(&self) -> super::vals::OscpllLpm0LpmSettingD0 {
        let val = (self.0 >> 0usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD0::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN0"]
    #[inline(always)]
    pub const fn set_lpm_setting_d0(&mut self, val: super::vals::OscpllLpm0LpmSettingD0) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
    }
    #[doc = "Clock Source LPM in DOMAIN1"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d1(&self) -> super::vals::OscpllLpm0LpmSettingD1 {
        let val = (self.0 >> 4usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD1::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN1"]
    #[inline(always)]
    pub const fn set_lpm_setting_d1(&mut self, val: super::vals::OscpllLpm0LpmSettingD1) {
        self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
    }
    #[doc = "Clock Source LPM in DOMAIN2"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d2(&self) -> super::vals::OscpllLpm0LpmSettingD2 {
        let val = (self.0 >> 8usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD2::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN2"]
    #[inline(always)]
    pub const fn set_lpm_setting_d2(&mut self, val: super::vals::OscpllLpm0LpmSettingD2) {
        self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
    }
    #[doc = "Clock Source LPM in DOMAIN3"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d3(&self) -> super::vals::OscpllLpm0LpmSettingD3 {
        let val = (self.0 >> 12usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD3::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN3"]
    #[inline(always)]
    pub const fn set_lpm_setting_d3(&mut self, val: super::vals::OscpllLpm0LpmSettingD3) {
        self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
    }
    #[doc = "Clock Source LPM in DOMAIN4"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d4(&self) -> super::vals::OscpllLpm0LpmSettingD4 {
        let val = (self.0 >> 16usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD4::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN4"]
    #[inline(always)]
    pub const fn set_lpm_setting_d4(&mut self, val: super::vals::OscpllLpm0LpmSettingD4) {
        self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
    }
    #[doc = "Clock Source LPM in DOMAIN5"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d5(&self) -> super::vals::OscpllLpm0LpmSettingD5 {
        let val = (self.0 >> 20usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD5::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN5"]
    #[inline(always)]
    pub const fn set_lpm_setting_d5(&mut self, val: super::vals::OscpllLpm0LpmSettingD5) {
        self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
    }
    #[doc = "Clock Source LPM in DOMAIN6"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d6(&self) -> super::vals::OscpllLpm0LpmSettingD6 {
        let val = (self.0 >> 24usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD6::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN6"]
    #[inline(always)]
    pub const fn set_lpm_setting_d6(&mut self, val: super::vals::OscpllLpm0LpmSettingD6) {
        self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
    }
    #[doc = "Clock Source LPM in DOMAIN7"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d7(&self) -> super::vals::OscpllLpm0LpmSettingD7 {
        let val = (self.0 >> 28usize) & 0x07;
        super::vals::OscpllLpm0LpmSettingD7::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN7"]
    #[inline(always)]
    pub const fn set_lpm_setting_d7(&mut self, val: super::vals::OscpllLpm0LpmSettingD7) {
        self.0 = (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
    }
}
impl Default for OscpllLpm0 {
    #[inline(always)]
    fn default() -> OscpllLpm0 {
        OscpllLpm0(0u64 as u32)
    }
}
impl core::fmt::Debug for OscpllLpm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllLpm0")
            .field("lpm_setting_d0", &self.lpm_setting_d0())
            .field("lpm_setting_d1", &self.lpm_setting_d1())
            .field("lpm_setting_d2", &self.lpm_setting_d2())
            .field("lpm_setting_d3", &self.lpm_setting_d3())
            .field("lpm_setting_d4", &self.lpm_setting_d4())
            .field("lpm_setting_d5", &self.lpm_setting_d5())
            .field("lpm_setting_d6", &self.lpm_setting_d6())
            .field("lpm_setting_d7", &self.lpm_setting_d7())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllLpm0 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllLpm0 {
            lpm_setting_d0: super::vals::OscpllLpm0LpmSettingD0,
            lpm_setting_d1: super::vals::OscpllLpm0LpmSettingD1,
            lpm_setting_d2: super::vals::OscpllLpm0LpmSettingD2,
            lpm_setting_d3: super::vals::OscpllLpm0LpmSettingD3,
            lpm_setting_d4: super::vals::OscpllLpm0LpmSettingD4,
            lpm_setting_d5: super::vals::OscpllLpm0LpmSettingD5,
            lpm_setting_d6: super::vals::OscpllLpm0LpmSettingD6,
            lpm_setting_d7: super::vals::OscpllLpm0LpmSettingD7,
        }
        let proxy = OscpllLpm0 {
            lpm_setting_d0: self.lpm_setting_d0(),
            lpm_setting_d1: self.lpm_setting_d1(),
            lpm_setting_d2: self.lpm_setting_d2(),
            lpm_setting_d3: self.lpm_setting_d3(),
            lpm_setting_d4: self.lpm_setting_d4(),
            lpm_setting_d5: self.lpm_setting_d5(),
            lpm_setting_d6: self.lpm_setting_d6(),
            lpm_setting_d7: self.lpm_setting_d7(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "clock source low power mode setting"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllLpm1(pub u32);
impl OscpllLpm1 {
    #[doc = "Clock Source LPM in DOMAIN8"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d8(&self) -> super::vals::OscpllLpm1LpmSettingD8 {
        let val = (self.0 >> 0usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD8::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN8"]
    #[inline(always)]
    pub const fn set_lpm_setting_d8(&mut self, val: super::vals::OscpllLpm1LpmSettingD8) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
    }
    #[doc = "Clock Source LPM in DOMAIN9"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d9(&self) -> super::vals::OscpllLpm1LpmSettingD9 {
        let val = (self.0 >> 4usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD9::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN9"]
    #[inline(always)]
    pub const fn set_lpm_setting_d9(&mut self, val: super::vals::OscpllLpm1LpmSettingD9) {
        self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
    }
    #[doc = "Clock Source LPM in DOMAIN10"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d10(&self) -> super::vals::OscpllLpm1LpmSettingD10 {
        let val = (self.0 >> 8usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD10::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN10"]
    #[inline(always)]
    pub const fn set_lpm_setting_d10(&mut self, val: super::vals::OscpllLpm1LpmSettingD10) {
        self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
    }
    #[doc = "Clock Source LPM in DOMAIN11"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d11(&self) -> super::vals::OscpllLpm1LpmSettingD11 {
        let val = (self.0 >> 12usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD11::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN11"]
    #[inline(always)]
    pub const fn set_lpm_setting_d11(&mut self, val: super::vals::OscpllLpm1LpmSettingD11) {
        self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
    }
    #[doc = "Clock Source LPM in DOMAIN12"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d12(&self) -> super::vals::OscpllLpm1LpmSettingD12 {
        let val = (self.0 >> 16usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD12::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN12"]
    #[inline(always)]
    pub const fn set_lpm_setting_d12(&mut self, val: super::vals::OscpllLpm1LpmSettingD12) {
        self.0 = (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
    }
    #[doc = "Clock Source LPM in DOMAIN13"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d13(&self) -> super::vals::OscpllLpm1LpmSettingD13 {
        let val = (self.0 >> 20usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD13::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN13"]
    #[inline(always)]
    pub const fn set_lpm_setting_d13(&mut self, val: super::vals::OscpllLpm1LpmSettingD13) {
        self.0 = (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
    }
    #[doc = "Clock Source LPM in DOMAIN14"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d14(&self) -> super::vals::OscpllLpm1LpmSettingD14 {
        let val = (self.0 >> 24usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD14::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN14"]
    #[inline(always)]
    pub const fn set_lpm_setting_d14(&mut self, val: super::vals::OscpllLpm1LpmSettingD14) {
        self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
    }
    #[doc = "Clock Source LPM in DOMAIN15"]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_d15(&self) -> super::vals::OscpllLpm1LpmSettingD15 {
        let val = (self.0 >> 28usize) & 0x07;
        super::vals::OscpllLpm1LpmSettingD15::from_bits(val as u8)
    }
    #[doc = "Clock Source LPM in DOMAIN15"]
    #[inline(always)]
    pub const fn set_lpm_setting_d15(&mut self, val: super::vals::OscpllLpm1LpmSettingD15) {
        self.0 = (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
    }
}
impl Default for OscpllLpm1 {
    #[inline(always)]
    fn default() -> OscpllLpm1 {
        OscpllLpm1(0u64 as u32)
    }
}
impl core::fmt::Debug for OscpllLpm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllLpm1")
            .field("lpm_setting_d8", &self.lpm_setting_d8())
            .field("lpm_setting_d9", &self.lpm_setting_d9())
            .field("lpm_setting_d10", &self.lpm_setting_d10())
            .field("lpm_setting_d11", &self.lpm_setting_d11())
            .field("lpm_setting_d12", &self.lpm_setting_d12())
            .field("lpm_setting_d13", &self.lpm_setting_d13())
            .field("lpm_setting_d14", &self.lpm_setting_d14())
            .field("lpm_setting_d15", &self.lpm_setting_d15())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllLpm1 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllLpm1 {
            lpm_setting_d8: super::vals::OscpllLpm1LpmSettingD8,
            lpm_setting_d9: super::vals::OscpllLpm1LpmSettingD9,
            lpm_setting_d10: super::vals::OscpllLpm1LpmSettingD10,
            lpm_setting_d11: super::vals::OscpllLpm1LpmSettingD11,
            lpm_setting_d12: super::vals::OscpllLpm1LpmSettingD12,
            lpm_setting_d13: super::vals::OscpllLpm1LpmSettingD13,
            lpm_setting_d14: super::vals::OscpllLpm1LpmSettingD14,
            lpm_setting_d15: super::vals::OscpllLpm1LpmSettingD15,
        }
        let proxy = OscpllLpm1 {
            lpm_setting_d8: self.lpm_setting_d8(),
            lpm_setting_d9: self.lpm_setting_d9(),
            lpm_setting_d10: self.lpm_setting_d10(),
            lpm_setting_d11: self.lpm_setting_d11(),
            lpm_setting_d12: self.lpm_setting_d12(),
            lpm_setting_d13: self.lpm_setting_d13(),
            lpm_setting_d14: self.lpm_setting_d14(),
            lpm_setting_d15: self.lpm_setting_d15(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "LPM setting of current CPU domain"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllLpmCur(pub u32);
impl OscpllLpmCur {
    #[doc = "LPM settings value for current CPU domain that is reading this register."]
    #[must_use]
    #[inline(always)]
    pub const fn lpm_setting_cur(&self) -> super::vals::OscpllLpmCurLpmSettingCur {
        let val = (self.0 >> 0usize) & 0x07;
        super::vals::OscpllLpmCurLpmSettingCur::from_bits(val as u8)
    }
    #[doc = "LPM settings value for current CPU domain that is reading this register."]
    #[inline(always)]
    pub const fn set_lpm_setting_cur(&mut self, val: super::vals::OscpllLpmCurLpmSettingCur) {
        self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
    }
}
impl Default for OscpllLpmCur {
    #[inline(always)]
    fn default() -> OscpllLpmCur {
        OscpllLpmCur(0u64 as u32)
    }
}
impl core::fmt::Debug for OscpllLpmCur {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllLpmCur")
            .field("lpm_setting_cur", &self.lpm_setting_cur())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllLpmCur {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllLpmCur {
            lpm_setting_cur: super::vals::OscpllLpmCurLpmSettingCur,
        }
        let proxy = OscpllLpmCur {
            lpm_setting_cur: self.lpm_setting_cur(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock source working status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllStatus0(pub u32);
impl OscpllStatus0 {
    #[doc = "Clock source current state"]
    #[must_use]
    #[inline(always)]
    pub const fn on(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "Clock source current state"]
    #[inline(always)]
    pub const fn set_on(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "Clock source active"]
    #[must_use]
    #[inline(always)]
    pub const fn status_early(&self) -> bool {
        let val = (self.0 >> 4usize) & 0x01;
        val != 0
    }
    #[doc = "Clock source active"]
    #[inline(always)]
    pub const fn set_status_early(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
    }
    #[doc = "Clock source ready"]
    #[must_use]
    #[inline(always)]
    pub const fn status_late(&self) -> bool {
        let val = (self.0 >> 5usize) & 0x01;
        val != 0
    }
    #[doc = "Clock source ready"]
    #[inline(always)]
    pub const fn set_status_late(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
    }
    #[doc = "This Clock Source is being used or not."]
    #[must_use]
    #[inline(always)]
    pub const fn in_use(&self) -> super::vals::InUse {
        let val = (self.0 >> 12usize) & 0x01;
        super::vals::InUse::from_bits(val as u8)
    }
    #[doc = "This Clock Source is being used or not."]
    #[inline(always)]
    pub const fn set_in_use(&mut self, val: super::vals::InUse) {
        self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
    }
}
impl Default for OscpllStatus0 {
    #[inline(always)]
    fn default() -> OscpllStatus0 {
        OscpllStatus0(1u64 as u32)
    }
}
impl core::fmt::Debug for OscpllStatus0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllStatus0")
            .field("on", &self.on())
            .field("status_early", &self.status_early())
            .field("status_late", &self.status_late())
            .field("in_use", &self.in_use())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllStatus0 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllStatus0 {
            on: bool,
            status_early: bool,
            status_late: bool,
            in_use: super::vals::InUse,
        }
        let proxy = OscpllStatus0 {
            on: self.on(),
            status_early: self.status_early(),
            status_late: self.status_late(),
            in_use: self.in_use(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
#[doc = "Clock source domain status"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OscpllStatus1(pub u32);
impl OscpllStatus1 {
    #[doc = "Domain active"]
    #[must_use]
    #[inline(always)]
    pub const fn domain_active(&self) -> u16 {
        let val = (self.0 >> 0usize) & 0xffff;
        val as u16
    }
    #[doc = "Domain active"]
    #[inline(always)]
    pub const fn set_domain_active(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
    }
    #[doc = "Domain enable"]
    #[must_use]
    #[inline(always)]
    pub const fn domain_enable(&self) -> u16 {
        let val = (self.0 >> 16usize) & 0xffff;
        val as u16
    }
    #[doc = "Domain enable"]
    #[inline(always)]
    pub const fn set_domain_enable(&mut self, val: u16) {
        self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
    }
}
impl Default for OscpllStatus1 {
    #[inline(always)]
    fn default() -> OscpllStatus1 {
        OscpllStatus1(65535u64 as u32)
    }
}
impl core::fmt::Debug for OscpllStatus1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OscpllStatus1")
            .field("domain_active", &self.domain_active())
            .field("domain_enable", &self.domain_enable())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OscpllStatus1 {
    fn format(&self, f: defmt::Formatter) {
        #[derive(defmt :: Format)]
        struct OscpllStatus1 {
            domain_active: u16,
            domain_enable: u16,
        }
        let proxy = OscpllStatus1 {
            domain_active: self.domain_active(),
            domain_enable: self.domain_enable(),
        };
        defmt::write!(f, "{}", proxy)
    }
}
